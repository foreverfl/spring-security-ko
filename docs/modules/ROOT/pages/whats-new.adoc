[[new]]
= Spring Security 6.3의 새로운 기능

Spring Security 6.3은 다양한 새로운 기능을 제공합니다.
아래는 이번 릴리스의 주요 내용입니다. 각 기능과 버그 수정에 대한 자세한 목록은 https://github.com/spring-projects/spring-security/releases[릴리스 노트]에서 확인할 수 있습니다.

== 수동적 JDK 직렬화 지원

Spring Security는 JDK 직렬화된 보안 컴포넌트에 대해 지금까지 꽤 공격적인 접근 방식을 취해왔습니다. 각 직렬화 버전을 오직 하나의 Spring Security 마이너 버전에서만 지원했습니다.
이는 JDK 직렬화된 보안 컴포넌트를 사용하고 있다면, 다음 Spring Security 버전으로 업그레이드하기 전에 이들을 제거해야 한다는 것을 의미했습니다. 더 이상 역직렬화가 불가능해지기 때문입니다.

이제 Spring Security가 6개월마다 마이너 릴리스를 수행하면서 이 문제가 더 큰 골치거리가 되었습니다.
이를 해결하기 위해 Spring Security는 이제 JSON 직렬화와 마찬가지로 https://spring.io/blog/2024/01/19/spring-security-6-3-adds-passive-jdk-serialization-deserialization-for[JDK 직렬화에 대해 수동적 접근 방식을 유지]할 것입니다. 이로 인해 더 원활한 업그레이드가 가능해집니다.

== 권한 부여

최근 몇 번의 릴리스에서 지속적으로 다뤄온 주제는 Spring Security의 권한 부여 서브시스템을 리팩토링하고 개선하는 것이었습니다.
`AccessDecisionManager` API를 ``AuthorizationManager``로 대체하는 것으로 시작해, 이제는 몇 가지 흥미로운 새로운 기능을 추가할 수 있는 단계에 이르렀습니다.

=== 어노테이션 매개변수 - https://github.com/spring-projects/spring-security/issues/14480[#14480]

6.3의 첫 번째 기능은 https://github.com/spring-projects/spring-security/issues/14480[어노테이션 매개변수 지원]입니다.
Spring Security의 xref:servlet/authorization/method-security.adoc#meta-annotations[메타 어노테이션] 지원을 고려해 보세요. 다음과 같은 예시가 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@PreAuthorize("hasAuthority('SCOPE_message:read')")
public @interface HasMessageRead {}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@PreAuthorize("hasAuthority('SCOPE_message:read')")
annotation class HasMessageRead
----
======

이 릴리스 이전에는 이런 방식이 코드베이스 전체에서 광범위하게 사용될 때만 유용했습니다.
하지만 이제는 xref:servlet/authorization/method-security.adoc#_templating_meta_annotation_expressions[매개변수를 추가]할 수 있게 되었습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@PreAuthorize("hasAuthority('SCOPE_{scope}')")
public @interface HasScope {
	String scope();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@PreAuthorize("hasAuthority('SCOPE_{scope}')")
annotation class HasScope (val scope:String)
----
======

이를 통해 다음과 같은 방식으로 사용할 수 있게 되었습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@HasScope("message:read")
public String method() { ... }
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@HasScope("message:read")
fun method(): String { ... }
----
======

이렇게 하면 SpEL 표현식을 더 많은 곳에 적용할 수 있게 됩니다.

=== 반환 값 보안 - https://github.com/spring-projects/spring-security/issues/14596[#14596], https://github.com/spring-projects/spring-security/issues/14597[#14597]

Spring Security의 초기부터 xref:servlet/authorization/method-security.adoc#use-preauthorize[Spring 빈에 ``@PreAuthorize``와 ``@PostAuthorize``를 어노테이션으로 추가]할 수 있었습니다.
하지만 컨트롤러, 서비스, 리포지토리만이 보안을 적용하고 싶은 대상은 아닙니다.
예를 들어, 관리자만 `Order#getPayment` 메서드를 호출할 수 있어야 하는 `Order` 도메인 객체는 어떨까요?

이제 6.3에서는 https://github.com/spring-projects/spring-security/issues/14597[이러한 메서드에도 어노테이션을 추가]할 수 있습니다.
먼저 Spring 빈에 하듯이 `getPayment` 메서드에 어노테이션을 추가합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class Order {

	@HasScope("payment:read")
	Payment getPayment() { ... }

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class Order {

	@HasScope("payment:read")
	fun getPayment(): Payment { ... }

}
----
======

그리고 나서 xref:servlet/authorization/method-security.adoc#authorize-object[Spring Data 리포지토리에 ``@AuthorizeReturnObject``를 어노테이션으로 추가]합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public interface OrderRepository implements CrudRepository<Order, String> {

	@AuthorizeReturnObject
	Optional<Order> findOrderById(String id);

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----

interface OrderRepository : CrudRepository<Order, String> {
    @AuthorizeReturnObject
    fun findOrderById(id: String?): Optional<Order?>?
}
----
======

이 시점에서 Spring Security는 https://github.com/spring-projects/spring-security/issues/14596[`Order` 인스턴스를 프록시하는 방식]으로 ``findOrderById``에서 반환된 모든 ``Order``를 보호합니다.

=== 오류 처리 - https://github.com/spring-projects/spring-security/issues/14598[#14598], https://github.com/spring-projects/spring-security/issues/14600[#14600], https://github.com/spring-projects/spring-security/issues/14601[#14601]

이번 릴리스에서는 새로운 메서드 보안 어노테이션을 통해 https://github.com/spring-projects/spring-security/issues/14601[메서드 레벨에서 실패를 가로채고 처리]할 수 있습니다.

xref:servlet/authorization/method-security.adoc#fallback-values-authorization-denied[메서드에 `@HandleAuthorizationDenied` 어노테이션을 추가]하면 다음과 같이 사용할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class Payment {
    @HandleAuthorizationDenied(handlerClass=Mask.class)
    @PreAuthorize("hasAuthority('card:read')")
    public String getCreditCardNumber() { ... }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class Payment {
    @HandleAuthorizationDenied(handlerClass=Mask.class)
    @PreAuthorize("hasAuthority('card:read')")
    fun getCreditCardNumber(): String { ... }
}
----
======

그리고 `Mask` 빈을 등록합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class Mask implements MethodAuthorizationDeniedHandler {
	@Override
    public Object handleDeniedInvocation(MethodInvocation invocation, AuthorizationResult result) {
		return "***";
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
class Mask : MethodAuthorizationDeniedHandler {
    fun handleDeniedInvocation(invocation: MethodInvocation?, result: AuthorizationResult?): Any = "***"
}
----
======

이렇게 하면 권한이 없는 `Payment#getCreditCardNumber` 호출은 번호 대신 ``***``를 반환합니다.

이 모든 기능이 함께 작동하는 것을 https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/java/data[최신 Spring Security Data 샘플]에서 확인할 수 있습니다.

== 손상된 비밀번호 확인 - https://github.com/spring-projects/spring-security/issues/7395[#7395]

사용자가 비밀번호를 선택하도록 허용한다면, 그 비밀번호가 이미 손상되지 않았는지 확인하는 것이 매우 중요합니다.
Spring Security 6.3에서는 xref:features/authentication/password-storage.adoc#authentication-compromised-password-check[`CompromisedPasswordChecker` 빈을 게시]하는 것만으로 이를 간단히 구현할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public CompromisedPasswordChecker compromisedPasswordChecker() {
    return new HaveIBeenPwnedRestApiPasswordChecker();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun compromisedPasswordChecker(): CompromisedPasswordChecker = HaveIBeenPwnedRestApiPasswordChecker()
----
======

== ``spring-security-rsa``가 이제 Spring Security의 일부가 됨 - https://github.com/spring-projects/spring-security/issues/14202[#14202]

2017년부터 Spring Security는 다양한 Spring Security 확장 기능을 Spring Security 본체에 통합하는 장기 프로젝트를 진행해 왔습니다.
6.3에서 ``spring-security-rsa``가 이 프로젝트들 중 최신으로 통합되었으며, 이는 팀이 장기적으로 이를 유지하고 기능을 추가하는 데 도움이 될 것입니다.

``spring-security-rsa``는 여러 가지 https://github.com/spring-projects/spring-security/blob/main/crypto/src/main/java/org/springframework/security/crypto/encrypt/RsaSecretEncryptor.java[유용한 `BytesEncryptor`] https://github.com/spring-projects/spring-security/blob/main/crypto/src/main/java/org/springframework/security/crypto/encrypt/RsaRawEncryptor.java[구현]과 함께 https://github.com/spring-projects/spring-security/blob/main/crypto/src/main/java/org/springframework/security/crypto/encrypt/KeyStoreKeyFactory.java[`KeyStore`를 다루는 더 간단한 API]를 제공합니다.

== OAuth 2.0 토큰 전환 권한 부여 - https://github.com/spring-projects/spring-security/issues/5199[#5199]

Spring Security에서 https://github.com/spring-projects/spring-security/issues/5199[가장 많은 투표를 받은 OAuth 2.0 기능] 중 하나가 이제 6.3에 구현되었습니다. 바로 https://datatracker.ietf.org/doc/html/rfc8693#section-2[OAuth 2.0 토큰 교환 그랜트] 지원입니다.

xref:servlet/oauth2/client/authorization-grants.adoc#token-exchange-grant-access-token[토큰 교환을 위해 구성된 모든 클라이언트]에 대해, Spring Security에서 이를 활성화하려면 ``OAuth2AuthorizedClientManager``에 `TokenExchangeAuthorizedClientProvider` 인스턴스를 다음과 같이 추가하면 됩니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public OAuth2AuthorizedClientProvider tokenExchange() {
	return new TokenExchangeOAuth2AuthorizedClientProvider();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun tokenExchange(): OAuth2AuthorizedClientProvider = TokenExchangeOAuth2AuthorizedClientProvider()
----
======

그런 다음 xref:servlet/oauth2/client/authorized-clients.adoc#oauth2Client-registered-authorized-client[`@RegisteredOAuth2AuthorizedClient` 어노테이션을 평소처럼 사용]하여 리소스 서버에 필요한 확장된 권한을 가진 적절한 토큰을 검색할 수 있습니다.