[[concurrency]]
= 동시성 지원

대부분의 환경에서 보안은 `Thread` 단위로 저장됩니다.
이는 새로운 ``Thread``에서 작업이 수행될 때 ``SecurityContext``가 손실된다는 것을 의미합니다.
Spring Security는 사용자가 이를 쉽게 처리할 수 있도록 일부 인프라를 제공합니다.
Spring Security는 다중 스레드 환경에서 Spring Security를 사용하기 위한 저수준 추상화를 제공합니다.
실제로 이는 Spring Security가 xref:servlet/integrations/servlet-api.adoc#servletapi-start-runnable[AsyncContext.start(Runnable)]과 xref:servlet/integrations/mvc.adoc#mvc-async[Spring MVC Async Integration]을 통합하기 위해 구축한 기반입니다.

== DelegatingSecurityContextRunnable

Spring Security의 동시성 지원에서 가장 기본적인 구성 요소 중 하나는 ``DelegatingSecurityContextRunnable``입니다.
이는 위임된 ``Runnable``을 감싸서 지정된 ``SecurityContext``로 ``SecurityContextHolder``를 초기화합니다.
그런 다음 위임된 Runnable을 실행하고 나중에 ``SecurityContextHolder``를 확실히 정리합니다.
``DelegatingSecurityContextRunnable``의 모습은 다음과 같습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public void run() {
	try {
		SecurityContextHolder.setContext(securityContext);
		delegate.run();
	} finally {
		SecurityContextHolder.clearContext();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
fun run() {
    try {
        SecurityContextHolder.setContext(securityContext)
        delegate.run()
    } finally {
        SecurityContextHolder.clearContext()
    }
}
----
======

매우 단순하지만, SecurityContext를 한 Thread에서 다른 Thread로 원활하게 전달할 수 있게 해줍니다.
이는 대부분의 경우 SecurityContextHolder가 Thread 단위로 작동하기 때문에 중요합니다.
예를 들어, Spring Security의 xref:servlet/appendix/namespace/method-security.adoc#nsa-global-method-security[<global-method-security>] 지원을 사용하여 서비스 중 하나를 보호했을 수 있습니다.
이제 현재 ``Thread``의 ``SecurityContext``를 보안 서비스를 호출하는 ``Thread``로 쉽게 전달할 수 있습니다.
이를 수행하는 방법의 예는 다음과 같습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Runnable originalRunnable = new Runnable() {
	public void run() {
		// 보안 서비스 호출
	}
};

SecurityContext context = SecurityContextHolder.getContext();
DelegatingSecurityContextRunnable wrappedRunnable =
	new DelegatingSecurityContextRunnable(originalRunnable, context);

new Thread(wrappedRunnable).start();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val originalRunnable = Runnable {
    // 보안 서비스 호출
}
val context: SecurityContext = SecurityContextHolder.getContext()
val wrappedRunnable = DelegatingSecurityContextRunnable(originalRunnable, context)

Thread(wrappedRunnable).start()
----
======

위의 코드는 다음 단계를 수행합니다:

* 보안 서비스를 호출할 ``Runnable``을 생성합니다. 이는 Spring Security를 인식하지 않습니다.
* ``SecurityContextHolder``에서 사용하고자 하는 ``SecurityContext``를 가져와 ``DelegatingSecurityContextRunnable``을 초기화합니다.
* ``DelegatingSecurityContextRunnable``을 사용하여 Thread를 생성합니다.
* 생성한 Thread를 시작합니다.

``SecurityContextHolder``의 ``SecurityContext``로 ``DelegatingSecurityContextRunnable``을 생성하는 것이 일반적이므로 이를 위한 단축 생성자가 있습니다.
다음 코드는 위의 코드와 동일합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
Runnable originalRunnable = new Runnable() {
	public void run() {
		// 보안 서비스 호출
	}
};

DelegatingSecurityContextRunnable wrappedRunnable =
	new DelegatingSecurityContextRunnable(originalRunnable);

new Thread(wrappedRunnable).start();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val originalRunnable = Runnable {
    // 보안 서비스 호출
}

val wrappedRunnable = DelegatingSecurityContextRunnable(originalRunnable)

Thread(wrappedRunnable).start()
----
======

이 코드는 사용하기 쉽지만 여전히 Spring Security를 사용한다는 것을 알아야 합니다.
다음 섹션에서는 ``DelegatingSecurityContextExecutor``를 사용하여 Spring Security 사용을 숨기는 방법을 살펴보겠습니다.

== DelegatingSecurityContextExecutor

이전 섹션에서 ``DelegatingSecurityContextRunnable``을 사용하기 쉽다는 것을 알았지만, Spring Security를 사용한다는 것을 알아야 한다는 점에서 이상적이지 않았습니다.
``DelegatingSecurityContextExecutor``가 어떻게 Spring Security 사용을 숨길 수 있는지 살펴보겠습니다.

``DelegatingSecurityContextExecutor``의 설계는 ``DelegatingSecurityContextRunnable``과 매우 유사하지만 위임된 ``Runnable`` 대신 위임된 ``Executor``를 받습니다.
사용 예는 다음과 같습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
SecurityContext context = SecurityContextHolder.createEmptyContext();
Authentication authentication =
	UsernamePasswordAuthenticationToken.authenticated("user","doesnotmatter", AuthorityUtils.createAuthorityList("ROLE_USER"));
context.setAuthentication(authentication);

SimpleAsyncTaskExecutor delegateExecutor =
	new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
	new DelegatingSecurityContextExecutor(delegateExecutor, context);

Runnable originalRunnable = new Runnable() {
	public void run() {
		// 보안 서비스 호출
	}
};

executor.execute(originalRunnable);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val context: SecurityContext = SecurityContextHolder.createEmptyContext()
val authentication: Authentication =
    UsernamePasswordAuthenticationToken("user", "doesnotmatter", AuthorityUtils.createAuthorityList("ROLE_USER"))
context.authentication = authentication

val delegateExecutor = SimpleAsyncTaskExecutor()
val executor = DelegatingSecurityContextExecutor(delegateExecutor, context)

val originalRunnable = Runnable {
    // 보안 서비스 호출
}

executor.execute(originalRunnable)
----
======

이 코드는 다음 단계를 수행합니다:

* ``DelegatingSecurityContextExecutor``에 사용할 ``SecurityContext``를 생성합니다. 이 예제에서는 ``SecurityContext``를 직접 생성했지만, ``SecurityContext``를 어디서 어떻게 얻는지는 중요하지 않습니다(예: ``SecurityContextHolder``에서 얻을 수도 있습니다).
* 제출된 ``Runnable``을 실행하는 delegateExecutor를 생성합니다.
* 마지막으로 ``DelegatingSecurityContextExecutor``를 생성합니다. 이는 execute 메서드에 전달된 모든 Runnable을 ``DelegatingSecurityContextRunnable``로 감싸는 역할을 합니다. 그런 다음 감싸진 Runnable을 delegateExecutor에 전달합니다. 이 경우 동일한 ``SecurityContext``가 ``DelegatingSecurityContextExecutor``에 제출된 모든 Runnable에 사용됩니다. 이는 높은 권한을 가진 사용자로 실행해야 하는 백그라운드 작업을 실행할 때 유용합니다.
* 이 시점에서 "이것이 어떻게 내 코드에서 Spring Security 사용을 숨기나요?"라고 물을 수 있습니다. ``SecurityContext``와 ``DelegatingSecurityContextExecutor``를 직접 생성하는 대신 이미 초기화된 `DelegatingSecurityContextExecutor` 인스턴스를 주입받을 수 있습니다.

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
private Executor executor; // DelegatingSecurityContextExecutor의 인스턴스가 됩니다

public void submitRunnable() {
Runnable originalRunnable = new Runnable() {
	public void run() {
	// 보안 서비스 호출
	}
};
executor.execute(originalRunnable);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Autowired
lateinit var executor: Executor // DelegatingSecurityContextExecutor의 인스턴스가 됩니다

fun submitRunnable() {
    val originalRunnable = Runnable {
        // 보안 서비스 호출
    }
    executor.execute(originalRunnable)
}
----
======

이제 코드는 ``SecurityContext``가 ``Thread``로 전파되고, ``originalRunnable``이 실행되며, 그 후 ``SecurityContextHolder``가 정리된다는 사실을 모릅니다.
이 예제에서는 각 스레드를 실행하는 데 동일한 사용자가 사용됩니다.
``executor.execute(Runnable)``을 호출할 때 ``SecurityContextHolder``의 사용자(즉, 현재 로그인한 사용자)를 사용하여 ``originalRunnable``을 처리하려면 어떻게 해야 할까요?
이는 `DelegatingSecurityContextExecutor` 생성자에서 `SecurityContext` 인자를 제거하면 가능합니다. 예를 들어:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
	new DelegatingSecurityContextExecutor(delegateExecutor);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val delegateExecutor = SimpleAsyncTaskExecutor()
val executor = DelegatingSecurityContextExecutor(delegateExecutor)
----
======

이제 ``executor.execute(Runnable)``이 실행될 때마다 ``SecurityContextHolder``에서 먼저 ``SecurityContext``를 가져온 다음 해당 ``SecurityContext``를 사용하여 ``DelegatingSecurityContextRunnabl`e`을 생성합니다.
이는 ``executor.execute(Runnable)`` 코드를 호출한 사용자와 동일한 사용자로 ``Runnable``을 실행한다는 것을 의미합니다.

== Spring Security 동시성 클래스

Java 동시성 API 및 Spring Task 추상화와의 추가 통합에 대해서는 Javadoc을 참조하세요.
이전 코드를 이해하면 이들은 쉽게 이해할 수 있습니다.

* `DelegatingSecurityContextCallable`
* `DelegatingSecurityContextExecutor`
* `DelegatingSecurityContextExecutorService`
* `DelegatingSecurityContextRunnable`
* `DelegatingSecurityContextScheduledExecutorService`
* `DelegatingSecurityContextSchedulingTaskExecutor`
* `DelegatingSecurityContextAsyncTaskExecutor`
* `DelegatingSecurityContextTaskExecutor`
* `DelegatingSecurityContextTaskScheduler`