[[authentication-password-storage]]
= 비밀번호 저장

Spring Security의 `PasswordEncoder` 인터페이스는 비밀번호를 안전하게 저장할 수 있도록 단방향 변환을 수행합니다.
``PasswordEncoder``는 단방향 변환이므로 양방향 변환이 필요한 경우(예: 데이터베이스 인증에 사용되는 자격 증명 저장)에는 유용하지 않습니다.
일반적으로 ``PasswordEncoder``는 인증 시점에 사용자가 제공한 비밀번호와 비교해야 하는 비밀번호를 저장할 때 사용됩니다.

[[authentication-password-storage-history]]
== 비밀번호 저장 역사

수년에 걸쳐 비밀번호 저장의 표준 메커니즘은 발전해 왔습니다.
초기에는 비밀번호가 평문으로 저장되었습니다.
비밀번호가 저장된 데이터 저장소에 접근하려면 자격 증명이 필요했기 때문에 안전하다고 가정했습니다.
그러나 악의적인 사용자들은 SQL 인젝션과 같은 공격을 통해 대규모 데이터 유출을 일으켜 대량의 사용자 이름과 비밀번호를 얻는 방법을 찾아냈습니다.
더 많은 사용자 자격 증명이 공개되면서 보안 전문가들은 사용자의 비밀번호를 보호하기 위해 더 많은 조치가 필요하다는 것을 깨달았습니다.

그 후 개발자들에게 SHA-256과 같은 단방향 해시 함수를 통해 비밀번호를 저장하도록 하라는 권고가 있었습니다.
사용자가 인증을 시도할 때, 입력한 비밀번호의 해시값과 저장된 해시값을 비교했습니다.
이는 시스템이 비밀번호의 단방향 해시만 저장하면 된다는 것을 의미했습니다.
보안 침해가 발생해도 비밀번호의 단방향 해시만 노출되었습니다.
해시는 단방향이고 해시로부터 비밀번호를 추측하는 것이 계산적으로 어려웠기 때문에, 시스템의 각 비밀번호를 알아내는 것은 노력할 가치가 없었습니다.
이 새로운 시스템을 무력화하기 위해 악의적인 사용자들은 https://en.wikipedia.org/wiki/Rainbow_table[레인보우 테이블]로 알려진 조회 테이블을 만들기로 결정했습니다.
매번 각 비밀번호를 추측하는 작업을 하는 대신, 비밀번호를 한 번 계산하고 조회 테이블에 저장했습니다.

레인보우 테이블의 효과를 줄이기 위해 개발자들은 솔트를 추가한 비밀번호를 사용하도록 권장받았습니다.
해시 함수에 비밀번호만을 입력으로 사용하는 대신, 모든 사용자의 비밀번호에 대해 무작위 바이트(솔트라고 함)가 생성되었습니다.
솔트와 사용자의 비밀번호가 해시 함수를 통과하여 고유한 해시를 생성했습니다.
솔트는 사용자의 비밀번호와 함께 평문으로 저장되었습니다.
그런 다음 사용자가 인증을 시도할 때, 저장된 솔트와 입력한 비밀번호의 해시값을 비교했습니다.
고유한 솔트는 모든 솔트와 비밀번호 조합에 대해 해시가 다르기 때문에 레인보우 테이블이 더 이상 효과적이지 않다는 것을 의미했습니다.

현대에 와서는 암호화 해시(SHA-256과 같은)가 더 이상 안전하지 않다는 것을 알게 되었습니다.
그 이유는 현대의 하드웨어로 초당 수십억 번의 해시 계산을 수행할 수 있기 때문입니다.
이는 각 비밀번호를 개별적으로 쉽게 크랙할 수 있다는 것을 의미합니다.

이제 개발자들은 비밀번호를 저장하기 위해 적응형 단방향 함수를 사용하도록 권장받고 있습니다.
적응형 단방향 함수를 사용한 비밀번호 검증 과정은 의도적으로 리소스를 많이 소모하게 설계되어 있습니다(주로 CPU, 메모리 등 많은 하드웨어 자원을 사용합니다).
적응형 단방향 함수는 하드웨어가 개선됨에 따라 증가할 수 있는 "작업 요소(work factor)"를 조정할 수 있습니다.
시스템에서 비밀번호를 확인하는 데 1초 정도가 걸리도록 "작업 요소"를 조정하는 것이 좋습니다.
이는 공격자가 비밀번호를 크랙하기 어렵게 만들지만, 시스템 성능에 과도한 부담을 주거나 사용자에게 불편을 끼치지 않도록 적절한 절충안이 됩니다.
Spring Security는 "작업 요소"에 대한 좋은 시작점을 제공하려고 했지만, 시스템마다 성능이 크게 다르기 때문에 사용자가 자신의 시스템에 맞게 "작업 요소"를 조정하는 것을 권장합니다.
사용해야 할 적응형 단방향 함수의 예로는 <<authentication-password-storage-bcrypt,bcrypt>>, <<authentication-password-storage-pbkdf2,PBKDF2>>, <<authentication-password-storage-scrypt,scrypt>>, <<authentication-password-storage-argon2,argon2>>가 있습니다.

적응형 단방향 함수는 의도적으로 리소스 집약적이기 때문에, 모든 요청에 대해 사용자 이름과 비밀번호를 검증하면 애플리케이션의 성능을 크게 저하시킬 수 있습니다.
비밀번호 검증을 리소스 집약적으로 만드는 것이 보안을 얻는 방법이기 때문에 Spring Security(또는 다른 라이브러리)가 비밀번호 검증 속도를 높일 수 있는 방법은 없습니다.
개발자는 장기 자격 증명(즉, 사용자 이름과 비밀번호)을 단기 자격 증명(예: 세션, OAuth 토큰 등)을 사용하는 것이 좋습니다.
단기 자격 증명은 보안 손실 없이 빠르게 검증할 수 있습니다.

[[authentication-password-storage-dpe]]
== DelegatingPasswordEncoder

Spring Security 5.0 이전에는 기본 ``PasswordEncoder``가 평문 비밀번호를 요구하는 ``NoOpPasswordEncoder``였습니다.
<<authentication-password-storage-history,비밀번호 역사>> 섹션을 기반으로, 이제 기본 ``PasswordEncoder``가 ``BCryptPasswordEncoder``와 같은 것이 될 것으로 예상할 수 있습니다.
그러나 이는 다음과 같은 세 가지 실제 문제를 무시합니다:

- 많은 애플리케이션이 쉽게 마이그레이션할 수 없는 오래된 비밀번호 인코딩을 사용합니다.
- 비밀번호 저장의 모범 사례는 다시 변경될 것입니다.
- 프레임워크로서 Spring Security는 자주 중대한 변경을 할 수 없습니다.

대신 Spring Security는 ``DelegatingPasswordEncoder``를 도입하여 다음과 같은 모든 문제를 해결합니다:

- 현재 비밀번호 저장 권장 사항을 사용하여 비밀번호가 인코딩되도록 보장합니다.
- 현대적이고 레거시 형식의 비밀번호 검증을 허용합니다.
- 향후 인코딩 업그레이드를 허용합니다.

``PasswordEncoderFactories``를 사용하여 ``DelegatingPasswordEncoder``의 인스턴스를 쉽게 구성할 수 있습니다:

.기본 DelegatingPasswordEncoder 생성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
PasswordEncoder passwordEncoder =
    PasswordEncoderFactories.createDelegatingPasswordEncoder();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val passwordEncoder: PasswordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder()
----
======

또는 자신만의 커스텀 인스턴스를 생성할 수 있습니다:

.커스텀 DelegatingPasswordEncoder 생성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
String idForEncode = "bcrypt";
Map encoders = new HashMap<>();
encoders.put(idForEncode, new BCryptPasswordEncoder());
encoders.put("noop", NoOpPasswordEncoder.getInstance());
encoders.put("pbkdf2", Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_5());
encoders.put("pbkdf2@SpringSecurity_v5_8", Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8());
encoders.put("scrypt", SCryptPasswordEncoder.defaultsForSpringSecurity_v4_1());
encoders.put("scrypt@SpringSecurity_v5_8", SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8());
encoders.put("argon2", Argon2PasswordEncoder.defaultsForSpringSecurity_v5_2());
encoders.put("argon2@SpringSecurity_v5_8", Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8());
encoders.put("sha256", new StandardPasswordEncoder());

PasswordEncoder passwordEncoder =
    new DelegatingPasswordEncoder(idForEncode, encoders);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val idForEncode = "bcrypt"
val encoders: MutableMap<String, PasswordEncoder> = mutableMapOf()
encoders[idForEncode] = BCryptPasswordEncoder()
encoders["noop"] = NoOpPasswordEncoder.getInstance()
encoders["pbkdf2"] = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_5()
encoders["pbkdf2@SpringSecurity_v5_8"] = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8()
encoders["scrypt"] = SCryptPasswordEncoder.defaultsForSpringSecurity_v4_1()
encoders["scrypt@SpringSecurity_v5_8"] = SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8()
encoders["argon2"] = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_2()
encoders["argon2@SpringSecurity_v5_8"] = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8()
encoders["sha256"] = StandardPasswordEncoder()

val passwordEncoder: PasswordEncoder = DelegatingPasswordEncoder(idForEncode, encoders)
----
======

[[authentication-password-storage-dpe-format]]
=== 비밀번호 저장 형식

비밀번호의 일반적인 형식은 다음과 같습니다:

.DelegatingPasswordEncoder 저장 형식
[source,text,attrs="-attributes"]
----
{id}encodedPassword
----

``id``는 어떤 ``PasswordEncoder``를 사용해야 하는지 찾는 데 사용되는 식별자이고 ``encodedPassword``는 선택된 ``PasswordEncoder``에 대한 원래 인코딩된 비밀번호입니다.
``id``는 반드시 비밀번호의 시작 부분에 있어야 하며, ``{``로 시작하고 ``}``로 끝나야 합니다.
``id``를 찾을 수 없으면 ``id``는 null로 설정됩니다.
예를 들어, 다음은 다른 ``id`` 값을 사용하여 인코딩된 비밀번호 목록일 수 있습니다.
모든 원래 비밀번호는 ``password``입니다.

.DelegatingPasswordEncoder 인코딩된 비밀번호 예시
[source,text,attrs="-attributes"]
----
{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG // <1>
{noop}password // <2>
{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc // <3>
{scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=  // <4>
{sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 // <5>
----

<1> 첫 번째 비밀번호는 ``PasswordEncoder`` id가 ``bcrypt``이고 `encodedPassword` 값이 ``$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG``입니다.
매칭 시 ``BCryptPasswordEncoder``에 위임됩니다.
<2> 두 번째 비밀번호는 ``PasswordEncoder`` id가 ``noop``이고 `encodedPassword` 값이 `password`입니다.
매칭 시 ``NoOpPasswordEncoder``에 위임됩니다.
<3> 세 번째 비밀번호는 ``PasswordEncoder`` id가 ``pbkdf2``이고 `encodedPassword` 값이 ``5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc``입니다.
매칭 시 ``Pbkdf2PasswordEncoder``에 위임됩니다.
<4> 네 번째 비밀번호는 ``PasswordEncoder`` id가 ``scrypt``이고 `encodedPassword` 값이 ``$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=``입니다.
매칭 시 ``SCryptPasswordEncoder``에 위임됩니다.
<5> 마지막 비밀번호는 ``PasswordEncoder`` id가 ``sha256``이고 `encodedPassword` 값이 ``97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0``입니다.
매칭 시 ``StandardPasswordEncoder``에 위임됩니다.

[NOTE]
====
일부 사용자는 저장 형식이 잠재적인 해커에게 제공된다는 점을 우려할지도 모릅니다.
이는 비밀번호 저장이 알고리즘의 비밀성에 의존하지 않기 때문에 문제가 되지 않습니다.
또한 대부분의 형식은 공격자가 접두사 없이도 쉽게 알아낼 수 있습니다.
예를 들어, BCrypt 비밀번호는 종종 ``$2a$``로 시작합니다.
====

[[authentication-password-storage-dpe-encoding]]
=== 비밀번호 인코딩

생성자에 전달된 ``idForEncode``는 비밀번호 인코딩에 사용되는 ``PasswordEncoder``를 결정합니다.
우리가 앞서 구성한 ``DelegatingPasswordEncoder``에서는 ``password``를 인코딩한 결과가 ``BCryptPasswordEncoder``에 위임되고 ``+{bcrypt}+`` 접두사가 붙습니다.
최종 결과는 다음 예시와 같습니다:

.DelegatingPasswordEncoder 인코딩 예시
[source,text,attrs="-attributes"]
----
{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

[[authentication-password-storage-dpe-matching]]
=== 비밀번호 매칭

매칭은 ``+{id}+``와 생성자에 제공된 ``id``에서 ``PasswordEncoder``로의 매핑을 기반으로 합니다.
<<authentication-password-storage-dpe-format,비밀번호 저장 형식>>의 예시에서 이것이 어떻게 작동하는지 보여줍니다.
기본적으로 매핑되지 않은 ``id``(null id 포함)를 가진 비밀번호로 ``matches(CharSequence, String)``을 호출한 결과는 ``IllegalArgumentException``입니다.
이 동작은 ``DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(PasswordEncoder)``를 사용하여 사용자 정의할 수 있습니다.

`id`를 사용함으로써 모든 비밀번호 인코딩에 대해 매칭할 수 있지만 가장 현대적인 비밀번호 인코딩을 사용하여 비밀번호를 인코딩할 수 있습니다.
이는 중요합니다. 암호화와 달리 비밀번호 해시는 평문을 복구할 수 있는 간단한 방법이 없도록 설계되었기 때문입니다. 평문을 복구할 수 없기 때문에 비밀번호를 마이그레이션하기 어렵습니다.
``NoOpPasswordEncoder``를 마이그레이션하는 것은 사용자들에게 간단하지만, 우리는 시작 경험을 단순화하기 위해 기본적으로 포함하기로 선택했습니다.

[[authentication-password-storage-dep-getting-started]]
=== 시작하기 경험

데모나 샘플을 만들 때 사용자의 비밀번호를 해시하는 데 시간을 들이는 것은 다소 번거로울 수 있습니다.
이를 더 쉽게 만들기 위한 편의 메커니즘이 있지만, 이는 여전히 프로덕션용으로 의도되지 않았습니다.

.withDefaultPasswordEncoder 예시
[tabs]
======
Java::
+
[source,java,role="primary",attrs="-attributes"]
----
UserDetails user = User.withDefaultPasswordEncoder()
  .username("user")
  .password("password")
  .roles("user")
  .build();
System.out.println(user.getPassword());
// {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

Kotlin::
+
[source,kotlin,role="secondary",attrs="-attributes"]
----
val user = User.withDefaultPasswordEncoder()
    .username("user")
    .password("password")
    .roles("user")
    .build()
println(user.password)
// {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----
======

여러 사용자를 만드는 경우 빌더를 재사용할 수도 있습니다:

.withDefaultPasswordEncoder 빌더 재사용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
UserBuilder users = User.withDefaultPasswordEncoder();
UserDetails user = users
  .username("user")
  .password("password")
  .roles("USER")
  .build();
UserDetails admin = users
  .username("admin")
  .password("password")
  .roles("USER","ADMIN")
  .build();
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val users = User.withDefaultPasswordEncoder()
val user = users
    .username("user")
    .password("password")
    .roles("USER")
    .build()
val admin = users
    .username("admin")
    .password("password")
    .roles("USER", "ADMIN")
    .build()
----
======

이것은 저장되는 비밀번호를 해시하지만, 비밀번호는 여전히 메모리와 컴파일된 소스 코드에 노출됩니다.
따라서 프로덕션 환경에서는 여전히 안전하지 않은 것으로 간주됩니다.
프로덕션을 위해서는 <<authentication-password-storage-boot-cli,외부에서 비밀번호를 해시>>해야 합니다.

[[authentication-password-storage-boot-cli]]
=== Spring Boot CLI로 인코딩

비밀번호를 적절히 인코딩하는 가장 쉬운 방법은 https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-cli.html[Spring Boot CLI]를 사용하는 것입니다.

예를 들어, 다음 예시는 <<authentication-password-storage-dpe>>와 함께 사용할 ``password``의 비밀번호를 인코딩합니다:

.Spring Boot CLI encodepassword 예시
[source,attrs="-attributes"]
----
spring encodepassword password
{bcrypt}$2a$10$X5wFBtLrL/kHcmrOGGTrGufsBX8CJ0WpQpF3pgeuxBB/H73BK1DW6
----

[[authentication-password-storage-dpe-troubleshoot]]
=== 문제 해결

<<authentication-password-storage-dpe-format>>에서 설명한 대로 저장된 비밀번호 중 하나에 ``id``가 없는 경우 다음과 같은 오류가 발생합니다.

----
java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"
	at org.springframework.security.crypto.password.DelegatingPasswordEncoder$UnmappedIdPasswordEncoder.matches(DelegatingPasswordEncoder.java:233)
	at org.springframework.security.crypto.password.DelegatingPasswordEncoder.matches(DelegatingPasswordEncoder.java:196)
----

이를 해결하는 가장 쉬운 방법은 현재 비밀번호가 어떻게 저장되고 있는지 파악하고 명시적으로 올바른 ``PasswordEncoder``를 제공하는 것입니다.

Spring Security 4.2.x에서 마이그레이션하는 경우, <<authentication-password-storage-configuration,`NoOpPasswordEncoder` 빈을 노출>>하여 이전 동작으로 되돌릴 수 있습니다.

또는 모든 비밀번호에 올바른 `id` 접두사를 붙이고 계속해서 ``DelegatingPasswordEncoder``를 사용할 수 있습니다.
예를 들어, BCrypt를 사용하고 있다면 비밀번호를 다음과 같이 마이그레이션할 수 있습니다:

----
$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

에서

[source,attrs="-attributes"]
----
{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
----

로 변경합니다.

매핑의 전체 목록은
https://docs.spring.io/spring-security/site/docs/5.0.x/api/org/springframework/security/crypto/factory/PasswordEncoderFactories.html[`PasswordEncoderFactories`]의 Javadoc을 참조하세요.

[[authentication-password-storage-bcrypt]]
== BCryptPasswordEncoder

`BCryptPasswordEncoder` 구현은 널리 지원되는 https://en.wikipedia.org/wiki/Bcrypt[bcrypt] 알고리즘을 사용하여 비밀번호를 해시합니다.
비밀번호 크래킹에 더 잘 저항하기 위해 bcrypt는 의도적으로 느리게 작동하도록 설계되었습니다.
다른 적응형 단방향 함수와 마찬가지로, 시스템에서 비밀번호를 확인하는 데 약 1초가 걸리도록 조정해야 합니다.
``BCryptPasswordEncoder``의 기본 구현은 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html[`BCryptPasswordEncoder`] Javadoc에 언급된 대로 강도 10을 사용합니다. 자신의 시스템에서 강도 매개변수를 조정하고 테스트하여 비밀번호 확인에 대략 1초가 걸리도록 하는 것이 좋습니다.

.BCryptPasswordEncoder
[tabs]
======
Java::
+
[source,java,role="primary"]
----
// 강도 16으로 인코더 생성
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// 강도 16으로 인코더 생성
val encoder = BCryptPasswordEncoder(16)
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))
----
======

[[authentication-password-storage-argon2]]
== Argon2PasswordEncoder

`Argon2PasswordEncoder` 구현은 https://en.wikipedia.org/wiki/Argon2[Argon2] 알고리즘을 사용하여 비밀번호를 해시합니다.
Argon2는 https://en.wikipedia.org/wiki/Password_Hashing_Competition[Password Hashing Competition]의 우승자입니다.
커스텀 하드웨어에서의 비밀번호 크래킹을 방지하기 위해 Argon2는 의도적으로 느린 알고리즘이며 대량의 메모리를 필요로 합니다.
다른 적응형 단방향 함수와 마찬가지로, 시스템에서 비밀번호를 확인하는 데 약 1초가 걸리도록 조정해야 합니다.
현재 `Argon2PasswordEncoder` 구현은 BouncyCastle을 필요로 합니다.

.Argon2PasswordEncoder
[tabs]
======
Java::
+
[source,java,role="primary"]
----
// 모든 기본값으로 인코더 생성
Argon2PasswordEncoder encoder = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// 모든 기본값으로 인코더 생성
val encoder = Argon2PasswordEncoder.defaultsForSpringSecurity_v5_8()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))
----
======

[[authentication-password-storage-pbkdf2]]
== Pbkdf2PasswordEncoder

`Pbkdf2PasswordEncoder` 구현은 https://en.wikipedia.org/wiki/PBKDF2[PBKDF2] 알고리즘을 사용하여 비밀번호를 해시합니다.
비밀번호 크래킹을 방지하기 위해 PBKDF2는 의도적으로 느린 알고리즘입니다.
다른 적응형 단방향 함수와 마찬가지로, 시스템에서 비밀번호를 확인하는 데 약 1초가 걸리도록 조정해야 합니다.
이 알고리즘은 FIPS 인증이 필요한 경우 좋은 선택입니다.

.Pbkdf2PasswordEncoder
[tabs]
======
Java::
+
[source,java,role="primary"]
----
// 모든 기본값으로 인코더 생성
Pbkdf2PasswordEncoder encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// 모든 기본값으로 인코더 생성
val encoder = Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))
----
======

[[authentication-password-storage-scrypt]]
== SCryptPasswordEncoder

`SCryptPasswordEncoder` 구현은 https://en.wikipedia.org/wiki/Scrypt[scrypt] 알고리즘을 사용하여 비밀번호를 해시합니다.
커스텀 하드웨어에서의 비밀번호 크래킹을 방지하기 위해 scrypt는 의도적으로 느리게 작동하도록 설계된 알고리즘이며 대량의 메모리를 필요로 합니다.
다른 적응형 단방향 함수와 마찬가지로, 시스템에서 비밀번호를 확인하는 데 약 1초가 걸리도록 조정해야 합니다.

.SCryptPasswordEncoder
[tabs]
======
Java::
+
[source,java,role="primary"]
----
// 모든 기본값으로 인코더 생성
SCryptPasswordEncoder encoder = SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
// 모든 기본값으로 인코더 생성
val encoder = SCryptPasswordEncoder.defaultsForSpringSecurity_v5_8()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))
----
======

[[authentication-password-storage-other]]
== 기타 ``PasswordEncoder``들

오로지 하위 호환성을 위해 존재하는 상당수의 다른 `PasswordEncoder` 구현체들이 있습니다.
이들은 모두 더 이상 안전하다고 간주되지 않음을 나타내기 위해 deprecated 되었습니다.
그러나 기존 레거시 시스템을 마이그레이션하기 어렵기 때문에 이들을 제거할 계획은 없습니다.

[[authentication-password-storage-configuration]]
== 비밀번호 저장 설정

Spring Security는 기본적으로 <<authentication-password-storage-dpe>>를 사용합니다.
그러나 ``PasswordEncoder``를 Spring 빈으로 노출시켜 이를 사용자 정의할 수 있습니다.

Spring Security 4.2.x에서 마이그레이션하는 경우, `NoOpPasswordEncoder` 빈을 노출시켜 이전 동작으로 되돌릴 수 있습니다.

[WARNING]
====
``NoOpPasswordEncoder``로 되돌리는 것은 안전하지 않은 것으로 간주됩니다.
대신 안전한 비밀번호 인코딩을 지원하기 위해 ``DelegatingPasswordEncoder``를 사용하도록 마이그레이션해야 합니다.
====

.NoOpPasswordEncoder
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public static NoOpPasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}
----

XML::
+
[source,xml,role="secondary"]
----
<b:bean id="passwordEncoder"
        class="org.springframework.security.crypto.password.NoOpPasswordEncoder" factory-method="getInstance"/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun passwordEncoder(): PasswordEncoder {
    return NoOpPasswordEncoder.getInstance();
}
----
======

[NOTE]
====
XML 설정에서는 `NoOpPasswordEncoder` 빈 이름이 `passwordEncoder`여야 합니다.
====

[[authentication-change-password-configuration]]
== 비밀번호 변경 설정

사용자가 비밀번호를 지정할 수 있도록 하는 대부분의 애플리케이션은 해당 비밀번호를 업데이트하는 기능도 필요로 합니다.

https://w3c.github.io/webappsec-change-password-url/[비밀번호 변경을 위한 잘 알려진 URL]은 비밀번호 관리자가 주어진 애플리케이션의 비밀번호 업데이트 엔드포인트를 발견할 수 있는 메커니즘을 나타냅니다.

Spring Security를 구성하여 이 검색 엔드포인트를 제공할 수 있습니다.
예를 들어, 애플리케이션의 비밀번호 변경 엔드포인트가 ``/change-password``인 경우 다음과 같이 Spring Security를 구성할 수 있습니다:

.기본 비밀번호 변경 엔드포인트
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .passwordManagement(Customizer.withDefaults())
----

XML::
+
[source,xml,role="secondary"]
----
<sec:password-management/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    passwordManagement { }
}
----
======

그러면 비밀번호 관리자가 ``/.well-known/change-password``로 이동할 때 Spring Security가 당신이 설정한 엔드포인트인 ``/change-password``로 리디렉션합니다.

또는 엔드포인트가 ``/change-password``가 아닌 다른 것이라면 다음과 같이 지정할 수도 있습니다:

.비밀번호 변경 엔드포인트
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .passwordManagement((management) -> management
        .changePasswordPage("/update-password")
    )
----

XML::
+
[source,xml,role="secondary"]
----
<sec:password-management change-password-page="/update-password"/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    passwordManagement {
        changePasswordPage = "/update-password"
    }
}
----
======

위의 구성으로, 비밀번호 관리자가 ``/.well-known/change-password``로 이동하면 Spring Security가 ``/update-password``로 리디렉션합니다.

[[authentication-compromised-password-check]]
== 유출된 비밀번호 확인

민감한 데이터를 다루는 애플리케이션을 만드는 경우와 같이 사용자의 비밀번호가 유출되었는지 확인해야 하는 시나리오가 있습니다. 이는 사용자 비밀번호의 신뢰성을 확인하기 위한 검사 중 하나일 수 있습니다.
이러한 검사 중 하나는 비밀번호가 유출되었는지 확인하는 것입니다. 일반적으로 이는 https://wikipedia.org/wiki/Data_breach[데이터 유출]에서 발견되었기 때문입니다.

이를 위해 Spring Security는 {security-api-url}org/springframework/security/core/password/HaveIBeenPwnedRestApiPasswordChecker.html[`HaveIBeenPwnedRestApiPasswordChecker` 구현]을 통해 https://haveibeenpwned.com/API/v3#PwnedPasswords[Have I Been Pwned API]와의 통합을 제공합니다. 이는 {security-api-url}org/springframework/security/core/password/CompromisedPasswordChecker.html[`CompromisedPasswordChecker` 인터페이스]의 구현입니다.

`CompromisedPasswordChecker` API를 직접 사용하거나, xref:servlet/authentication/passwords/index.adoc[Spring Security 인증 메커니즘]을 통해 xref:servlet/authentication/passwords/dao-authentication-provider.adoc[`DaoAuthenticationProvider`]를 사용하는 경우 `CompromisedPasswordChecker` 빈을 제공하면 Spring Security 구성에 의해 자동으로 선택됩니다.

이렇게 하면 약한 비밀번호(예: `123456`)를 사용하여 폼 로그인을 통해 인증하려고 할 때 401을 받거나 `/login?error` 페이지로 리디렉션됩니다(사용자 에이전트에 따라 다름).
그러나 401이나 리디렉션만으로는 그다지 유용하지 않습니다. 사용자가 올바른 비밀번호를 제공했음에도 로그인할 수 없어 혼란을 야기할 수 있습니다.
이런 경우 ``AuthenticationFailureHandler``를 통해 ``CompromisedPasswordException``을 처리하여 원하는 로직을 수행할 수 있습니다. 예를 들어 사용자 에이전트를 ``/reset-password``로 리디렉션하는 등의 작업을 수행할 수 있습니다:

.CompromisedPasswordChecker 사용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .formLogin((login) -> login
            .failureHandler(new CompromisedPasswordAuthenticationFailureHandler())
        );
    return http.build();
}

@Bean
public CompromisedPasswordChecker compromisedPasswordChecker() {
    return new HaveIBeenPwnedRestApiPasswordChecker();
}

static class CompromisedPasswordAuthenticationFailureHandler implements AuthenticationFailureHandler {

    private final SimpleUrlAuthenticationFailureHandler defaultFailureHandler = new SimpleUrlAuthenticationFailureHandler(
            "/login?error");

    private final RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();

    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
            AuthenticationException exception) throws IOException, ServletException {
        if (exception instanceof CompromisedPasswordException) {
            this.redirectStrategy.sendRedirect(request, response, "/reset-password");
            return;
        }
        this.defaultFailureHandler.onAuthenticationFailure(request, response, exception);
    }

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun filterChain(http:HttpSecurity): SecurityFilterChain {
    http {
        authorizeHttpRequests {
            authorize(anyRequest, authenticated)
        }
        formLogin {
            failureHandler = CompromisedPasswordAuthenticationFailureHandler()
        }
    }
    return http.build()
}

@Bean
open fun compromisedPasswordChecker(): CompromisedPasswordChecker {
    return HaveIBeenPwnedRestApiPasswordChecker()
}

class CompromisedPasswordAuthenticationFailureHandler : AuthenticationFailureHandler {
    private val defaultFailureHandler = SimpleUrlAuthenticationFailureHandler("/login?error")
    private val redirectStrategy = DefaultRedirectStrategy()

    override fun onAuthenticationFailure(
        request: HttpServletRequest,
        response: HttpServletResponse,
        exception: AuthenticationException
    ) {
        if (exception is CompromisedPasswordException) {
            redirectStrategy.sendRedirect(request, response, "/reset-password")
            return
        }
        defaultFailureHandler.onAuthenticationFailure(request, response, exception)
    }
}
----
======