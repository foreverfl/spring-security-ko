[[http]]
= HTTP

https://www.troyhunt.com/heres-why-your-static-website-needs-https/[정적 리소스]를 포함한 모든 HTTP 기반 통신은 https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html[TLS를 사용하여] 보호되어야 합니다.

Spring Security는 프레임워크로서 HTTP 연결을 직접 처리하지 않기 때문에 HTTPS를 직접 지원하지 않습니다.
그러나 HTTPS 사용을 돕는 여러 기능을 제공합니다.

[[http-redirect]]
== HTTPS로 리다이렉트

클라이언트가 HTTP를 사용할 때, Spring Security를 구성하여 서블릿 및 WebFlux 환경 모두에서 HTTPS로 리다이렉트할 수 있습니다.

[[http-hsts]]
== 엄격한 전송 보안

Spring Security는 엄격한 전송 보안(HSTS)을 지원하며 기본적으로 활성화합니다.

[[http-proxy-server]]
== 프록시 서버 구성

프록시 서버를 사용할 때는 애플리케이션을 올바르게 구성하는 것이 중요합니다.
예를 들어, 많은 애플리케이션에서 로드 밸런서가 ``\https://example.com/``에 대한 요청을 ``\https://192.168.0.107``의 애플리케이션 서버로 전달합니다.
적절한 구성이 없으면 애플리케이션 서버는 로드 밸런서의 존재를 알 수 없어, 마치 클라이언트가 ``\https://192.168.0.107:8080``을 직접 요청한 것처럼 취급합니다.

이 문제를 해결하기 위해 https://tools.ietf.org/html/rfc7239[RFC 7239]를 사용하여 로드 밸런서가 사용 중임을 명시할 수 있습니다.
애플리케이션이 이를 인식하도록 하려면 X-Forwarded 헤더를 인식하도록 애플리케이션 서버를 구성해야 합니다.
예를 들어, Tomcat은 https://tomcat.apache.org/tomcat-10.1-doc/api/org/apache/catalina/valves/RemoteIpValve.html[`RemoteIpValve`]를 사용하고 Jetty는 https://eclipse.dev/jetty/javadoc/jetty-11/org/eclipse/jetty/server/ForwardedRequestCustomizer.html[`ForwardedRequestCustomizer`]를 사용합니다.
또는 Spring 사용자는 서블릿 스택에서 https://docs.spring.io/spring-framework/reference/web/webmvc/filters.html#filters-forwarded-headers[`ForwardedHeaderFilter`]를, 리액티브 스택에서 https://docs.spring.io/spring-framework/reference/web/webflux/reactive-spring.html#webflux-forwarded-headers[`ForwardedHeaderTransformer`]를 사용할 수 있습니다.

Spring Boot 사용자는 `server.forward-headers-strategy` 속성을 사용하여 애플리케이션을 구성할 수 있습니다.
자세한 내용은 https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.webserver.use-behind-a-proxy-server[Spring Boot 문서]를 참조하세요.