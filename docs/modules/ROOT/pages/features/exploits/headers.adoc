[[headers]]
= Security HTTP 응답 헤더

[NOTE]
====
이 문서 부분은 Security HTTP 응답 헤더의 일반적인 주제를 다룹니다.
서블릿 및 WebFlux 기반 애플리케이션의 Security HTTP 응답 헤더에 대한 구체적인 정보는 해당 섹션을 참조하세요.
====

웹 애플리케이션의 보안을 강화하기 위해 https://owasp.org/www-project-secure-headers/#div-headers[HTTP 응답 헤더]를 다양한 방식으로 사용할 수 있습니다.
이 섹션에서는 Spring Security가 명시적으로 지원하는 다양한 HTTP 응답 헤더에 대해 설명합니다.
필요한 경우 Spring Security를 구성하여 <<headers-custom,사용자 정의 헤더>>를 제공할 수도 있습니다.

[[headers-default]]
== 기본 Security 헤더

[NOTE]
====
서블릿 및 웹플럭스 기반 애플리케이션에서 기본값을 사용자 정의하는 방법은 관련 섹션을 참조하세요.
====

Spring Security는 보안과 관련된 HTTP 응답 헤더의 기본 세트를 제공하여 안전한 기본값을 제공합니다.

Spring Security의 기본 헤더는 다음과 같습니다:

.기본 Security HTTP 응답 헤더
[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 0
----

[NOTE]
====
Strict-Transport-Security는 HTTPS 요청에만 추가됩니다
====

기본값이 요구사항을 충족하지 않는 경우, 이러한 기본값에서 헤더를 쉽게 제거, 수정 또는 추가할 수 있습니다.
각 헤더에 대한 자세한 내용은 다음 섹션을 참조하세요:

* <<headers-cache-control,캐시 제어>>
* <<headers-content-type-options,콘텐츠 유형 옵션>>
* <<headers-hsts,HTTP 엄격 전송 보안>>
* <<headers-frame-options,X-Frame-Options>>
* <<headers-xss-protection,X-XSS-Protection>>

[[headers-cache-control]]
== 캐시 제어

[NOTE]
====
서블릿 및 웹플럭스 기반 애플리케이션에서 기본값을 사용자 정의하는 방법은 관련 섹션을 참조하세요.
====

Spring Security의 기본 설정은 사용자의 콘텐츠를 보호하기 위해 캐싱을 비활성화하는 것입니다.

사용자가 민감한 정보를 보기 위해 인증한 후 로그아웃하면, 악의적인 사용자가 뒤로 가기 버튼을 클릭하여 민감한 정보를 볼 수 없도록 해야 합니다.
기본적으로 전송되는 캐시 제어 헤더는 다음과 같습니다:

.기본 캐시 제어 HTTP 응답 헤더
[source]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
----

기본적으로 안전하게 하기 위해 Spring Security는 이러한 헤더를 기본적으로 추가합니다.
그러나 애플리케이션이 자체 캐시 제어 헤더를 제공하는 경우, Spring Security는 이를 방해하지 않습니다.
이를 통해 애플리케이션은 CSS 및 JavaScript와 같은 정적 리소스가 캐시될 수 있도록 할 수 있습니다.

[[headers-content-type-options]]
== 콘텐츠 유형 옵션

[NOTE]
====
서블릿 및 웹플럭스 기반 애플리케이션에서 기본값을 사용자 정의하는 방법은 관련 섹션을 참조하세요.
====

역사적으로 Internet Explorer를 포함한 브라우저들은 https://en.wikipedia.org/wiki/Content_sniffing[콘텐츠 스니핑]을 사용하여 요청의 콘텐츠 유형을 추측하려 했습니다.
이를 통해 브라우저는 콘텐츠 유형이 지정되지 않은 리소스에 대해 콘텐츠 유형을 추측하여 사용자 경험을 개선할 수 있었습니다.
예를 들어, 브라우저가 콘텐츠 유형이 지정되지 않은 JavaScript 파일을 만나면 콘텐츠 유형을 추측하고 실행할 수 있었습니다.

[NOTE]
====
콘텐츠 업로드를 허용할 때는 추가적인 조치(예: 문서를 별도의 도메인에서만 표시, Content-Type 헤더가 설정되어 있는지 확인, 문서 sanitize 등)가 필요합니다.
그러나 이러한 조치는 Spring Security가 제공하는 범위를 벗어납니다.
또한 콘텐츠 스니핑을 비활성화할 때는 올바른 작동을 위해 콘텐츠 유형을 지정해야 한다는 점을 강조하는 것이 중요합니다.
====

콘텐츠 스니핑의 문제점은 악의적인 사용자가 폴리글롯(즉, 여러 콘텐츠 유형으로 유효한 파일)을 사용하여 XSS 공격을 수행할 수 있다는 것입니다.
예를 들어, 일부 사이트에서는 사용자가 유효한 포스트스크립트 문서를 웹사이트에 제출하고 볼 수 있도록 허용할 수 있습니다.
악의적인 사용자는 http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf[유효한 JavaScript 파일이기도 한 포스트스크립트 문서]를 만들어 XSS 공격을 수행할 수 있습니다.

Spring Security는 기본적으로 다음 헤더를 HTTP 응답에 추가하여 콘텐츠 스니핑을 비활성화합니다:

.nosniff HTTP 응답 헤더
[source,http]
----
X-Content-Type-Options: nosniff
----

[[headers-hsts]]
== HTTP 엄격 전송 보안 (HSTS)

[NOTE]
====
서블릿 및 웹플럭스 기반 애플리케이션에서 기본값을 사용자 정의하는 방법은 관련 섹션을 참조하세요.
====

은행 웹사이트를 입력할 때, ``mybank.example.com``을 입력하나요, 아니면 ``\https://mybank.example.com``을 입력하나요?
``https`` 프로토콜을 생략하면 https://en.wikipedia.org/wiki/Man-in-the-middle_attack[중간자 공격]에 취약해질 수 있습니다.
웹사이트가 ``\https://mybank.example.com``으로 리다이렉트를 수행하더라도, 악의적인 사용자가 초기 HTTP 요청을 가로채고 응답을 조작할 수 있습니다(예: ``\https://mibank.example.com``으로 리다이렉트하여 자격 증명을 탈취).

많은 사용자가 `https` 프로토콜을 생략하기 때문에 https://tools.ietf.org/html/rfc6797[HTTP 엄격 전송 보안 (HSTS)]이 만들어졌습니다.
``mybank.example.com``이 https://tools.ietf.org/html/rfc6797#section-5.1[HSTS 호스트]로 추가되면, 브라우저는 mybank.example.com에 대한 모든 요청을 ``\https://mybank.example.com``으로 해석해야 한다는 것을 미리 알 수 있습니다.
이는 중간자 공격이 발생할 가능성을 크게 줄입니다.

[NOTE]
====
https://tools.ietf.org/html/rfc6797#section-7.2[RFC6797]에 따라 HSTS 헤더는 HTTPS 응답에만 삽입됩니다.
브라우저가 헤더를 인식하려면, 브라우저는 먼저 연결을 만드는 데 사용된 SSL 인증서에 서명한 CA를 신뢰해야 합니다(SSL 인증서만 신뢰하는 것이 아님).
====

사이트를 HSTS 호스트로 표시하는 한 가지 방법은 해당 호스트를 브라우저에 미리 로드하는 것입니다.
다른 방법은 응답에 `Strict-Transport-Security` 헤더를 추가하는 것입니다.
예를 들어, Spring Security의 기본 동작은 다음 헤더를 추가하는 것입니다. 이 헤더는 브라우저에게 1년 동안(윤년이 아닌 경우 31536000초) 해당 도메인을 HSTS 호스트로 취급하도록 지시합니다:

.엄격 전송 Security HTTP 응답 헤더
[source]
----
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
----

선택적인 `includeSubDomains` 지시어는 브라우저에게 서브도메인(예: `secure.mybank.example.com`)도 HSTS 도메인으로 취급해야 한다고 지시합니다.

선택적인 `preload` 지시어는 브라우저에게 해당 도메인을 HSTS 도메인으로 브라우저에 미리 로드해야 한다고 지시합니다.
HSTS 사전 로드에 대한 자세한 내용은 link:[https://hstspreload.org]을 참조하세요.

[[headers-hpkp]]
== HTTP 공개 키 고정 (HPKP)

[NOTE]
====
Spring Security는 여전히 서블릿 환경에서 HPKP를 지원합니다.
그러나 앞서 언급한 이유로 인해 Spring Security 팀은 더 이상 HPKP를 권장하지 않습니다.
====

https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning[HTTP 공개 키 고정 (HPKP)]은 위조된 인증서를 사용한 중간자(MITM) 공격을 방지하기 위해 웹 클라이언트에게 특정 웹 서버와 함께 사용할 공개 키를 지정합니다.
올바르게 사용되면 HPKP는 손상된 인증서로부터 추가적인 보호 계층을 제공할 수 있습니다.
그러나 HPKP의 복잡성으로 인해 많은 전문가들은 더 이상 사용을 권장하지 않으며, https://www.chromestatus.com/feature/5903385005916160[Chrome은 지원을 제거]했습니다.

[[headers-hpkp-deprecated]]
HPKP가 더 이상 권장되지 않는 이유에 대한 추가 세부 정보는 https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead[HTTP 공개 키 고정이 죽었나요?]와 https://scotthelme.co.uk/im-giving-up-on-hpkp/[HPKP를 포기합니다]를 읽어보세요.

[[headers-frame-options]]
== X-Frame-Options

[NOTE]
====
서블릿 및 웹플럭스 기반 애플리케이션에서 기본값을 사용자 정의하는 방법은 관련 섹션을 참조하세요.
====

웹사이트를 프레임에 추가하도록 허용하는 것은 보안 문제가 될 수 있습니다.
예를 들어, 교묘한 CSS 스타일링을 사용하여 사용자가 의도하지 않은 것을 클릭하도록 속일 수 있습니다.
예를 들어, 은행에 로그인한 사용자가 다른 사용자에게 접근 권한을 부여하는 버튼을 클릭할 수 있습니다.