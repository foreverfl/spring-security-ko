// 서블릿과 WebFlux 지원에 대한 링크 추가 필요

[[csrf]]
= 크로스 사이트 요청 위조 (CSRF)

Spring은 https://en.wikipedia.org/wiki/Cross-site_request_forgery[크로스 사이트 요청 위조 (CSRF)] 공격에 대한 포괄적인 보호를 제공합니다.
다음 섹션에서는 아래 내용을 살펴봅니다:

* <<csrf-explained>>
* <<csrf-protection>>
* <<csrf-considerations>>

[NOTE]
====
이 문서의 이 부분은 CSRF 보호에 대한 일반적인 주제를 다룹니다.
xref:servlet/exploits/csrf.adoc#servlet-csrf[서블릿]과 xref:reactive/exploits/csrf.adoc#webflux-csrf[WebFlux] 기반 애플리케이션의 CSRF 보호에 대한 특정 정보는 관련 섹션을 참조하세요.
====

[[csrf-explained]]
== CSRF 공격이란 무엇인가?
CSRF 공격을 이해하는 가장 좋은 방법은 구체적인 예를 살펴보는 것입니다.

은행 웹사이트가 현재 로그인한 사용자로부터 다른 은행 계좌로 돈을 이체할 수 있는 양식을 제공한다고 가정해 봅시다.
예를 들어, 이체 양식은 다음과 같을 수 있습니다:

.이체 양식
[source,html]
----
<form method="post"
	action="/transfer">
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="text"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
----

해당 HTTP 요청은 다음과 같을 수 있습니다:

.이체 HTTP 요청
[source]
----
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
----

이제 당신이 은행 웹사이트에 인증한 후, 로그아웃하지 않고 악의적인 웹사이트를 방문한다고 가정해 봅시다.
악의적인 웹사이트에는 다음과 같은 양식이 포함된 HTML 페이지가 있습니다:

.악의적인 이체 양식
[source,html]
----
<form method="post"
	action="https://bank.example.com/transfer">
<input type="hidden"
	name="amount"
	value="100.00"/>
<input type="hidden"
	name="routingNumber"
	value="evilsRoutingNumber"/>
<input type="hidden"
	name="account"
	value="evilsAccountNumber"/>
<input type="submit"
	value="Win Money!"/>
</form>
----

당신은 돈을 얻기 위해 제출 버튼을 클릭합니다.
이 과정에서 당신은 의도치 않게 악의적인 사용자에게 100달러를 이체했습니다.
이는 악의적인 웹사이트가 당신의 쿠키를 볼 수 없지만, 은행과 관련된 쿠키가 여전히 요청과 함께 전송되기 때문에 발생합니다.

더 나쁜 점은 이 전체 과정이 JavaScript를 사용하여 자동화될 수 있다는 것입니다.
이는 버튼을 클릭할 필요조차 없다는 것을 의미합니다.
더욱이, 이는 https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)[XSS 공격]의 피해자가 된 정직한 사이트를 방문할 때도 마찬가지로 쉽게 발생할 수 있습니다.
그렇다면 우리는 어떻게 사용자를 이러한 공격으로부터 보호할 수 있을까요?

[[csrf-protection]]
== CSRF 공격으로부터의 보호
CSRF 공격이 가능한 이유는 피해자의 웹사이트에서 오는 HTTP 요청과 공격자의 웹사이트에서 오는 요청이 정확히 같기 때문입니다.
이는 악의적인 사이트에서 오는 요청을 거부하고 은행 웹사이트에서 오는 요청만 허용할 방법이 없다는 것을 의미합니다.
CSRF 공격으로부터 보호하기 위해서는 악의적인 사이트가 제공할 수 없는 요청에 무언가를 포함시켜 두 요청을 구별할 수 있도록 해야 합니다.

Spring은 CSRF 공격으로부터 보호하기 위한 두 가지 메커니즘을 제공합니다:

* <<csrf-protection-stp, 동기화 토큰 패턴>>
* 세션 쿠키에 <<csrf-protection-ssa, SameSite 속성>> 지정하기

[NOTE]
====
두 보호 방식 모두 <<csrf-protection-read-only,안전한 메서드가 읽기 전용이어야 함>>을 요구합니다.
====

[[csrf-protection-read-only]]
=== 안전한 메서드는 읽기 전용이어야 함

CSRF에 대한 <<csrf-protection,어느 보호 방식>>이든 작동하려면, 애플리케이션은 https://tools.ietf.org/html/rfc7231#section-4.2.1["안전한" HTTP 메서드가 읽기 전용]임을 보장해야 합니다.
이는 HTTP `GET`, `HEAD`, `OPTIONS`, `TRACE` 메서드를 사용하는 요청이 애플리케이션의 상태를 변경해서는 안 된다는 것을 의미합니다.

[[csrf-protection-stp]]
=== 동기화 토큰 패턴
CSRF 공격으로부터 보호하는 가장 효과적이고 널리 사용되는 방법은 https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern[동기화 토큰 패턴(Synchronizer Token Pattern)]을 사용하는 것입니다.
이 솔루션은 각 HTTP 요청이 세션 쿠키 외에도 CSRF 토큰이라고 불리는 안전한 난수 생성 값을 HTTP 요청에 포함하도록 요구합니다.

HTTP 요청이 제출되면, 서버는 예상되는 CSRF 토큰을 조회하고 이를 HTTP 요청의 실제 CSRF 토큰과 비교해야 합니다.
값이 일치하지 않으면 HTTP 요청은 거부되어야 합니다.

이 방식이 작동하는 핵심은 실제 CSRF 토큰이 브라우저에 의해 자동으로 포함되지 않는 HTTP 요청의 일부에 있어야 한다는 것입니다.
예를 들어, HTTP 파라미터나 HTTP 헤더에 실제 CSRF 토큰을 요구하면 CSRF 공격으로부터 보호할 수 있습니다.
쿠키에 실제 CSRF 토큰을 요구하는 것은 작동하지 않습니다. 왜냐하면 쿠키는 브라우저에 의해 HTTP 요청에 자동으로 포함되기 때문입니다.

우리는 애플리케이션의 상태를 업데이트하는 각 HTTP 요청에 대해서만 실제 CSRF 토큰을 요구하도록 요구 사항을 조정할 수 있습니다.
이를 위해서는 애플리케이션이 <<csrf-protection-read-only,안전한 HTTP 메서드가 읽기 전용>>임을 보장해야 합니다.
이는 외부 사이트에서 우리 웹사이트로 링크하는 것을 허용하고자 하므로 사용성을 개선합니다.
또한, 토큰이 유출될 수 있으므로 HTTP GET에 난수 토큰을 포함시키고 싶지 않습니다.

동기화 토큰 패턴을 사용할 때 <<csrf-explained,우리의 예제>>가 어떻게 변경되는지 고려해 봅시다.
실제 CSRF 토큰이 ``_csrf``라는 HTTP 파라미터에 있어야 한다고 가정합시다.
우리 애플리케이션의 이체 양식은 다음과 같이 보일 것입니다:

.Synchronizer Token 양식
[source,html]
----
<form method="post"
	action="/transfer">
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="hidden"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
----

이제 양식에는 CSRF 토큰 값을 가진 숨겨진 입력이 포함되어 있습니다.
동일 출처 정책은 악의적인 사이트가 응답을 읽을 수 없도록 보장하므로 외부 사이트는 CSRF 토큰을 읽을 수 없습니다.

돈을 이체하는 해당 HTTP 요청은 다음과 같이 보일 것입니다:

.Synchronizer Token 요청
[source]
----
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721
----


HTTP 요청에 이제 안전한 난수 값을 가진 `_csrf` 파라미터가 포함되어 있음을 주목하세요.
악의적인 웹사이트는 `_csrf` 파라미터에 대한 올바른 값을 제공할 수 없을 것입니다 (악의적인 웹사이트에서 명시적으로 제공해야 함). 서버가 실제 CSRF 토큰을 예상 CSRF 토큰과 비교할 때 이체는 실패할 것입니다.

[[csrf-protection-ssa]]
=== SameSite 속성
<<csrf,CSRF 공격>>으로부터 보호하는 새로운 방법은 쿠키에 https://tools.ietf.org/html/draft-west-first-party-cookies[SameSite 속성]을 지정하는 것입니다.
서버는 쿠키를 설정할 때 `SameSite` 속성을 지정하여 외부 사이트에서 올 때 쿠키를 보내지 말아야 함을 나타낼 수 있습니다.

[NOTE]
====
Spring Security는 세션 쿠키의 생성을 직접 제어하지 않으므로 SameSite 속성에 대한 지원을 제공하지 않습니다.
https://spring.io/projects/spring-session[Spring Session]은 서블릿 기반 애플리케이션에서 `SameSite` 속성에 대한 지원을 제공합니다.
Spring Framework의 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html[`CookieWebSessionIdResolver`]는 WebFlux 기반 애플리케이션에서 `SameSite` 속성에 대한 기본 지원을 제공합니다.
====

`SameSite` 속성이 포함된 HTTP 응답 헤더의 예는 다음과 같을 수 있습니다:

.SameSite HTTP 응답
[source]
----
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
----

`SameSite` 속성의 유효한 값은 다음과 같습니다:

* ``Strict``: 지정된 경우, https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[동일 사이트]에서 오는 모든 요청에 쿠키가 포함됩니다.
그렇지 않으면 쿠키가 HTTP 요청에 포함되지 않습니다.
* ``Lax``: 지정된 경우, https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[동일 사이트]에서 오거나 요청이 최상위 탐색에서 오고 <<Safe Methods Must be Read-only,메서드가 읽기 전용>>일 때 쿠키가 전송됩니다.
그렇지 않으면 쿠키가 HTTP 요청에 포함되지 않습니다.

<<csrf-explained,우리의 예제>>가 `SameSite` 속성을 사용하여 어떻게 보호될 수 있는지 고려해 봅시다.
은행 애플리케이션은 세션 쿠키에 `SameSite` 속성을 지정함으로써 CSRF로부터 보호할 수 있습니다.

세션 쿠키에 `SameSite` 속성이 설정되면, 브라우저는 계속해서 은행 웹사이트에서 오는 요청에 대해 `JSESSIONID` 쿠키를 보냅니다.
그러나 브라우저는 더 이상 악의적인 웹사이트에서 오는 이체 요청에 `JSESSIONID` 쿠키를 보내지 않습니다.
악의적인 웹사이트에서 오는 이체 요청에 세션이 더 이상 존재하지 않으므로, 애플리케이션은 CSRF 공격으로부터 보호됩니다.

CSRF 공격으로부터 보호하기 위해 `SameSite` 속성을 사용할 때 주의해야 할 중요한 https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-5[고려사항]이 있습니다.

`SameSite` 속성을 ``Strict``로 설정하면 더 강력한 방어를 제공하지만 사용자를 혼란스럽게 할 수 있습니다.
link:[https://social.example.com]에서 호스팅되는 소셜 미디어 사이트에 로그인 상태를 유지하는 사용자를 고려해 보세요.
사용자가 link:[https://email.example.org]에서 소셜 미디어 사이트로의 링크가 포함된 이메일을 받습니다.
사용자가 링크를 클릭하면, 당연히 소셜 미디어 사이트에 인증된 상태일 것으로 기대합니다.
그러나 `SameSite` 속성이 ``Strict``인 경우, 쿠키가 전송되지 않으므로 사용자는 인증되지 않을 것입니다.

[NOTE]
====
https://github.com/spring-projects/spring-security/issues/7537[gh-7537]을 구현하면 CSRF 공격에 대한 `SameSite` 보호의 효과와 사용성을 개선할 수 있습니다.
====

또 다른 명백한 고려사항은 `SameSite` 속성으로 사용자를 보호하려면 브라우저가 `SameSite` 속성을 지원해야 한다는 것입니다.
대부분의 현대 브라우저는 https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility[SameSite 속성을 지원]합니다.
그러나 여전히 사용 중인 구형 브라우저는 지원하지 않을 수 있습니다.

이러한 이유로, 우리는 일반적으로 `SameSite` 속성을 CSRF 공격에 대한 유일한 보호 수단으로 사용하기보다는 심층 방어의 한 방법으로 사용할 것을 권장합니다.

[[csrf-when]]
== CSRF 보호를 사용해야 할 때
언제 CSRF 보호를 사용해야 할까요?
우리의 권장사항은 일반 사용자가 브라우저로 처리할 수 있는 모든 요청에 대해 CSRF 보호를 사용하는 것입니다.
브라우저가 아닌 클라이언트만 사용하는 서비스를 만드는 경우, CSRF 보호를 비활성화하고 싶을 수 있습니다.

[[csrf-when-json]]
=== CSRF 보호와 JSON
흔한 질문은 "JavaScript에서 만든 JSON 요청을 보호해야 하나요?"입니다.
간단한 답변은: 상황에 따라 다릅니다.
그러나 JSON 요청에 영향을 미칠 수 있는 CSRF 공격이 있으므로 매우 주의해야 합니다.
예를 들어, 악의적인 사용자는 http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html[다음과 같은 양식을 사용하여 JSON으로 CSRF를 생성]할 수 있습니다:

.JSON을 사용한 CSRF 양식
[source,html]
----
<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
----


이는 다음과 같은 JSON 구조를 생성합니다

.JSON을 사용한 CSRF 요청
[source,javascript]
----
{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}
----

애플리케이션이 `Content-Type` 헤더를 검증하지 않으면 이 공격에 노출될 수 있습니다.
설정에 따라 ``Content-Type``을 검증하는 Spring MVC 애플리케이션도 URL 접미사를 ``.json``으로 끝나도록 업데이트하여 여전히 공격당할 수 있습니다:

.JSON을 사용한 Spring MVC CSRF 양식
[source,html]
----
<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
----

[[csrf-when-stateless]]
=== CSRF와 무상태(stateless) 브라우저 애플리케이션
내 애플리케이션이 무상태(stateless)라면 어떨까요?
그렇다고 해서 반드시 보호되는 것은 아닙니다.
실제로, 주어진 요청에 대해 사용자가 웹 브라우저에서 어떤 작업도 수행할 필요가 없다면, 여전히 CSRF 공격에 취약할 가능성이 높습니다.

예를 들어, 인증을 위해 JSESSIONID 대신 모든 상태를 포함하는 사용자 정의 쿠키를 사용하는 애플리케이션을 고려해 보세요.
CSRF 공격이 수행될 때, 이 사용자 정의 쿠키는 이전 예제에서 JSESSIONID 쿠키가 전송된 것과 같은 방식으로 요청과 함께 전송됩니다.
이 애플리케이션은 CSRF 공격에 취약합니다.

기본 인증을 사용하는 애플리케이션도 CSRF 공격에 취약합니다.
브라우저가 이전 예제에서 JSESSIONID 쿠키를 전송한 것과 같은 방식으로 모든 요청에 자동으로 사용자 이름과 비밀번호를 포함하기 때문에 애플리케이션이 취약합니다.

[[csrf-considerations]]
== CSRF 고려사항
CSRF 공격에 대한 보호를 구현할 때 고려해야 할 몇 가지 특별한 사항이 있습니다.

[[csrf-considerations-login]]
=== 로그인

https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests[로그인 요청 위조]로부터 보호하기 위해, 로그인 HTTP 요청도 CSRF 공격으로부터 보호되어야 합니다.
로그인 요청 위조로부터의 보호는 악의적인 사용자가 피해자의 민감한 정보를 읽지 못하도록 하기 위해 필요합니다.
공격은 다음과 같이 수행됩니다:

. 악의적인 사용자가 악의적인 사용자의 자격 증명으로 CSRF 로그인을 수행합니다.
피해자는 이제 악의적인 사용자로 인증됩니다.
. 그런 다음 악의적인 사용자는 피해자가 손상된 웹사이트를 방문하여 민감한 정보를 입력하도록 유도합니다.
. 정보는 악의적인 사용자의 계정과 연결되므로 악의적인 사용자는 자신의 자격 증명으로 로그인하여 피해자의 민감한 정보를 볼 수 있습니다.

로그인 HTTP 요청이 CSRF 공격으로부터 보호되도록 하는 과정에서, 사용자가 세션이 만료되어 요청이 거부되는 문제를 겪을 수 있습니다. 
로그인 시 세션이 필요하리라고 예상하지 않는 사용자에게는 세션 타임아웃이 당황스러울 수 있습니다.
자세한 정보는 <<csrf-considerations-timeouts>>를 참조하세요.

[[csrf-considerations-logout]]
=== 로그아웃

로그아웃 요청 위조로부터 보호하기 위해, 로그아웃 HTTP 요청도 CSRF 공격으로부터 보호되어야 합니다.
로그아웃 요청 위조로부터의 보호는 악의적인 사용자가 피해자의 민감한 정보를 읽지 못하도록 하기 위해 필요합니다.
공격에 대한 자세한 내용은 https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/[이 블로그 게시물]을 참조하세요.

로그아웃 HTTP 요청이 CSRF 공격으로부터 보호되도록 하는 과정에서, 사용자가 세션이 만료되어 요청이 거부되는 문제를 겪을 수 있습니다. 
로그아웃하는 데 세션이 필요하리라고 예상하지 않는 사용자에게는 세션 타임아웃이 당황스러울 수 있습니다.
자세한 정보는 <<csrf-considerations-timeouts>>를 참조하세요.

[[csrf-considerations-timeouts]]
=== CSRF와 세션 타임아웃
대부분의 경우, 예상되는 CSRF 토큰은 세션에 저장됩니다.
이는 세션이 만료되는 즉시 서버가 예상되는 CSRF 토큰을 찾지 못하고 HTTP 요청을 거부한다는 것을 의미합니다.
타임아웃을 해결하기 위한 여러 가지 옵션이 있습니다(각각 장단점이 있음):

* 타임아웃을 완화하는 가장 좋은 방법은 JavaScript를 사용하여 양식 제출 시 CSRF 토큰을 요청하는 것입니다.
그런 다음 양식이 CSRF 토큰으로 업데이트되고 제출됩니다.
* 다른 옵션은 세션이 곧 만료될 것임을 사용자에게 알리는 JavaScript를 사용하는 것입니다.
사용자는 버튼을 클릭하여 계속하고 세션을 새로 고칠 수 있습니다.
* 마지막으로, 예상되는 CSRF 토큰을 쿠키에 저장할 수 있습니다.
이렇게 하면 예상되는 CSRF 토큰이 세션보다 오래 지속될 수 있습니다.

예상되는 CSRF 토큰이 기본적으로 쿠키에 저장되지 않는 이유를 물어볼 수 있습니다.
이는 헤더(예: 쿠키를 지정하기 위한)가 다른 도메인에 의해 설정될 수 있는 알려진 공격이 있기 때문입니다.
이는 Ruby on Rails가 X-Requested-With 헤더가 있을 때 https://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/[더 이상 CSRF 검사를 건너뛰지 않는] 이유와 같습니다.
공격 수행 방법에 대한 자세한 내용은 https://web.archive.org/web/20210221120355/https://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html[이 webappsec.org 스레드]를 참조하세요.
또 다른 단점은 상태(즉, 타임아웃)를 제거함으로써 토큰이 손상된 경우 강제로 무효화할 수 있는 능력을 잃는다는 것입니다.

[[csrf-considerations-multipart]]
=== Multipart (파일 업로드)

Multipart 요청(파일 업로드)을 CSRF 공격으로부터 보호하는 것은 https://en.wikipedia.org/wiki/Chicken_or_the_egg[닭이 먼저냐 달걀이 먼저냐] 문제를 야기합니다.
CSRF 공격을 방지하려면 HTTP 요청의 본문을 읽어 실제 CSRF 토큰을 얻어야 합니다.
그러나 본문을 읽는다는 것은 파일이 업로드된다는 의미이며, 이는 외부 사이트가 파일을 업로드할 수 있다는 뜻입니다.

multipart/form-data와 함께 CSRF 보호를 사용하는 데에는 두 가지 옵션이 있습니다:

* <<csrf-considerations-multipart-body,CSRF 토큰을 본문에 배치>>
* <<csrf-considerations-multipart-url,CSRF 토큰을 URL에 배치>>

각 옵션에는 장단점이 있습니다.

[NOTE]
====
Spring Security의 CSRF 보호를 multipart 파일 업로드와 통합하기 전에, 먼저 CSRF 보호 없이 업로드할 수 있는지 확인해야 합니다.
Spring과 함께 multipart 양식을 사용하는 방법에 대한 자세한 정보는 Spring 참조 문서의 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart[1.1.11. Multipart Resolver] 섹션과 https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html[`MultipartFilter` Javadoc]을 참조하세요.
====

[[csrf-considerations-multipart-body]]
==== CSRF 토큰을 본문에 배치
첫 번째 옵션은 실제 CSRF 토큰을 요청 본문에 포함시키는 것입니다.
CSRF 토큰을 본문에 배치함으로써, 인증이 수행되기 전에 본문이 읽힙니다.
이는 누구나 임시 파일을 서버에 올릴 수 있다는 것을 의미합니다.
그러나 오직 인증된 사용자만이 애플리케이션에 의해 처리되는 파일을 제출할 수 있습니다.
일반적으로 이는 권장되는 접근 방식입니다. 임시 파일 업로드는 대부분의 서버에 무시할 만한 영향을 미치기 때문입니다.

[[csrf-considerations-multipart-url]]
==== CSRF 토큰을 URL에 포함
허가되지 않은 사용자가 임시 파일을 업로드하는 것이 허용되지 않는다면, 대안은 양식의 action 속성에 쿼리 파라미터로 예상되는 CSRF 토큰을 포함시키는 것입니다.
이 접근 방식의 단점은 쿼리 파라미터가 유출될 수 있다는 것입니다.
일반적으로 민감한 데이터를 쿼리 파라미터나 본문에 넣는 것이 유출되지 않도록 하는 가장 좋은 방법으로 간주됩니다.
https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3[RFC 2616 섹션 15.1.3 URI에 민감한 정보 인코딩]에서 추가 정보를 찾을 수 있습니다.

[[csrf-considerations-override-method]]
==== HiddenHttpMethodFilter
일부 애플리케이션은 HTTP 메서드를 재정의하기 위해 양식 파라미터를 사용할 수 있습니다.
예를 들어, 다음 양식은 HTTP 메서드를 `post` 대신 ``delete``로 취급할 수 있습니다.

.CSRF 숨겨진 HTTP 메서드 양식
[source,html]
----
<form action="/process"
	method="post">
	<!-- ... -->
	<input type="hidden"
		name="_method"
		value="delete"/>
</form>
----


HTTP 메서드 재정의는 필터에서 발생합니다.
이 필터는 Spring Security의 필터보다 앞에 위치해야 합니다.
재정의는 ``post``에서만 발생하므로 실제로 어떤 실제 문제를 일으킬 가능성은 낮습니다.
그러나 Spring Security의 필터 앞에 위치시키는 것이 여전히 가장 좋은 방법입니다.