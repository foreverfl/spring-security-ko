[[servlet-architecture]]
= 아키텍처
:figures: servlet/architecture

이 섹션에서는 서블릿 기반 애플리케이션에서의 Spring Security의 고수준 아키텍처에 대해 설명합니다.
우리는 이 고수준 이해를 바탕으로 참조 문서의 xref:servlet/authentication/index.adoc#servlet-authentication[인증], xref:servlet/authorization/index.adoc#servlet-authorization[권한 부여], 그리고 xref:servlet/exploits/index.adoc#servlet-exploits[공격 방어] 섹션에서 더 자세히 다룰 것입니다.

[[servlet-filters-review]]
== 필터 개요

Spring Security의 서블릿 지원은 서블릿 필터를 기반으로 하므로, 먼저 필터의 역할을 전반적으로 살펴보는 것이 도움이 됩니다.
다음 이미지는 단일 HTTP 요청에 대한 핸들러의 일반적인 계층을 보여줍니다.

.FilterChain
[[servlet-filterchain-figure]]
image::{figures}/filterchain.png[]

클라이언트가 애플리케이션에 요청을 보내면, 컨테이너는 요청 URI의 경로를 기반으로 ``HttpServletRequest``를 처리해야 하는 `Filter` 인스턴스와 ``Servlet``을 포함하는 ``FilterChain``을 생성합니다.
Spring MVC 애플리케이션에서 ``Servlet``은 {spring-framework-reference-url}web.html#mvc-servlet[`DispatcherServlet`]의 인스턴스입니다.
하나의 ``HttpServletRequest``와 ``HttpServletResponse``를 처리할 수 있는 ``Servlet``은 최대 하나입니다.
그러나 여러 개의 ``Filter``를 사용하여 다음과 같은 작업을 수행할 수 있습니다:

* 다운스트림 ``Filter`` 인스턴스나 ``Servlet``이 호출되는 것을 방지합니다.
이 경우 ``Filter``는 일반적으로 ``HttpServletResponse``를 작성합니다.
* 다운스트림 ``Filter`` 인스턴스와 ``Servlet``이 사용하는 ``HttpServletRequest`` 또는 ``HttpServletResponse``를 수정합니다.

``Filter``의 강력한 기능은 전달받은 ``FilterChain``에서 비롯됩니다.

.`FilterChain` 사용 예시
[tabs]
======
Java::
+
[source,java,role="primary"]
----
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
	// 애플리케이션의 나머지 부분 실행 전에 수행할 작업
    chain.doFilter(request, response); // 애플리케이션의 나머지 부분 호출
    // 애플리케이션의 나머지 부분 실행 후에 수행할 작업
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {
    // 애플리케이션의 나머지 부분 실행 전에 수행할 작업
    chain.doFilter(request, response) // 애플리케이션의 나머지 부분 호출
    // 애플리케이션의 나머지 부분 실행 후에 수행할 작업
}
----
======

``Filter``는 다운스트림 ``Filter`` 인스턴스와 ``Servlet``에만 영향을 미치므로, 각 ``Filter``가 호출되는 순서가 매우 중요합니다.

[[servlet-delegatingfilterproxy]]
== DelegatingFilterProxy

Spring은 서블릿 컨테이너의 생명주기와 Spring의 `ApplicationContext` 사이의 연결을 가능하게 하는 {spring-framework-api-url}org/springframework/web/filter/DelegatingFilterProxy.html[`DelegatingFilterProxy`]라는 `Filter` 구현을 제공합니다.
서블릿 컨테이너는 자체 표준을 사용하여 `Filter` 인스턴스를 등록할 수 있지만, Spring에서 정의한 빈(Bean)을 인식하지 못합니다.
``DelegatingFilterProxy``를 표준 서블릿 컨테이너 메커니즘을 통해 등록할 수 있지만, 모든 작업을 ``Filter``를 구현하는 Spring 빈에 위임할 수 있습니다.

다음은 ``DelegatingFilterProxy``가 <<servlet-filters-review,``Filter`` 인스턴스와 ``FilterChain``>>에 어떻게 들어맞는지 보여주는 그림입니다.

.DelegatingFilterProxy
[[servlet-delegatingfilterproxy-figure]]
image::{figures}/delegatingfilterproxy.png[]

``DelegatingFilterProxy``는 ``ApplicationContext``에서 __Bean Filter~0~__를 찾아 __Bean Filter~0~__를 호출합니다.
다음은 ``DelegatingFilterProxy``의 의사 코드입니다:

.`DelegatingFilterProxy` 의사 코드
[tabs]
======
Java::
+
[source,java,role="primary"]
----
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
	Filter delegate = getFilterBean(someBeanName); // <1>
	delegate.doFilter(request, response); // <2>
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {
	val delegate: Filter = getFilterBean(someBeanName) // <1>
	delegate.doFilter(request, response) // <2>
}
----
======
<1> Spring 빈으로 등록된 Filter를 지연 로딩합니다.
<<servlet-delegatingfilterproxy-figure>> 예시에서 ``delegate``는 __Bean Filter~0~__의 인스턴스입니다.
<2> 작업을 Spring 빈에 위임합니다.

``DelegatingFilterProxy``의 또 다른 이점은 `Filter` 빈 인스턴스 조회를 지연시킬 수 있다는 것입니다.
이는 컨테이너가 시작되기 전에 `Filter` 인스턴스를 등록해야 하기 때문에 중요합니다.
그러나 Spring은 일반적으로 ``ContextLoaderListener``를 사용하여 Spring 빈을 로드하며, 이는 ``Filter`` 인스턴스를 등록해야 할 때까지 완료되지 않습니다.

[[servlet-filterchainproxy]]
== FilterChainProxy

Spring Security의 서블릿 지원은 `FilterChainProxy` 내에 포함되어 있습니다.
``FilterChainProxy``는 Spring Security가 제공하는 특별한 ``Filter``로, <<servlet-securityfilterchain,`SecurityFilterChain`>>을 통해 여러 `Filter` 인스턴스에 위임할 수 있게 합니다.
``FilterChainProxy``는 빈이므로 일반적으로 <<servlet-delegatingfilterproxy>>로 래핑됩니다.

다음 이미지는 ``FilterChainProxy``의 역할을 보여줍니다.

.FilterChainProxy
[[servlet-filterchainproxy-figure]]
image::{figures}/filterchainproxy.png[]

[[servlet-securityfilterchain]]
== SecurityFilterChain

{security-api-url}org/springframework/security/web/SecurityFilterChain.html[`SecurityFilterChain`]은 <<servlet-filterchainproxy>>에 의해 사용되어 현재 요청에 대해 어떤 Spring Security `Filter` 인스턴스를 호출해야 하는지 결정합니다.

다음 이미지는 ``SecurityFilterChain``의 역할을 보여줍니다.

.SecurityFilterChain
[[servlet-securityfilterchain-figure]]
image::{figures}/securityfilterchain.png[]

``SecurityFilterChain``의 <<servlet-security-filters,Security Filters>>는 일반적으로 빈이지만, <<servlet-delegatingfilterproxy>> 대신 ``FilterChainProxy``에 등록됩니다.
``FilterChainProxy``는 서블릿 컨테이너나 <<servlet-delegatingfilterproxy>>에 직접 등록하는 것보다 여러 가지 이점을 제공합니다.
첫째, Spring Security의 모든 서블릿 지원에 대한 시작점을 제공합니다.
따라서 Spring Security의 서블릿 지원을 디버깅하려고 할 때 ``FilterChainProxy``에 중단점을 추가하는 것이 좋은 시작점이 됩니다.

둘째, ``FilterChainProxy``는 Spring Security 사용의 중심이기 때문에 선택적으로 간주되지 않는 작업을 수행할 수 있습니다.
예를 들어, 메모리 누수를 방지하기 위해 ``SecurityContext``를 지웁니다.
또한 Spring Security의 xref:servlet/exploits/firewall.adoc#servlet-httpfirewall[`HttpFirewall`]을 적용하여 특정 유형의 공격으로부터 애플리케이션을 보호합니다.

또한 ``SecurityFilterChain``이 호출되어야 하는 시기를 결정하는 데 있어 더 많은 유연성을 제공합니다.
서블릿 컨테이너에서 `Filter` 인스턴스는 URL만을 기반으로 호출됩니다.
그러나 ``FilterChainProxy``는 `RequestMatcher` 인터페이스를 사용하여 ``HttpServletRequest``의 모든 항목을 기반으로 호출을 결정할 수 있습니다.

다음 이미지는 여러 `SecurityFilterChain` 인스턴스를 보여줍니다:

.Multiple SecurityFilterChain
[[servlet-multi-securityfilterchain-figure]]
image::{figures}/multi-securityfilterchain.png[]

<<servlet-multi-securityfilterchain-figure>> 그림에서 ``FilterChainProxy``는 어떤 ``SecurityFilterChain``을 사용해야 할지 결정합니다.
일치하는 첫 번째 ``SecurityFilterChain``만 호출됩니다.
`/api/messages/` URL이 요청되면, 먼저 ``SecurityFilterChain~0~``의 ``+/api/**+`` 패턴과 일치하므로 ``SecurityFilterChain~0~``만 호출됩니다. 이는 ``SecurityFilterChain~n~``과도 일치하더라도 마찬가지입니다.
`/messages/` URL이 요청되면, ``SecurityFilterChain~0~``의 ``+/api/**+`` 패턴과 일치하지 않으므로 ``FilterChainProxy``는 계속해서 각 ``SecurityFilterChain``을 시도합니다.
다른 ``SecurityFilterChain`` 인스턴스가 일치하지 않는다고 가정하면, ``SecurityFilterChain~n~``이 호출됩니다.

``SecurityFilterChain~0~``에는 세 개의 보안 `Filter` 인스턴스만 구성되어 있습니다.
그러나 ```SecurityFilterChain~n~```에는 네 개의 보안 `Filter` 인스턴스가 구성되어 있습니다.
각 ``SecurityFilterChain``이 고유하며 독립적으로 구성될 수 있다는 점을 주목해야 합니다.
실제로 애플리케이션이 특정 요청을 Spring Security가 무시하기를 원한다면 ``SecurityFilterChain``에 보안 `Filter` 인스턴스가 없을 수도 있습니다.

[[servlet-security-filters]]
== Security Filters

Security Filters는 <<servlet-securityfilterchain>> API를 통해 <<servlet-filterchainproxy>>에 삽입됩니다.
이러한 필터들은 xref:servlet/authentication/index.adoc[인증], xref:servlet/authorization/index.adoc[권한 부여], xref:servlet/exploits/index.adoc[공격 방어] 등 다양한 목적으로 사용될 수 있습니다.
필터들은 적절한 시기에 호출되도록 특정 순서로 실행됩니다. 예를 들어, 인증을 수행하는 ``Filter``는 권한 부여를 수행하는 ``Filter`` 이전에 호출되어야 합니다.
일반적으로 Spring Security ``Filter``의 순서를 알 필요는 없습니다.
그러나 순서를 알아야 할 때가 있다면, {gh-url}/config/src/main/java/org/springframework/security/config/annotation/web/builders/FilterOrderRegistration.java[`FilterOrderRegistration` 코드]를 확인할 수 있습니다.

위 내용을 예시로 들기 위해, 다음과 같은 보안 설정을 고려해 봅시다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(Customizer.withDefaults())
            .authorizeHttpRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .formLogin(Customizer.withDefaults());
        return http.build();
    }

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.config.web.servlet.invoke

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            csrf { }
            authorizeHttpRequests {
                authorize(anyRequest, authenticated)
            }
            httpBasic { }
            formLogin { }
        }
        return http.build()
    }

}
----
======

위의 구성은 다음과 같은 `Filter` 순서를 만들어냅니다:

[cols="1,1", options="header"]
|====
| 필터 | 추가된 위치
| xref:servlet/exploits/csrf.adoc[CsrfFilter] | `HttpSecurity#csrf`
| xref:servlet/authentication/passwords/form.adoc#servlet-authentication-form[UsernamePasswordAuthenticationFilter] | `HttpSecurity#formLogin`
| xref:servlet/authentication/passwords/basic.adoc[BasicAuthenticationFilter] | `HttpSecurity#httpBasic`
| xref:servlet/authorization/authorize-http-requests.adoc[AuthorizationFilter] | `HttpSecurity#authorizeHttpRequests`
|====

1. 먼저, ``CsrfFilter``가 호출되어 xref:servlet/exploits/csrf.adoc[CSRF 공격]으로부터 보호합니다.
2. 둘째, 인증 필터들이 호출되어 요청을 인증합니다.
3. 셋째, ``AuthorizationFilter``가 호출되어 요청을 승인합니다.

[NOTE]
====
위에 나열되지 않은 다른 `Filter` 인스턴스가 있을 수 있습니다.
특정 요청에 대해 호출되는 필터 목록을 보고 싶다면, <<servlet-print-filters,필터를 출력>>할 수 있습니다.
====

[[servlet-print-filters]]
=== 보안 필터 출력하기

종종 특정 요청에 대해 호출되는 보안 `Filter` 목록을 보는 것이 유용할 수 있습니다.
예를 들어, <<adding-custom-filter,추가한 필터>>가 보안 필터 목록에 있는지 확인하고 싶을 수 있습니다.

필터 목록은 애플리케이션 시작 시 INFO 레벨로 출력되므로, 콘솔 출력에서 다음과 같은 내용을 볼 수 있습니다:

[source,text,role="terminal"]
----
2023-06-14T08:55:22.321-03:00  INFO 76975 --- [           main] o.s.s.web.DefaultSecurityFilterChain     : Will secure any request with [
org.springframework.security.web.session.DisableEncodeUrlFilter@404db674,
org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@50f097b5,
org.springframework.security.web.context.SecurityContextHolderFilter@6fc6deb7,
org.springframework.security.web.header.HeaderWriterFilter@6f76c2cc,
org.springframework.security.web.csrf.CsrfFilter@c29fe36,
org.springframework.security.web.authentication.logout.LogoutFilter@ef60710,
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@7c2dfa2,
org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@4397a639,
org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@7add838c,
org.springframework.security.web.authentication.www.BasicAuthenticationFilter@5cc9d3d0,
org.springframework.security.web.savedrequest.RequestCacheAwareFilter@7da39774,
org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@32b0876c,
org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3662bdff,
org.springframework.security.web.access.ExceptionTranslationFilter@77681ce4,
org.springframework.security.web.access.intercept.AuthorizationFilter@169268a7]
----

이는 <<servlet-securityfilterchain,각 필터 체인>>에 대해 구성된 보안 필터에 대한 좋은 아이디어를 제공합니다.

그러나 이것이 전부는 아닙니다. 각 요청에 대해 개별 필터의 호출을 출력하도록 애플리케이션을 구성할 수도 있습니다.
이는 추가한 필터가 특정 요청에 대해 호출되는지 확인하거나 예외가 어디서 발생하는지 확인하는 데 도움이 됩니다.
이를 위해 <<servlet-logging,보안 이벤트를 로깅>>하도록 애플리케이션을 구성할 수 있습니다.

[[adding-custom-filter]]
=== 필터 체인에 사용자 정의 필터 추가하기

대부분의 경우, 기본 보안 필터만으로도 애플리케이션의 보안을 제공하기에 충분합니다.
그러나 보안 필터 체인에 사용자 정의 ``Filter``를 추가해야 할 때가 있을 수 있습니다.

예를 들어, 테넌트 ID 헤더를 가져와서 현재 사용자가 해당 테넌트에 접근할 수 있는지 확인하는 ``Filter``를 추가하고 싶다고 가정해 봅시다.
이 설명은 이미 필터를 어디에 추가해야 할지에 대한 힌트를 제공합니다. 현재 사용자를 알아야 하므로 인증 필터 이후에 추가해야 합니다.

먼저 ``Filter``를 만들어 봅시다:

[source,java]
----
import java.io.IOException;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import org.springframework.security.access.AccessDeniedException;

public class TenantFilter implements Filter {

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        String tenantId = request.getHeader("X-Tenant-Id"); <1>
        boolean hasAccess = isUserAllowed(tenantId); <2>
        if (hasAccess) {
            filterChain.doFilter(request, response); <3>
            return;
        }
        throw new AccessDeniedException("접근 거부"); <4>
    }

}

----

위의 샘플 코드는 다음과 같은 작업을 수행합니다:

<1> 요청 헤더에서 테넌트 ID를 가져옵니다.
<2> 현재 사용자가 테넌트 ID에 접근할 수 있는지 확인합니다.
<3> 사용자가 접근 권한이 있다면 체인의 나머지 필터들을 호출합니다.
<4> 사용자가 접근 권한이 없다면 `AccessDeniedException`을 던집니다.

[TIP]
====
``Filter``를 구현하는 대신 {spring-framework-api-url}org/springframework/web/filter/OncePerRequestFilter.html[OncePerRequestFilter]를 확장할 수 있습니다. 이는 요청당 한 번만 호출되는 필터의 기본 클래스이며 `doFilterInternal` 메서드를 제공하여 ``HttpServletRequest``와 ``HttpServletResponse`` 파라미터를 사용할 수 있습니다.
====

이제 이 필터를 보안 필터 체인에 추가해야 합니다.
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        // ...
        .addFilterBefore(new TenantFilter(), AuthorizationFilter.class); <1>
    return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun filterChain(http: HttpSecurity): SecurityFilterChain {
    http
        // ...
        .addFilterBefore(TenantFilter(), AuthorizationFilter::class.java) <1>
    return http.build()
}
----
======

<1> ``HttpSecurity#addFilterBefore``를 사용하여 ``TenantFilter``를 ``AuthorizationFilter`` 이전에 추가합니다.

``TenantFilter``를 ``AuthorizationFilter`` 이전에 추가함으로써 인증 필터 이후에 ``TenantFilter``가 호출되도록 보장합니다.
``HttpSecurity#addFilterAfter``를 사용하여 특정 필터 이후에 필터를 추가하거나 ``HttpSecurity#addFilterAt``을 사용하여 필터 체인의 특정 위치에 필터를 추가할 수도 있습니다.

이제 ``TenantFilter``가 필터 체인에서 호출되어 현재 사용자가 테넌트 ID에 접근할 수 있는지 확인합니다.

필터를 ``@Component``로 주석을 달거나 구성에서 빈으로 선언하여 Spring 빈으로 선언할 때 주의해야 합니다. Spring Boot는 자동으로 {spring-boot-reference-url}web.html#web.servlet.embedded-container.servlets-filters-listeners.beans[내장 컨테이너에 등록]하기 때문입니다.
이로 인해 필터가 컨테이너에 의해 한 번, Spring Security에 의해 한 번, 총 두 번 호출될 수 있으며 순서도 다를 수 있습니다.

필터를 Spring 빈으로 선언하여 의존성 주입 등의 이점을 활용하면서도 중복 호출을 피하고 싶다면, `FilterRegistrationBean` 빈을 선언하고 `enabled` 속성을 ``false``로 설정하여 컨테이너에 등록되지 않도록 할 수 있습니다:

[source,java]
----
@Bean
public FilterRegistrationBean<TenantFilter> tenantFilterRegistration(TenantFilter filter) {
    FilterRegistrationBean<TenantFilter> registration = new FilterRegistrationBean<>(filter);
    registration.setEnabled(false);
    return registration;
}
----


[[servlet-exceptiontranslationfilter]]
== 보안 예외 처리


{security-api-url}org/springframework/security/web/access/ExceptionTranslationFilter.html[`ExceptionTranslationFilter`]는 {security-api-url}org/springframework/security/access/AccessDeniedException.html[`AccessDeniedException`]과 {security-api-url}/org/springframework/security/core/AuthenticationException.html[`AuthenticationException`]을 HTTP 응답으로 변환할 수 있게 합니다.

``ExceptionTranslationFilter``는 <<servlet-filterchainproxy>>에 <<servlet-security-filters>> 중 하나로 삽입됩니다.

다음 이미지는 ``ExceptionTranslationFilter``와 다른 컴포넌트들 간의 관계를 보여줍니다:

image::{figures}/exceptiontranslationfilter.png[]


* image:{icondir}/number_1.png[] 먼저, ``ExceptionTranslationFilter``는 ``FilterChain.doFilter(request, response)``를 호출하여 애플리케이션의 나머지 부분을 실행합니다.
* image:{icondir}/number_2.png[] 사용자가 인증되지 않았거나 ``AuthenticationException``인 경우, __인증 시작__.
** xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder]가 지워집니다.
** ``HttpServletRequest``가 <<savedrequests,저장>>되어 인증이 성공한 후 원래 요청을 재실행하는 데 사용될 수 있습니다.
** ``AuthenticationEntryPoint``는 클라이언트에 자격 증명을 요청하는 데 사용됩니다.
예를 들어, 로그인 페이지로 리다이렉트하거나 ``WWW-Authenticate`` 헤더를 보낼 수 있습니다.
* image:{icondir}/number_3.png[] 그렇지 않고 ``AccessDeniedException``인 경우, __접근 거부__.
`AccessDeniedHandler`가 호출되어 접근 거부를 처리합니다.

[NOTE]
====
애플리케이션이 ``AccessDeniedException``이나 ``AuthenticationException``을 던지지 않으면 ``ExceptionTranslationFilter``는 아무 작업도 수행하지 않습니다.
====

``ExceptionTranslationFilter``의 의사 코드는 다음과 같습니다:

.ExceptionTranslationFilter 의사 코드
[source,java]
----
try {
	filterChain.doFilter(request, response); // <1>
} catch (AccessDeniedException | AuthenticationException ex) {
	if (!authenticated || ex instanceof AuthenticationException) {
		startAuthentication(); // <2>
	} else {
		accessDenied(); // <3>
	}
}
----
<1> <<servlet-filters-review>>에서 설명한 대로, ``FilterChain.doFilter(request, response)``를 호출하는 것은 애플리케이션의 나머지 부분을 호출하는 것과 같습니다.
이는 애플리케이션의 다른 부분(<<servlet-authorization-filtersecurityinterceptor,`FilterSecurityInterceptor`>> 또는 메서드 보안)이 ``AuthenticationException``이나 `AccessDeniedException`을 던지면 여기서 잡아서 처리된다는 것을 의미합니다.
<2> 사용자가 인증되지 않았거나 ``AuthenticationException``인 경우, __인증 시작__.
<3> 그렇지 않으면, __접근 거부__.

[[savedrequests]]
== 인증 간 요청 저장하기

<<servlet-exceptiontranslationfilter>>에서 설명한 대로, 인증되지 않은 요청이 인증이 필요한 리소스에 대한 것일 때, 인증이 성공한 후 인증된 리소스에 대한 요청을 다시 요청할 필요가 있습니다. Spring Security에서는 이를 <<requestcache,`RequestCache`>> 구현을 사용하여 ``HttpServletRequest``를 저장함으로써 수행합니다.

[[requestcache]]
=== RequestCache

``HttpServletRequest``는 {security-api-url}org/springframework/security/web/savedrequest/RequestCache.html[`RequestCache`]에 저장됩니다.
사용자가 성공적으로 인증하면, ``RequestCache``를 사용하여 원래 요청을 재실행합니다.
<<requestcacheawarefilter,`RequestCacheAwareFilter`>>는 사용자 인증 후 저장된 ``HttpServletRequest``를 가져오기 위해 ``RequestCache``를 사용하며, ``ExceptionTranslationFilter``는 ``AuthenticationException``을 감지한 후 사용자를 로그인 엔드포인트로 리다이렉트하기 전에 ``HttpServletRequest``를 저장하기 위해 `RequestCache`를 사용합니다.

기본적으로 ``HttpSessionRequestCache``가 사용됩니다.
아래 코드는 `continue` 매개변수가 존재할 때 저장된 요청에 대해 `HttpSession`을 확인하는 데 사용되는 ``RequestCache`` 구현을 어떻게 사용자 정의할 수 있는지 보여줍니다.

include::partial$servlet/architecture/request-cache-continue.adoc[]

[[requestcache-prevent-saved-request]]
==== 요청 저장 방지하기

사용자의 인증되지 않은 요청을 세션에 저장하고 싶지 않은 이유가 여러 가지 있을 수 있습니다.
그 저장을 사용자의 브라우저로 옮기거나 데이터베이스에 저장하고 싶을 수 있습니다.
또는 사용자를 항상 로그인 전에 방문하려고 했던 페이지 대신 홈페이지로 리다이렉트하고 싶어서 이 기능을 끄고 싶을 수 있습니다.

이를 위해 {security-api-url}org/springframework/security/web/savedrequest/NullRequestCache.html[`NullRequestCache` 구현]을 사용할 수 있습니다.

.요청 저장 방지하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityFilterChain springSecurity(HttpSecurity http) throws Exception {
    RequestCache nullRequestCache = new NullRequestCache();
    http
        // ...
        .requestCache((cache) -> cache
            .requestCache(nullRequestCache)
        );
    return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun springSecurity(http: HttpSecurity): SecurityFilterChain {
    val nullRequestCache = NullRequestCache()
    http {
        requestCache {
            requestCache = nullRequestCache
        }
    }
    return http.build()
}
----

XML::
+
[source,xml,role="secondary"]
----
<http auto-config="true">
	<!-- ... -->
	<request-cache ref="nullRequestCache"/>
</http>

<b:bean id="nullRequestCache" class="org.springframework.security.web.savedrequest.NullRequestCache"/>
----
======


[[requestcacheawarefilter]]
=== RequestCacheAwareFilter

{security-api-url}org/springframework/security/web/savedrequest/RequestCacheAwareFilter.html[`RequestCacheAwareFilter`]는 <<requestcache,`RequestCache`>>를 사용하여 원래 요청을 재실행합니다.

[[servlet-logging]]
== 로깅

Spring Security는 모든 보안 관련 이벤트에 대해 DEBUG 및 TRACE 레벨에서 포괄적인 로깅을 제공합니다.
이는 애플리케이션을 디버깅할 때 매우 유용할 수 있습니다. 보안 조치를 위해 Spring Security는 요청이 거부된 이유에 대한 세부 정보를 응답 본문에 추가하지 않기 때문입니다.
401이나 403 오류를 만나면, 무슨 일이 일어나고 있는지 이해하는 데 도움이 되는 로그 메시지를 찾을 가능성이 높습니다.

xref:servlet/exploits/csrf.adoc[CSRF 보호]가 활성화된 리소스에 CSRF 토큰 없이 `POST` 요청을 시도하는 사용자의 예를 살펴보겠습니다.
로그 없이는 사용자는 요청이 거부된 이유에 대한 설명 없이 403 오류만 보게 됩니다.
그러나 Spring Security에 대한 로깅을 활성화하면 다음과 같은 로그 메시지를 볼 수 있습니다:

[source,text]
----
2023-06-14T09:44:25.797-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Securing POST /hello
2023-06-14T09:44:25.797-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Invoking DisableEncodeUrlFilter (1/15)
2023-06-14T09:44:25.798-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Invoking WebAsyncManagerIntegrationFilter (2/15)
2023-06-14T09:44:25.800-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Invoking SecurityContextHolderFilter (3/15)
2023-06-14T09:44:25.801-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Invoking HeaderWriterFilter (4/15)
2023-06-14T09:44:25.802-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.security.web.FilterChainProxy        : Invoking CsrfFilter (5/15)
2023-06-14T09:44:25.814-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.security.web.csrf.CsrfFilter         : Invalid CSRF token found for http://localhost:8080/hello
2023-06-14T09:44:25.814-03:00 DEBUG 76975 --- [nio-8080-exec-1] o.s.s.w.access.AccessDeniedException   : Responding with 403 status code
2023-06-14T09:44:25.814-03:00 TRACE 76975 --- [nio-8080-exec-1] o.s.s.w.header.writers.HstsHeaderWriter  : Not injecting HSTS header since it did not match request to [Is Secure]
----

CSRF 토큰이 누락되어 요청이 거부되고 있다는 것이 명확해집니다.

애플리케이션이 모든 보안 이벤트를 로깅하도록 구성하려면 다음을 애플리케이션에 추가할 수 있습니다:

====
.Spring Boot의 application.properties
[source,properties,role="primary"]
----
logging.level.org.springframework.security=TRACE
----
.logback.xml
[source,xml,role="secondary"]
----
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <!-- ... -->
    </appender>
    <!-- ... -->
    <logger name="org.springframework.security" level="trace" additivity="false">
        <appender-ref ref="Console" />
    </logger>
</configuration>
----
====