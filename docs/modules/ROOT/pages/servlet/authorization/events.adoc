[[servlet-events]]
= 권한 부여 이벤트

권한 부여가 거부될 때마다 ``AuthorizationDeniedEvent``가 발생합니다.
또한, 권한이 부여된 경우 ``AuthorizationGrantedEvent``를 발생시킬 수 있습니다.

이러한 이벤트를 수신하려면 먼저 ``AuthorizationEventPublisher``를 등록해야 합니다.

Spring Security의 ``SpringAuthorizationEventPublisher``가 적합할 것입니다.
이는 Spring의 ``ApplicationEventPublisher``를 사용하여 권한 부여 이벤트를 등록합니다.:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public AuthorizationEventPublisher authorizationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    return new SpringAuthorizationEventPublisher(applicationEventPublisher);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authorizationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthorizationEventPublisher {
    return SpringAuthorizationEventPublisher(applicationEventPublisher)
}
----
======

그런 다음 Spring의 `@EventListener` 지원을 사용할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class AuthenticationEvents {

    @EventListener
    public void onFailure(AuthorizationDeniedEvent failure) {
		// ...
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
class AuthenticationEvents {

    @EventListener
    fun onFailure(failure: AuthorizationDeniedEvent?) {
        // ...
    }
}
----
======

[[authorization-granted-events]]
== 권한 부여 승인 이벤트

``AuthorizationGrantedEvent``는 불필요하게 많이 발생할 가능성이 때문에 기본적으로 등록되지 않습니다.

실제로, 이러한 이벤트를 등록하려면 애플리케이션이 불필요하게 많이 발생하는 권한 부여 이벤트로 인해 부담을 받지 않도록 하기 위해 일부 비즈니스 로직이 필요할 것입니다.

성공 이벤트를 필터링하는 자체 이벤트 등록자를 만들 수 있습니다.
예를 들어, 다음 등록자는 ``ROLE_ADMIN``이 필요한 권한 부여 승인만 등록합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class MyAuthorizationEventPublisher implements AuthorizationEventPublisher {
    private final ApplicationEventPublisher publisher;
    private final AuthorizationEventPublisher delegate;

    public MyAuthorizationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
        this.delegate = new SpringAuthorizationEventPublisher(publisher);
    }

    @Override
    public <T> void publishAuthorizationEvent(Supplier<Authentication> authentication,
            T object, AuthorizationDecision decision) {
        if (decision == null) {
            return;
        }
        if (!decision.isGranted()) {
            this.delegate.publishAuthorizationEvent(authentication, object, decision);
            return;
        }
        if (shouldThisEventBePublished(decision)) {
            AuthorizationGrantedEvent granted = new AuthorizationGrantedEvent(
                    authentication, object, decision);
            this.publisher.publishEvent(granted);
        }
    }

    private boolean shouldThisEventBePublished(AuthorizationDecision decision) {
        if (!(decision instanceof AuthorityAuthorizationDecision)) {
            return false;
        }
        Collection<GrantedAuthority> authorities = ((AuthorityAuthorizationDecision) decision).getAuthorities();
        for (GrantedAuthority authority : authorities) {
            if ("ROLE_ADMIN".equals(authority.getAuthority())) {
                return true;
            }
        }
        return false;
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
class MyAuthorizationEventPublisher(val publisher: ApplicationEventPublisher,
    val delegate: SpringAuthorizationEventPublisher = SpringAuthorizationEventPublisher(publisher)):
    AuthorizationEventPublisher {

    override fun <T : Any?> publishAuthorizationEvent(
        authentication: Supplier<Authentication>?,
        `object`: T,
        decision: AuthorizationDecision?
    ) {
        if (decision == null) {
            return
        }
        if (!decision.isGranted) {
            this.delegate.publishAuthorizationEvent(authentication, `object`, decision)
            return
        }
        if (shouldThisEventBePublished(decision)) {
            val granted = AuthorizationGrantedEvent(authentication, `object`, decision)
            this.publisher.publishEvent(granted)
        }
    }

    private fun shouldThisEventBePublished(decision: AuthorizationDecision): Boolean {
        if (decision !is AuthorityAuthorizationDecision) {
            return false
        }
        val authorities = decision.authorities
        for (authority in authorities) {
            if ("ROLE_ADMIN" == authority.authority) {
                return true
            }
        }
        return false
    }
}
----
======