[[servlet-authorization-authorizationfilter]]
= HttpServletRequest 권한 부여하기
:figures: servlet/authorization

Spring Security를 사용하면 요청 수준에서 xref:servlet/authorization/index.adoc[권한 부여를 모델링]할 수 있습니다.
예를 들어, Spring Security를 사용하여 `/admin` 하위의 모든 페이지에 특정 권한이 필요하고 다른 모든 페이지는 단순히 인증만 필요하다고 지정할 수 있습니다.

기본적으로 Spring Security는 모든 요청에 인증이 필요하도록 요구합니다.
그러나 xref:servlet/configuration/java.adoc#jc-httpsecurity[`HttpSecurity` 인스턴스]를 사용할 때마다 권한 부여 규칙을 선언해야 합니다.

[[activate-request-security]]
`HttpSecurity` 인스턴스가 있을 때마다 최소한 다음과 같이 해야 합니다:

.authorizeHttpRequests 사용하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .anyRequest().authenticated()
    )
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize(anyRequest, authenticated)
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<http>
    <intercept-url pattern="/**" access="authenticated"/>
</http>
----
======

이는 Spring Security에게 애플리케이션의 모든 엔드포인트에 대해 최소한 보안 컨텍스트가 인증되어야 액세스를 허용한다고 알려줍니다.

많은 경우, 권한 부여 규칙이 이보다 더 복잡할 수 있으므로 다음과 같은 사용 사례를 고려해보세요:

* ``authorizeRequests``를 사용하는 앱이 있고 <<migrate-authorize-requests,``authorizeHttpRequests``로 마이그레이션>>하고 싶습니다
* <<request-authorization-architecture,``AuthorizationFilter`` 컴포넌트가 어떻게 작동하는지>> 이해하고 싶습니다
* 패턴을 기반으로 <<match-requests, 요청을 매칭>>하고 싶습니다; 특히 <<match-by-regex,정규식>>을 사용하고 싶습니다
* 요청을 매칭하고 싶은데, Spring MVC를 <<mvc-not-default-servlet, 기본 서블릿이 아닌 다른 곳에 매핑>>했습니다
* <<authorize-requests, 요청을 권한 부여>>하고 싶습니다
* <<match-by-custom, 프로그래밍 방식으로 요청을 매칭>>하고 싶습니다
* <<authorize-requests, 프로그래밍 방식으로 요청을 권한 부여>>하고 싶습니다
* <<remote-authorization-manager, 정책 에이전트에 요청 권한 부여를 위임>>하고 싶습니다

[[request-authorization-architecture]]
== 요청 권한 부여 컴포넌트의 작동 방식 이해하기

[NOTE]
이 섹션은 xref:servlet/architecture.adoc#servlet-architecture[서블릿 아키텍처 및 구현]을 기반으로 하여 서블릿 기반 애플리케이션에서 요청 수준의 xref:servlet/authorization/index.adoc#servlet-authorization[권한 부여]가 어떻게 작동하는지 더 자세히 살펴봅니다.

.HttpServletRequest 권한 부여
image::{figures}/authorizationfilter.png[]

* image:{icondir}/number_1.png[] 먼저, ``AuthorizationFilter``는 xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontextholder[SecurityContextHolder]에서 xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[Authentication]을 검색하는 ``Supplier``를 구성합니다.
* image:{icondir}/number_2.png[] 그 다음, ``Supplier<Authentication>``과 ``HttpServletRequest``를 xref:servlet/architecture.adoc#authz-authorization-manager[`AuthorizationManager`]에 전달합니다.
``AuthorizationManager``는 요청을 ``authorizeHttpRequests``의 패턴과 매칭하고 해당하는 규칙을 실행합니다.
** image:{icondir}/number_3.png[] 권한 부여가 거부되면 xref:servlet/authorization/events.adoc[``AuthorizationDeniedEvent``가 발행]되고 ``AccessDeniedException``이 발생합니다.
이 경우 xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`]가 `AccessDeniedException`을 처리합니다.
** image:{icondir}/number_4.png[] 액세스가 허용되면 xref:servlet/authorization/events.adoc[``AuthorizationGrantedEvent``가 발행]되고 ``AuthorizationFilter``는 xref:servlet/architecture.adoc#servlet-filters-review[FilterChain]을 계속 진행하여 애플리케이션이 정상적으로 처리되도록 합니다.

=== ``AuthorizationFilter``는 기본적으로 마지막에 위치

``AuthorizationFilter``는 기본적으로 xref:servlet/architecture.adoc#servlet-filterchain-figure[Spring Security 필터 체인]의 마지막에 위치합니다.
이는 Spring Security의 xref:servlet/authentication/index.adoc[인증 필터], xref:servlet/exploits/index.adoc[취약점 보호], 그리고 다른 필터 통합이 권한 부여를 필요로 하지 않음을 의미합니다.
``AuthorizationFilter`` 이전에 자체 필터를 추가하면 해당 필터도 권한 부여가 필요하지 않습니다. 그렇지 않으면 권한 부여가 필요합니다.

이는 일반적으로 {spring-framework-reference-url}web.html#spring-web[Spring MVC] 엔드포인트를 추가할 때 중요해집니다.
이들은 {spring-framework-reference-url}web.html#mvc-servlet[`DispatcherServlet`]에 의해 실행되며 이는 `AuthorizationFilter` 이후에 오기 때문에, 엔드포인트가 허용되려면 <<authorizing-endpoints,`authorizeHttpRequests`에 포함>>되어야 합니다.

=== 모든 디스패치가 권한 부여됨

``AuthorizationFilter``는 모든 요청뿐만 아니라 모든 디스패치에서도 실행됩니다.
이는 `REQUEST` 디스패치가 권한 부여를 필요로 하지만, `FORWARD`, `ERROR`, ``INCLUDE``도 마찬가지임을 의미합니다.

예를 들어, {spring-framework-reference-url}web.html#spring-web[Spring MVC]는 Thymeleaf 템플릿을 렌더링하는 뷰 리졸버로 요청을 ``FORWARD``할 수 있습니다:

.Spring MVC 컨트롤러 포워딩 예시
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class MyController {
    @GetMapping("/endpoint")
    public String endpoint() {
        return "endpoint";
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class MyController {
    @GetMapping("/endpoint")
    fun endpoint(): String {
        return "endpoint"
    }
}
----
======

이 경우 권한 부여는 두 번 발생합니다. 한 번은 ``/endpoint``를 권한 부여하고, 다른 한 번은 "endpoint" 템플릿을 렌더링하기 위해 Thymeleaf로 포워딩할 때입니다.

이러한 이유로 <<match-by-dispatcher-type, 모든 `FORWARD` 디스패치를 허용>>하고 싶을 수 있습니다.

이 원칙의 또 다른 예는 {spring-boot-reference-url}web.html#web.servlet.spring-mvc.error-handling[Spring Boot가 오류를 처리하는 방식]입니다.
컨테이너가 예외를 잡으면, 예를 들어 다음과 같은 경우:

.오류 발생 Spring MVC 컨트롤러 예시
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class MyController {
    @GetMapping("/endpoint")
    public String endpoint() {
        throw new UnsupportedOperationException("unsupported");
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
class MyController {
    @GetMapping("/endpoint")
    fun endpoint(): String {
        throw UnsupportedOperationException("unsupported")
    }
}
----
======

그러면 Boot는 이를 `ERROR` 디스패치로 보냅니다.

이 경우에도 권한 부여는 두 번 발생합니다. 한 번은 ``/endpoint``를 권한 부여하고, 다른 한 번은 오류를 디스패치할 때입니다.

이러한 이유로 <<match-by-dispatcher-type, 모든 `ERROR` 디스패치를 허용>>하고 싶을 수 있습니다.

=== `Authentication` 조회는 지연됨

xref:servlet/authorization/architecture.adoc#_the_authorizationmanager[`AuthorizationManager` API는 ``Supplier<Authentication>``을 사용]한다는 점을 기억하세요.

이는 ``authorizeHttpRequests``에서 요청이 <<authorize-requests,항상 허용되거나 항상 거부될 때>> 중요합니다.
이러한 경우 xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`]이 조회되지 않아 요청 처리가 더 빨라집니다.

[[authorizing-endpoints]]
== 엔드포인트 권한 부여하기

여러 규칙을 우선순위에 따라 추가하여 Spring Security를 구성할 수 있습니다.

``/endpoint``가 `USER` 권한을 가진 최종 사용자만 접근 가능하도록 하려면 다음과 같이 할 수 있습니다:

.엔드포인트 권한 부여
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public SecurityFilterChain web(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests((authorize) -> authorize
	    .requestMatchers("/endpoint").hasAuthority("USER")
            .anyRequest().authenticated()
        )
        // ...
        
    return http.build();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun web(http: HttpSecurity): SecurityFilterChain {
    http {
        authorizeHttpRequests {
            authorize("/endpoint", hasAuthority("USER"))
            authorize(anyRequest, authenticated)
        }
    }
    
    return http.build()
}
----

Xml::
+
[source,xml,role="secondary"]
----
<http>
    <intercept-url pattern="/endpoint" access="hasAuthority('USER')"/>
    <intercept-url pattern="/**" access="authenticated"/>
</http>
----
======

보시다시피 선언은 패턴/규칙 쌍으로 나눌 수 있습니다.

``AuthorizationFilter``는 이러한 쌍을 나열된 순서대로 처리하며, 요청과 일치하는 첫 번째 패턴만 적용합니다.
이는 ``/**``가 ``/endpoint``와도 일치하지만 위의 규칙들이 문제가 되지 않는다는 것을 의미합니다.
위의 규칙을 읽는 방법은 "요청이 ``/endpoint``이면 `USER` 권한을 요구하고, 그렇지 않으면 인증만 요구한다"입니다.

Spring Security는 여러 패턴과 규칙을 지원하며, 각각을 프로그래밍 방식으로 직접 만들 수도 있습니다.

권한 부여가 완료되면 xref:servlet/test/method.adoc#test-method-withmockuser[Security의 테스트 지원]을 사용하여 다음과 같이 테스트할 수 있습니다:

.엔드포인트 권한 부여 테스트
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@WithMockUser(authorities="USER")
@Test
void endpointWhenUserAuthorityThenAuthorized() {
    this.mvc.perform(get("/endpoint"))
        .andExpect(status().isOk());
}

@WithMockUser
@Test
void endpointWhenNotUserAuthorityThenForbidden() {
    this.mvc.perform(get("/endpoint"))
        .andExpect(status().isForbidden());
}

@Test
void anyWhenUnauthenticatedThenUnauthorized() {
    this.mvc.perform(get("/any"))
        .andExpect(status().isUnauthorized());
}
----
======

[[match-requests]]
== 요청 매칭하기

위에서 이미 <<authorizing-endpoints, 요청을 매칭하는 두 가지 방법>>을 보았습니다.

첫 번째는 가장 간단한 방법으로, 모든 요청을 매칭하는 것입니다.

두 번째는 URI 패턴으로 매칭하는 것입니다.
Spring Security는 URI 패턴 매칭을 위해 두 가지 언어를 지원합니다: <<match-by-ant,Ant>> (위에서 본 것처럼)와 <<match-by-regex,정규 표현식>>입니다.

[[match-by-ant]]
=== Ant를 사용한 매칭
Ant는 Spring Security가 요청을 매칭하는 데 사용하는 기본 언어입니다.

이를 사용하여 단일 엔드포인트나 디렉토리를 매칭할 수 있으며, 나중에 사용할 플레이스홀더를 캡처할 수도 있습니다.
또한 특정 HTTP 메소드 집합으로 매칭을 세분화할 수 있습니다.

`/endpoint` 엔드포인트를 매칭하는 대신 `/resource` 디렉토리 아래의 모든 엔드포인트를 매칭하고 싶다고 가정해 봅시다.
이 경우 다음과 같이 할 수 있습니다:

.Ant로 매칭하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers("/resource/**").hasAuthority("USER")
        .anyRequest().authenticated()
    )
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize("/resource/**", hasAuthority("USER"))
        authorize(anyRequest, authenticated)
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<http>
    <intercept-url pattern="/resource/**" access="hasAuthority('USER')"/>
    <intercept-url pattern="/**" access="authenticated"/>
</http>
----
======

이것을 읽는 방법은 "요청이 `/resource` 또는 그 하위 디렉토리인 경우 `USER` 권한을 요구하고, 그렇지 않으면 인증만 요구한다"입니다.

요청에서 경로 값을 추출할 수도 있습니다. 아래 예시를 보세요:

.권한 부여 및 추출
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers("/resource/{name}").access(new WebExpressionAuthorizationManager("#name == authentication.name"))
        .anyRequest().authenticated()
    )
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize("/resource/{name}", WebExpressionAuthorizationManager("#name == authentication.name"))
        authorize(anyRequest, authenticated)
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<http>
    <intercept-url pattern="/resource/{name}" access="#name == authentication.name"/>
    <intercept-url pattern="/**" access="authenticated"/>
</http>
----
======

권한 부여가 완료되면 xref:servlet/test/method.adoc#test-method-withmockuser[Security의 테스트 지원]을 사용하여 다음과 같이 테스트할 수 있습니다:

.디렉토리 권한 부여 테스트
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@WithMockUser(authorities="USER")
@Test
void endpointWhenUserAuthorityThenAuthorized() {
    this.mvc.perform(get("/endpoint/jon"))
        .andExpect(status().isOk());
}

@WithMockUser
@Test
void endpointWhenNotUserAuthorityThenForbidden() {
    this.mvc.perform(get("/endpoint/jon"))
        .andExpect(status().isForbidden());
}

@Test
void anyWhenUnauthenticatedThenUnauthorized() {
    this.mvc.perform(get("/any"))
        .andExpect(status().isUnauthorized());
}
----
======

[NOTE]
Spring Security는 경로만 매칭합니다.
쿼리 파라미터를 매칭하려면 사용자 정의 요청 매처가 필요합니다.

[[match-by-regex]]
=== 정규 표현식을 사용한 매칭
Spring Security는 정규 표현식을 사용한 요청 매칭을 지원합니다.
이는 하위 디렉토리에 ``**``보다 더 엄격한 매칭 기준을 적용하고 싶을 때 유용할 수 있습니다.

예를 들어, 사용자 이름을 포함하는 경로와 모든 사용자 이름이 영숫자여야 한다는 규칙이 있다고 가정해 봅시다.
이 규칙을 준수하기 위해 {security-api-url}org/springframework/security/web/util/matcher/RegexRequestMatcher.html[`RegexRequestMatcher`]를 다음과 같이 사용할 수 있습니다:

.정규 표현식으로 매칭하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers(RegexRequestMatcher.regexMatcher("/resource/[A-Za-z0-9]+")).hasAuthority("USER")
        .anyRequest().denyAll()
    )
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize(RegexRequestMatcher.regexMatcher("/resource/[A-Za-z0-9]+"), hasAuthority("USER"))
        authorize(anyRequest, denyAll)
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<http>
    <intercept-url request-matcher="regex" pattern="/resource/[A-Za-z0-9]+" access="hasAuthority('USER')"/>
    <intercept-url pattern="/**" access="denyAll"/>
</http>
----
======

[[match-by-httpmethod]]
=== HTTP 메소드로 매칭하기

규칙을 HTTP 메소드로도 매칭할 수 있습니다.
이는 `read` 또는 `write` 권한과 같이 부여된 권한으로 권한 부여할 때 유용합니다.

모든 `GET` 요청에 `read` 권한을 요구하고 모든 `POST` 요청에 `write` 권한을 요구하려면 다음과 같이 할 수 있습니다:

.HTTP 메소드로 매칭하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers(HttpMethod.GET).hasAuthority("read")
        .requestMatchers(HttpMethod.POST).hasAuthority("write")
        .anyRequest().denyAll()
    )
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize(HttpMethod.GET, hasAuthority("read"))
        authorize(HttpMethod.POST, hasAuthority("write"))
        authorize(anyRequest, denyAll)
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<http>
    <intercept-url http-method="GET" pattern="/**" access="hasAuthority('read')"/>
    <intercept-url http-method="POST" pattern="/**" access="hasAuthority('write')"/>
    <intercept-url pattern="/**" access="denyAll"/>
</http>
----
======

이러한 권한 부여 규칙은 다음과 같이 읽힙니다: "요청이 GET이면 `read` 권한을 요구하고, POST이면 `write` 권한을 요구하며, 그 외의 경우에는 요청을 거부한다"

[TIP]
기본적으로 요청을 거부하는 것은 규칙 집합을 허용 목록으로 전환하는 건전한 보안 관행입니다.

권한 부여가 완료되면 xref:servlet/test/method.adoc#test-method-withmockuser[Security의 테스트 지원]을 사용하여 다음과 같이 테스트할 수 있습니다:

.HTTP 메소드 권한 부여 테스트
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@WithMockUser(authorities="read")
@Test
void getWhenReadAuthorityThenAuthorized() {
    this.mvc.perform(get("/any"))
        .andExpect(status().isOk());
}

@WithMockUser
@Test
void getWhenNoReadAuthorityThenForbidden() {
    this.mvc.perform(get("/any"))
        .andExpect(status().isForbidden());
}

@WithMockUser(authorities="write")
@Test
void postWhenWriteAuthorityThenAuthorized() {
    this.mvc.perform(post("/any").with(csrf()))
        .andExpect(status().isOk());
}

@WithMockUser(authorities="read")
@Test
void postWhenNoWriteAuthorityThenForbidden() {
    this.mvc.perform(get("/any").with(csrf()))
        .andExpect(status().isForbidden());
}
----
======

[[match-by-dispatcher-type]]
=== 디스패처 타입으로 매칭하기

[NOTE]
이 기능은 현재 XML에서 지원되지 않습니다.

앞서 언급했듯이, Spring Security는 <<_all_dispatches_are_authorized, 기본적으로 모든 디스패처 타입을 권한 부여>>합니다.
그리고 `REQUEST` 디스패치에서 설정된 xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontext[보안 컨텍스트]가 후속 디스패치로 이어지더라도, 미묘한 불일치로 인해 예기치 않은 ``AccessDeniedException``이 발생할 수 있습니다.

이를 해결하기 위해 Spring Security Java 구성에서 ``FORWARD``와 `ERROR` 같은 디스패처 타입을 허용하도록 구성할 수 있습니다:

.디스패처 타입으로 매칭하기
====
.Java
[source,java,role="secondary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.ERROR).permitAll()
        .requestMatchers("/endpoint").permitAll()
        .anyRequest().denyAll()
    )
----

.Kotlin
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize(DispatcherTypeRequestMatcher(DispatcherType.FORWARD), permitAll)
        authorize(DispatcherTypeRequestMatcher(DispatcherType.ERROR), permitAll)
        authorize("/endpoint", permitAll)
        authorize(anyRequest, denyAll)
    }
}
----
====

[[match-by-mvc]]
=== MvcRequestMatcher 사용하기

일반적으로 위에서 보여준 대로 ``requestMatchers(String)``를 사용할 수 있습니다.

그러나 Spring MVC를 다른 서블릿 경로에 매핑한 경우, 보안 구성에서 이를 고려해야 합니다.

예를 들어, Spring MVC가 `/` (기본값) 대신 ``/spring-mvc``에 매핑되어 있다면, ``/spring-mvc/my/controller``와 같은 엔드포인트에 권한 부여를 적용하고 싶을 수 있습니다.

이 경우 ``MvcRequestMatcher``를 사용하여 구성에서 서블릿 경로와 컨트롤러 경로를 분리해야 합니다:

.MvcRequestMatcher로 매칭하기
====
.Java
[source,java,role="primary"]
----
@Bean
MvcRequestMatcher.Builder mvc(HandlerMappingIntrospector introspector) {
	return new MvcRequestMatcher.Builder(introspector).servletPath("/spring-mvc");
}

@Bean
SecurityFilterChain appEndpoints(HttpSecurity http, MvcRequestMatcher.Builder mvc) {
	http
        .authorizeHttpRequests((authorize) -> authorize
            .requestMatchers(mvc.pattern("/my/controller/**")).hasAuthority("controller")
            .anyRequest().authenticated()
        );

	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun mvc(introspector: HandlerMappingIntrospector): MvcRequestMatcher.Builder =
    MvcRequestMatcher.Builder(introspector).servletPath("/spring-mvc");

@Bean
fun appEndpoints(http: HttpSecurity, mvc: MvcRequestMatcher.Builder): SecurityFilterChain =
    http {
        authorizeHttpRequests {
            authorize(mvc.pattern("/my/controller/**"), hasAuthority("controller"))
            authorize(anyRequest, authenticated)
        }
    }
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-url servlet-path="/spring-mvc" pattern="/my/controller/**" access="hasAuthority('controller')"/>
    <intercept-url pattern="/**" access="authenticated"/>
</http>
----
====

이런 필요성은 적어도 두 가지 경우에 발생할 수 있습니다:

* `spring.mvc.servlet.path` Boot 속성을 사용하여 기본 경로(`/`)를 다른 것으로 변경한 경우
* 둘 이상의 Spring MVC ``DispatcherServlet``을 등록한 경우 (따라서 그 중 하나는 기본 경로가 아니어야 함)

[[match-by-custom]]
=== 사용자 정의 매처 사용하기

[NOTE]
이 기능은 현재 XML에서 지원되지 않습니다.

Java 구성에서는 자체 {security-api-url}org/springframework/security/web/util/matcher/RequestMatcher.html[`RequestMatcher`]를 생성하고 DSL에 제공할 수 있습니다:

.디스패처 타입으로 권한 부여하기
====
.Java
[source,java,role="secondary"]
----
RequestMatcher printview = (request) -> request.getParameter("print") != null;
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers(printview).hasAuthority("print")
        .anyRequest().authenticated()
    )
----

.Kotlin
[source,kotlin,role="secondary"]
----
val printview: RequestMatcher = { (request) -> request.getParameter("print") != null }
http {
    authorizeHttpRequests {
        authorize(printview, hasAuthority("print"))
        authorize(anyRequest, authenticated)
    }
}
----
====

[TIP]
{security-api-url}org/springframework/security/web/util/matcher/RequestMatcher.html[`RequestMatcher`]는 함수형 인터페이스이므로 DSL에서 람다로 제공할 수 있습니다.
그러나 요청에서 값을 추출하려면 ``default`` 메서드를 오버라이드해야 하므로 구체적인 클래스가 필요합니다.

권한 부여가 완료되면 xref:servlet/test/method.adoc#test-method-withmockuser[Security의 테스트 지원]을 사용하여 다음과 같이 테스트할 수 있습니다:

.사용자 정의 권한 부여 테스트
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@WithMockUser(authorities="print")
@Test
void printWhenPrintAuthorityThenAuthorized() {
    this.mvc.perform(get("/any?print"))
        .andExpect(status().isOk());
}

@WithMockUser
@Test
void printWhenNoPrintAuthorityThenForbidden() {
    this.mvc.perform(get("/any?print"))
        .andExpect(status().isForbidden());
}
----
======

[[authorize-requests]]
== 요청 권한 부여하기

요청이 매칭되면 <<match-requests, 이미 본>> `permitAll`, `denyAll`, ``hasAuthority``와 같은 여러 가지 방법으로 권한 부여할 수 있습니다.

간단히 요약하면, DSL에 내장된 권한 부여 규칙은 다음과 같습니다:

* `permitAll` - 요청에 권한 부여가 필요 없으며 공개 엔드포인트입니다. 이 경우 xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`]은 세션에서 절대 검색되지 않습니다.
* `denyAll` - 어떤 상황에서도 요청이 허용되지 않습니다. 이 경우에도 ``Authentication``은 세션에서 절대 검색되지 않습니다.
* `hasAuthority` - 요청은 ``Authentication``이 주어진 값과 일치하는 xref:servlet/authorization/architecture.adoc#authz-authorities[`GrantedAuthority`]를 가지고 있어야 합니다.
* `hasRole` - `ROLE_` 접두사나 구성된 기본 접두사를 붙이는 ``hasAuthority``의 단축 버전입니다.
* `hasAnyAuthority` - 요청은 ``Authentication``이 주어진 값들 중 하나와 일치하는 ``GrantedAuthority``를 가지고 있어야 합니다.
* `hasAnyRole` - `ROLE_` 접두사나 구성된 기본 접두사를 붙이는 ``hasAnyAuthority``의 단축 버전입니다.
* `access` - 요청은 이 사용자 정의 ``AuthorizationManager``를 사용하여 접근을 결정합니다.

이제 패턴, 규칙, 그리고 이들을 어떻게 짝지을 수 있는지 배웠으므로, 다음과 같은 더 복잡한 예제를 이해할 수 있을 것입니다:

.요청 권한 부여하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
import static jakarta.servlet.DispatcherType.*;

import static org.springframework.security.authorization.AuthorizationManagers.allOf;
import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasAuthority;
import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole;

@Bean
SecurityFilterChain web(HttpSecurity http) throws Exception {
	http
		// ...
		.authorizeHttpRequests(authorize -> authorize                                  // <1>
            .dispatcherTypeMatchers(FORWARD, ERROR).permitAll() // <2>
			.requestMatchers("/static/**", "/signup", "/about").permitAll()         // <3>
			.requestMatchers("/admin/**").hasRole("ADMIN")                             // <4>
			.requestMatchers("/db/**").access(allOf(hasAuthority("db"), hasRole("ADMIN")))   // <5>
			.anyRequest().denyAll()                                                // <6>
		);

	return http.build();
}
----
======
<1> 여러 권한 부여 규칙이 지정되어 있습니다.
각 규칙은 선언된 순서대로 고려됩니다.
<2> ``FORWARD``와 ``ERROR`` 디스패치는 {spring-framework-reference-url}web.html#spring-web[Spring MVC]가 뷰를 렌더링하고 Spring Boot가 오류를 렌더링할 수 있도록 허용됩니다.
<3> 모든 사용자가 접근할 수 있는 여러 URL 패턴을 지정했습니다.
구체적으로, URL이 "/static/"로 시작하거나, "/signup"이거나, "/about"인 경우 모든 사용자가 접근할 수 있습니다.
<4> "/admin/"로 시작하는 모든 URL은 "ROLE_ADMIN" 역할을 가진 사용자로 제한됩니다.
``hasRole`` 메서드를 호출하므로 "ROLE_" 접두사를 지정할 필요가 없습니다.
<5> "/db/"로 시작하는 모든 URL은 사용자가 "db" 권한과 "ROLE_ADMIN" 역할을 모두 가지고 있어야 합니다.
``hasRole`` 표현식을 사용하므로 "ROLE_" 접두사를 지정할 필요가 없습니다.
<6> 이미 매칭되지 않은 모든 URL에 대한 접근이 거부됩니다.
이는 실수로 권한 부여 규칙 업데이트를 잊지 않도록 하는 좋은 전략입니다.

[[authorization-expressions]]
== SpEL로 권한 부여 표현하기

구체적인 ``AuthorizationManager``를 사용하는 것이 권장되지만, `<intercept-url>` 또는 JSP Taglib와 같이 표현식이 필요한 경우가 있습니다.
이러한 이유로 이 섹션에서는 그러한 영역의 예제에 초점을 맞출 것입니다.

그러면 Spring Security의 웹 보안 권한 부여 SpEL API를 좀 더 자세히 살펴보겠습니다.

Spring Security는 모든 권한 부여 필드와 메서드를 루트 객체 세트에 캡슐화합니다.
가장 일반적인 루트 객체는 ``SecurityExpressionRoot``라고 하며 ``WebSecurityExpressionRoot``의 기초를 형성합니다.
Spring Security는 권한 부여 표현식을 평가할 준비를 할 때 ``StandardEvaluationContext``에 이 루트 객체를 제공합니다.

[[using-authorization-expression-fields-and-methods]]
=== 권한 부여 표현식 필드 및 메서드 사용하기

이는 SpEL 표현식에 향상된 권한 부여 필드와 메서드 세트를 제공합니다.
다음은 가장 일반적인 메서드에 대한 간단한 개요입니다:

* `permitAll` - 요청을 호출하는 데 권한 부여가 필요 없습니다. 이 경우 xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`]은 세션에서 절대 검색되지 않습니다.
* `denyAll` - 어떤 상황에서도 요청이 허용되지 않습니다. 이 경우에도 ``Authentication``은 세션에서 절대 검색되지 않습니다.
* `hasAuthority` - 요청은 ``Authentication``이 주어진 값과 일치하는 xref:servlet/authorization/architecture.adoc#authz-authorities[`GrantedAuthority`]를 가지고 있어야 합니다.
* `hasRole` - `ROLE_` 접두사나 구성된 기본 접두사를 붙이는 ``hasAuthority``의 단축 버전입니다.
* `hasAnyAuthority` - 요청은 ``Authentication``이 주어진 값들 중 하나와 일치하는 ``GrantedAuthority``를 가지고 있어야 합니다.
* `hasAnyRole` - `ROLE_` 접두사나 구성된 기본 접두사를 붙이는 ``hasAnyAuthority``의 단축 버전입니다.
* `hasPermission` - 객체 수준 권한 부여를 위한 ``PermissionEvaluator`` 인스턴스에 대한 연결 지점입니다.

그리고 가장 일반적인 필드에 대한 간단한 살펴보기입니다:

* `authentication` - 이 메서드 호출과 관련된 `Authentication` 인스턴스
* `principal` - 이 메서드 호출과 관련된 `Authentication#getPrincipal`

이제 패턴, 규칙, 그리고 이들을 어떻게 짝지을 수 있는지 배웠으므로, 다음과 같은 더 복잡한 예제에서 무슨 일이 일어나는지 이해할 수 있을 것입니다:

.SpEL을 사용한 요청 권한 부여
[tabs]
======
Xml::
+
[source,java,role="primary"]
----
<http>
    <intercept-url pattern="/static/**" access="permitAll"/> <1>
    <intercept-url pattern="/admin/**" access="hasRole('ADMIN')"/> <2>
    <intercept-url pattern="/db/**" access="hasAuthority('db') and hasRole('ADMIN')"/> <3>
    <intercept-url pattern="/**" access="denyAll"/> <4>
</http>
----
======
<1> 모든 사용자가 접근할 수 있는 URL 패턴을 지정했습니다.
구체적으로, URL이 "/static/"로 시작하는 경우 모든 사용자가 접근할 수 있습니다.
<2> "/admin/"로 시작하는 모든 URL은 "ROLE_ADMIN" 역할을 가진 사용자로 제한됩니다.
`hasRole` 메서드를 호출하므로 "ROLE_" 접두사를 지정할 필요가 없습니다.
<3> "/db/"로 시작하는 모든 URL은 사용자가 "db" 권한과 "ROLE_ADMIN" 역할을 모두 가지고 있어야 합니다.
`hasRole` 표현식을 사용하므로 "ROLE_" 접두사를 지정할 필요가 없습니다.
<4> 이미 매칭되지 않은 모든 URL에 대한 접근이 거부됩니다.
이는 실수로 권한 부여 규칙 업데이트를 잊지 않도록 하는 좋은 전략입니다.

[[using_path_parameters]]
=== 경로 매개변수 사용하기

또한 Spring Security는 경로 매개변수를 발견하여 SpEL 표현식에서도 접근할 수 있는 메커니즘을 제공합니다.

예를 들어, SpEL 표현식에서 다음과 같은 방식으로 경로 매개변수에 접근할 수 있습니다:

.SpEL 경로 변수를 사용한 요청 권한 부여
[tabs]
======
Xml::
+
[source,xml,role="primary"]
----
<http>
    <intercept-url pattern="/resource/{name}" access="#name == authentication.name"/>
    <intercept-url pattern="/**" access="authenticated"/>
</http>
----
======

이 표현식은 `/resource/` 뒤의 경로 변수를 참조하며 이것이 ``Authentication#getName``과 같아야 한다고 요구합니다.

[[remote-authorization-manager]]
=== 권한 부여 데이터베이스, 정책 에이전트 또는 기타 서비스 사용하기
권한 부여를 위해 별도의 서비스를 사용하도록 Spring Security를 구성하려면 자체 ``AuthorizationManager``를 만들고 이를 ``anyRequest``와 매칭할 수 있습니다.

먼저, ``AuthorizationManager``는 다음과 같을 수 있습니다:

.Open Policy Agent 권한 부여 관리자
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public final class OpenPolicyAgentAuthorizationManager implements AuthorizationManager<RequestAuthorizationContext> {
    @Override
    public AuthorizationDecision check(Supplier<Authentication> authentication, RequestAuthorizationContext context) {
        // Open Policy Agent에 요청
    }
}
----
======

그런 다음 다음과 같은 방식으로 Spring Security에 연결할 수 있습니다:

.모든 요청을 원격 서비스로 전송
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityFilterChain web(HttpSecurity http, AuthorizationManager<RequestAuthorizationContext> authz) throws Exception {
	http
		// ...
		.authorizeHttpRequests((authorize) -> authorize
            .anyRequest().access(authz)
		);

	return http.build();
}
----
======

[[favor-permitall]]
=== ``ignoring`` 대신 ``permitAll`` 선호하기
정적 리소스가 있을 때 필터 체인이 이러한 값들을 무시하도록 구성하고 싶을 수 있습니다.
더 안전한 접근 방식은 다음과 같이 ``permitAll``을 사용하는 것입니다:

.정적 리소스 허용
====
.Java
[source,java,role="secondary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers("/css/**").permitAll()
        .anyRequest().authenticated()
    )
----

.Kotlin
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize("/css/**", permitAll)
        authorize(anyRequest, authenticated)
    }
}
----
====

이 방법이 더 안전한 이유는 정적 리소스에서도 안전한 헤더를 작성하는 것이 중요하기 때문입니다. 요청이 무시되면 Spring Security가 이를 수행할 수 없습니다.

과거에는 Spring Security가 모든 요청에서 세션을 확인해야 했기 때문에 성능 트레이드오프가 있었습니다.
그러나 Spring Security 6부터는 권한 부여 규칙에 필요한 경우가 아니면 더 이상 세션을 확인하지 않습니다.
이제 성능 문제가 해결되었으므로 Spring Security는 모든 요청에 대해 최소한 ``permitAll``을 사용할 것을 권장합니다.

[[migrate-authorize-requests]]
== ``authorizeRequests``에서 마이그레이션하기

[NOTE]
``AuthorizationFilter``는 {security-api-url}org/springframework/security/web/access/intercept/FilterSecurityInterceptor.html[`FilterSecurityInterceptor`]를 대체합니다.
이전 버전과의 호환성을 유지하기 위해 ``FilterSecurityInterceptor``가 기본값으로 남아 있습니다.
이 섹션에서는 ``AuthorizationFilter``가 어떻게 작동하는지와 기본 구성을 어떻게 재정의할 수 있는지 설명합니다.

{security-api-url}org/springframework/security/web/access/intercept/AuthorizationFilter.html[`AuthorizationFilter`]는 ``HttpServletRequest``에 대한 xref:servlet/authorization/index.adoc#servlet-authorization[권한 부여]를 제공합니다.
이는 xref:servlet/architecture.adoc#servlet-filterchainproxy[FilterChainProxy]에 xref:servlet/architecture.adoc#servlet-security-filters[보안 필터] 중 하나로 삽입됩니다.

``SecurityFilterChain``을 선언할 때 기본값을 재정의할 수 있습니다.
{security-api-url}org/springframework/security/config/annotation/web/builders/HttpSecurity.html#authorizeRequests()[`authorizeRequests`] 대신 ``authorizeHttpRequests``를 사용하세요:

.authorizeHttpRequests 사용하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
SecurityFilterChain web(HttpSecurity http) throws AuthenticationException {
    http
        .authorizeHttpRequests((authorize) -> authorize
            .anyRequest().authenticated();
        )
        // ...

    return http.build();
}
----
======

이는 ``authorizeRequests``를 여러 가지 면에서 개선합니다:

1. 메타데이터 소스, 구성 속성, 결정 관리자 및 투표자 대신 단순화된 ``AuthorizationManager`` API를 사용합니다.
이는 재사용과 사용자 정의를 단순화합니다.
2. ``Authentication`` 조회를 지연시킵니다.
모든 요청에 대해 인증을 조회하는 대신, 권한 부여 결정에 인증이 필요한 요청에서만 조회합니다.
3. Bean 기반 구성 지원.

``authorizeHttpRequests``가 ``authorizeRequests`` 대신 사용되면 {security-api-url}org/springframework/security/web/access/intercept/AuthorizationFilter.html[`AuthorizationFilter`]가 {security-api-url}org/springframework/security/web/access/intercept/FilterSecurityInterceptor.html[`FilterSecurityInterceptor`] 대신 사용됩니다.

=== 표현식 마이그레이션

가능한 경우 SpEL 대신 타입 안전한 권한 부여 관리자를 사용하는 것이 권장됩니다.
Java 구성의 경우, {security-api-url}org/springframework/security/web/access/expression/WebExpressionAuthorizationManager.html[`WebExpressionAuthorizationManager`]를 사용하여 레거시 SpEL을 마이그레이션하는 데 도움을 받을 수 있습니다.

``WebExpressionAuthorizationManager``를 사용하려면 마이그레이션하려는 표현식으로 하나를 구성할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
.requestMatchers("/test/**").access(new WebExpressionAuthorizationManager("hasRole('ADMIN') && hasRole('USER')"))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
.requestMatchers("/test/**").access(WebExpressionAuthorizationManager("hasRole('ADMIN') && hasRole('USER')"))
----
======

표현식에서 ``@webSecurity.check(authentication, request)``와 같이 빈을 참조하는 경우, 대신 빈을 직접 호출하는 것이 좋습니다. 이는 다음과 같이 보일 것입니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
.requestMatchers("/test/**").access((authentication, context) ->
    new AuthorizationDecision(webSecurity.check(authentication.get(), context.getRequest())))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
.requestMatchers("/test/**").access((authentication, context): AuthorizationManager<RequestAuthorizationContext> ->
    AuthorizationDecision(webSecurity.check(authentication.get(), context.getRequest())))
----
======

빈 참조와 다른 표현식을 포함하는 복잡한 지시사항의 경우, ``AuthorizationManager``를 구현하고 ``.access(AuthorizationManager)``를 호출하여 참조하는 것이 좋습니다.

그렇게 할 수 없는 경우, 빈 리졸버로 {security-api-url}org/springframework/security/web/access/expression/DefaultHttpSecurityExpressionHandler.html[``DefaultHttpSecurityExpressionHandler``]를 구성하고 이를 ``WebExpressionAuthorizationManager#setExpressionhandler``에 제공할 수 있습니다.

[[security-matchers]]
== 보안 매처

{security-api-url}org/springframework/security/web/util/matcher/RequestMatcher.html[`RequestMatcher`] 인터페이스는 요청이 주어진 규칙과 일치하는지 여부를 결정하는 데 사용됩니다.
우리는 ``securityMatchers``를 사용하여 xref:servlet/configuration/java.adoc#jc-httpsecurity[주어진 `HttpSecurity`]가 주어진 요청에 적용되어야 하는지 결정합니다.
같은 방식으로 ``requestMatchers``를 사용하여 주어진 요청에 적용해야 하는 권한 부여 규칙을 결정할 수 있습니다.
다음 예를 살펴보세요:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			.securityMatcher("/api/**")                            <1>
			.authorizeHttpRequests(authorize -> authorize
				.requestMatchers("/user/**").hasRole("USER")       <2>
				.requestMatchers("/admin/**").hasRole("ADMIN")     <3>
				.anyRequest().authenticated()                      <4>
			)
			.formLogin(withDefaults());
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
open class SecurityConfig {

    @Bean
    open fun web(http: HttpSecurity): SecurityFilterChain {
        http {
            securityMatcher("/api/**")                                           <1>
            authorizeHttpRequests {
                authorize("/user/**", hasRole("USER"))                           <2>
                authorize("/admin/**", hasRole("ADMIN"))                         <3>
                authorize(anyRequest, authenticated)                             <4>
            }
        }
        return http.build()
    }

}
----
======

<1> ``/api/``로 시작하는 URL에만 적용되도록 `HttpSecurity` 구성
<2> ``/user/``로 시작하는 URL에 대한 접근을 `USER` 역할을 가진 사용자에게 허용
<3> ``/admin/``으로 시작하는 URL에 대한 접근을 `ADMIN` 역할을 가진 사용자에게 허용
<4> 위의 규칙과 일치하지 않는 다른 모든 요청은 인증이 필요함

``securityMatcher(s)``와 ``requestMatcher(s)`` 메서드는 애플리케이션에 가장 적합한 `RequestMatcher` 구현을 결정합니다: {spring-framework-reference-url}web.html#spring-web[Spring MVC]가 클래스패스에 있으면 {security-api-url}org/springframework/security/web/servlet/util/matcher/MvcRequestMatcher.html[`MvcRequestMatcher`]가 사용되고, 그렇지 않으면 {security-api-url}org/springframework/security/web/servlet/util/matcher/AntPathRequestMatcher.html[`AntPathRequestMatcher`]가 사용됩니다.
Spring MVC 통합에 대해 xref:servlet/integrations/mvc.adoc[여기]에서 더 자세히 읽을 수 있습니다.

특정 ``RequestMatcher``를 사용하려면 ``securityMatcher`` 및/또는 ``requestMatcher`` 메서드에 구현체를 전달하면 됩니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
import static org.springframework.security.web.util.matcher.AntPathRequestMatcher.antMatcher; <1>
import static org.springframework.security.web.util.matcher.RegexRequestMatcher.regexMatcher;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		http
			.securityMatcher(antMatcher("/api/**"))                              <2>
			.authorizeHttpRequests(authorize -> authorize
				.requestMatchers(antMatcher("/user/**")).hasRole("USER")         <3>
				.requestMatchers(regexMatcher("/admin/.*")).hasRole("ADMIN")     <4>
				.requestMatchers(new MyCustomRequestMatcher()).hasRole("SUPERVISOR")     <5>
				.anyRequest().authenticated()
			)
			.formLogin(withDefaults());
		return http.build();
	}
}

public class MyCustomRequestMatcher implements RequestMatcher {

    @Override
    public boolean matches(HttpServletRequest request) {
        // ...
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.web.util.matcher.AntPathRequestMatcher.antMatcher <1>
import org.springframework.security.web.util.matcher.RegexRequestMatcher.regexMatcher

@Configuration
@EnableWebSecurity
open class SecurityConfig {

    @Bean
    open fun web(http: HttpSecurity): SecurityFilterChain {
        http {
            securityMatcher(antMatcher("/api/**"))                               <2>
            authorizeHttpRequests {
                authorize(antMatcher("/user/**"), hasRole("USER"))               <3>
                authorize(regexMatcher("/admin/**"), hasRole("ADMIN"))           <4>
                authorize(MyCustomRequestMatcher(), hasRole("SUPERVISOR"))       <5>
                authorize(anyRequest, authenticated)
            }
        }
        return http.build()
    }

}
----
======

<1> ``AntPathRequestMatcher``와 ``RegexRequestMatcher``에서 정적 팩토리 메서드를 가져와 ``RequestMatcher`` 인스턴스를 생성합니다.
<2> ``AntPathRequestMatcher``를 사용하여 ``/api/``로 시작하는 URL에만 적용되도록 ``HttpSecurity`` 구성
<3> ``AntPathRequestMatcher``를 사용하여 ``/user/``로 시작하는 URL에 대한 접근을 `USER` 역할을 가진 사용자에게 허용
<4> ``RegexRequestMatcher``를 사용하여 ``/admin/``으로 시작하는 URL에 대한 접근을 `ADMIN` 역할을 가진 사용자에게 허용
<5> 사용자 정의 ``RequestMatcher``를 사용하여 ``MyCustomRequestMatcher``와 일치하는 URL에 대한 접근을 ``SUPERVISOR`` 역할을 가진 사용자에게 허용

== 추가 읽기

이제 애플리케이션의 요청을 보호했으니 xref:servlet/authorization/method-security.adoc[메서드 보안]을 고려해 보세요.
또한 xref:servlet/test/index.adoc[애플리케이션 테스트]나 Spring Security를 애플리케이션의 다른 측면과 통합하는 방법에 대해 더 읽어볼 수 있습니다. 예를 들어 xref:servlet/integrations/data.adoc[데이터 계층]이나 xref:servlet/integrations/observability.adoc[추적 및 메트릭]과의 통합에 대해 알아볼 수 있습니다.