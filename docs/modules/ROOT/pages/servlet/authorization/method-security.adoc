[[jc-method]]
= 메서드 보안
:figures: servlet/authorization

요청 레벨에서 xref:servlet/authorization/authorize-http-requests.adoc[권한 부여를 설정]하는 것 외에도, Spring Security는 메서드 레벨에서의 설정도 지원합니다.

[[activate-method-security]]
애플리케이션에서 메서드 보안을 활성화하려면 `@Configuration` 클래스에 `@EnableMethodSecurity` 어노테이션을 추가하거나 XML 구성 파일에 ``<method-security>``를 추가하면 됩니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableMethodSecurity
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security/>
----
======

그러면 즉시 Spring 관리 클래스나 메서드에 <<use-preauthorize, `@PreAuthorize`>>, <<use-postauthorize,`@PostAuthorize`>>, <<use-prefilter,`@PreFilter`>>, <<use-postfilter,`@PostFilter`>> 어노테이션을 사용하여 메서드 호출, 입력 매개변수, 반환 값을 권한 부여할 수 있습니다.

[NOTE]
{spring-boot-reference-url}using.html#using.build-systems.starters[Spring Boot Starter Security]는 기본적으로 메서드 레벨 권한 부여를 활성화하지 않습니다.

메서드 보안은 <<use-aspectj, AspectJ 지원>>, <<use-programmatic-authorization,사용자 정의 어노테이션>>, 그리고 여러 구성 포인트를 포함한 다양한 사용 사례를 지원합니다.
다음과 같은 사용 사례에 대해 알아보는 것이 좋습니다:

* <<migration-enableglobalmethodsecurity, ``@EnableGlobalMethodSecurity``에서 마이그레이션>>
* <<method-security-architecture,메서드 보안의 작동 방식>> 이해 및 사용 이유
* <<request-vs-method,요청 레벨과 메서드 레벨 권한 부여 비교>>
* <<use-preauthorize,``@PreAuthorize``>>와 <<use-postauthorize,``@PostAuthorize``>>를 사용한 메서드 권한 부여
* <<fallback-values-authorization-denied,권한 부여가 거부된 경우 대체 값 제공>>
* <<use-prefilter,``@PreFilter``>>와 <<use-postfilter,``@PostFilter``>>를 사용한 메서드 필터링
* <<use-jsr250,JSR-250 어노테이션>>을 사용한 메서드 권한 부여
* <<use-aspectj,AspectJ 표현식>>을 사용한 메서드 권한 부여
* <<weave-aspectj,AspectJ 바이트코드 위빙>>과 통합
* <<changing-the-order,@Transactional 및 기타 AOP 기반 어노테이션과 조정>>
* <<customizing-expression-handling,SpEL 표현식 처리 사용자 정의>>
* <<custom-authorization-managers,사용자 정의 권한 부여 시스템>>과 통합

[[method-security-architecture]]
== 메서드 보안의 작동 방식

Spring Security의 메서드 권한 부여 지원은 다음과 같은 경우에 유용합니다:

* 세분화된 권한 부여 로직 추출. 예를 들어, 메서드 매개변수와 반환 값이 권한 부여 결정에 기여하는 경우
* 서비스 계층에서 보안 강제
* 스타일적으로 `HttpSecurity` 기반 구성보다 어노테이션 기반 구성 선호

그리고 메서드 보안이 {spring-framework-reference-url}core.html#aop-api[Spring AOP]를 사용하여 설계되었기 때문에, 필요에 따라 Spring Security의 기본값을 재정의하기 위해 모든 표현력 있는 기능에 접근할 수 있습니다.

이미 언급했듯이, `@Configuration` 클래스에 ``@EnableMethodSecurity``를 추가하거나 Spring XML 구성 파일에 ``<sec:method-security/>``를 추가하여 시작합니다.

[[use-method-security]]
[NOTE]
====
이 어노테이션과 XML 요소는 각각 ``@EnableGlobalMethodSecurity``와 ``<sec:global-method-security/>``를 대체합니다.
이들은 다음과 같은 개선 사항을 제공합니다:

1. 메타데이터 소스, 구성 속성, 결정 관리자, 투표자 대신 단순화된 `AuthorizationManager` API를 사용합니다.
이는 재사용과 사용자 정의를 단순화합니다.
2. 빈 구성을 직접 사용하며, ``GlobalMethodSecurityConfiguration``을 확장하여 빈을 사용자 정의할 필요가 없습니다.
3. 네이티브 Spring AOP를 사용하여 설계되어 추상화를 제거하고 사용자 정의를 위해 Spring AOP 빌딩 블록을 사용할 수 있습니다.
4. 모호하지 않은 보안 구성을 보장하기 위해 충돌하는 어노테이션을 확인합니다.
5. JSR-250을 준수합니다.
6. 기본적으로 `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, ``@PostFilter``를 활성화합니다.

`@EnableGlobalMethodSecurity` 또는 ``<global-method-security/>``를 사용 중이라면, 이제 이들은 deprecated 되었으므로 마이그레이션을 권장합니다.
====

메서드 권한 부여는 메서드 전과 후의 권한 부여 조합입니다.
다음과 같이 어노테이션이 달린 서비스 빈을 고려해 보세요:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Service
public class MyCustomerService {
    @PreAuthorize("hasAuthority('permission:read')")
    @PostAuthorize("returnObject.owner == authentication.name")
    public Customer readCustomer(String id) { ... }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Service
open class MyCustomerService {
    @PreAuthorize("hasAuthority('permission:read')")
    @PostAuthorize("returnObject.owner == authentication.name")
    fun readCustomer(val id: String): Customer { ... }
}
----
======

메서드 보안이 <<activate-method-security,활성화>>되면 ``MyCustomerService#readCustomer``에 대한 특정 호출은 다음과 같이 보일 수 있습니다:

image::{figures}/methodsecurity.png[]

1. Spring AOP는 ``readCustomer``에 대한 프록시 메서드를 호출합니다. 프록시의 다른 어드바이저 중에서 <<annotation-method-pointcuts,`@PreAuthorize` 포인트컷>>과 일치하는 {security-api-url}org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html[`AuthorizationManagerBeforeMethodInterceptor`]를 호출합니다.
2. 인터셉터는 {security-api-url}org/springframework/security/authorization/method/PreAuthorizeAuthorizationManager.html[`PreAuthorizeAuthorizationManager#check`]를 호출합니다.
3. 권한 부여 관리자는 ``MethodSecurityExpressionHandler``를 사용하여 어노테이션의 <<authorization-expressions,SpEL 표현식>>을 파싱하고 xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Supplier<Authentication>`]과 ``MethodInvocation``을 포함하는 ``MethodSecurityExpressionRoot``에서 해당하는 ``EvaluationContext``를 구성합니다.
4. 인터셉터는 이 컨텍스트를 사용하여 표현식을 평가합니다. 구체적으로, ``Supplier``에서 xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`]을 읽고 xref:servlet/authorization/architecture.adoc#authz-authorities[권한] 컬렉션에 ``permission:read``가 있는지 확인합니다.
5. 평가가 통과되면 Spring AOP는 메서드 호출을 진행합니다.
6. 그렇지 않으면 인터셉터는 ``AuthorizationDeniedEvent``를 발행하고 {security-api-url}org/springframework/security/access/AccessDeniedException.html[`AccessDeniedException`]을 던집니다. 이는 xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`]가 잡아서 응답에 403 상태 코드를 반환합니다.
7. 메서드가 반환된 후, Spring AOP는 <<annotation-method-pointcuts,`@PostAuthorize` 포인트컷>>과 일치하는 {security-api-url}org/springframework/security/authorization/method/AuthorizationManagerAfterMethodInterceptor.html[`AuthorizationManagerAfterMethodInterceptor`]를 호출합니다. 이는 위와 동일하게 작동하지만 {security-api-url}org/springframework/security/authorization/method/PostAuthorizeAuthorizationManager.html[`PostAuthorizeAuthorizationManager`]를 사용합니다.
8. 평가가 통과되면 (이 경우 반환 값이 로그인한 사용자에게 속함) 처리가 정상적으로 계속됩니다.
9. 그렇지 않으면 인터셉터는 ``AuthorizationDeniedEvent``를 발행하고 {security-api-url}org/springframework/security/access/AccessDeniedException.html[`AccessDeniedException`]을 던집니다. 이는 xref:servlet/architecture.adoc#servlet-exceptiontranslationfilter[`ExceptionTranslationFilter`]가 잡아서 응답에 403 상태 코드를 반환합니다.

[NOTE]
메서드가 HTTP 요청의 컨텍스트에서 호출되지 않는 경우, ``AccessDeniedException``을 직접 처리해야 할 가능성이 높습니다.

[[unanimous-based-authorization-decisions]]
=== 여러 어노테이션은 순차적으로 계산됨

위에서 설명한 대로, 메서드 호출에 여러 <<authorizing-with-annotations,메서드 보안 어노테이션>>이 포함된 경우 각각이 한 번에 하나씩 처리됩니다.
이는 집합적으로 "그리고(and)"로 묶여 있다고 생각할 수 있습니다.
다시 말해, 호출이 권한 부여되려면 모든 어노테이션 검사가 권한 부여를 통과해야 합니다.

[[repeated-annotations]]
=== 반복 어노테이션은 지원되지 않음

단, 동일한 메서드에 같은 어노테이션을 반복하는 것은 지원되지 않습니다.
예를 들어, 동일한 메서드에 ``@PreAuthorize``를 두 번 배치할 수 없습니다.

대신 SpEL의 boolean 지원이나 별도의 빈에 위임하는 지원을 사용하세요.

[[annotation-method-pointcuts]]
=== 각 어노테이션에는 자체 포인트컷이 있음

각 어노테이션에는 <<class-or-interface-annotations,메서드와 그 포함 클래스>>에서 시작하여 전체 객체 계층 구조에서 해당 어노테이션이나 <<meta-annotations,메타 어노테이션>> 대응물을 찾는 자체 포인트컷 인스턴스가 있습니다.

이에 대한 세부 사항은 {security-api-url}org/springframework/security/authorization/method/AuthorizationMethodPointcuts.html[`AuthorizationMethodPointcuts`]에서 확인할 수 있습니다.

[[annotation-method-interceptors]]
=== 각 어노테이션에는 자체 메서드 인터셉터가 있음

각 어노테이션에는 전용 메서드 인터셉터가 있습니다.
이는 구성 요소를 더 조립 가능하게 만들기 위함입니다.
예를 들어, 필요한 경우 Spring Security 기본값을 비활성화하고 <<_enabling_certain_annotations,`@PostAuthorize` 메서드 인터셉터만 게시>>할 수 있습니다.

메서드 인터셉터는 다음과 같습니다:

* <<use-preauthorize,`@PreAuthorize`>>의 경우, Spring Security는 {security-api-url}org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html[`AuthorizationManagerBeforeMethodInterceptor#preAuthorize`]를 사용하며, 이는 {security-api-url}org/springframework/security/authorization/method/PreAuthorizeAuthorizationManager.html[`PreAuthorizeAuthorizationManager`]를 사용합니다.
* <<use-postauthorize,`@PostAuthorize`>>의 경우, Spring Security는 {security-api-url}org/springframework/security/authorization/method/AuthorizationManagerAfterMethodInterceptor.html[`AuthorizationManagerBeforeMethodInterceptor#postAuthorize`]를 사용하며, 이는 {security-api-url}org/springframework/security/authorization/method/PostAuthorizeAuthorizationManager.html[`PostAuthorizeAuthorizationManager`]를 사용합니다.
* <<use-prefilter,`@PreFilter`>>의 경우, Spring Security는 {security-api-url}org/springframework/security/authorization/method/PreFilterAuthorizationMethodInterceptor.html[`PreFilterAuthorizationMethodInterceptor`]를 사용합니다.
* <<use-postfilter,`@PostFilter`>>의 경우, Spring Security는 {security-api-url}org/springframework/security/authorization/method/PostFilterAuthorizationMethodInterceptor.html[`PostFilterAuthorizationMethodInterceptor`]를 사용합니다.
* <<use-secured,`@Secured`>>의 경우, Spring Security는 {security-api-url}org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html[`AuthorizationManagerBeforeMethodInterceptor#secured`]를 사용하며, 이는 {security-api-url}org/springframework/security/authorization/method/SecuredAuthorizationManager.html[`SecuredAuthorizationManager`]를 사용합니다.
* JSR-250 어노테이션의 경우, Spring Security는 {security-api-url}org/springframework/security/authorization/method/AuthorizationManagerBeforeMethodInterceptor.html[`AuthorizationManagerBeforeMethodInterceptor#jsr250`]를 사용하며, 이는 {security-api-url}org/springframework/security/authorization/method/Jsr250AuthorizationManager.html[`Jsr250AuthorizationManager`]를 사용합니다.

일반적으로 ``@EnableMethodSecurity``를 추가할 때 Spring Security가 게시하는 인터셉터는 다음과 같습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
static Advisor preAuthorizeMethodInterceptor() {
    return AuthorizationManagerBeforeMethodInterceptor.preAuthorize();
}

@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
static Advisor postAuthorizeMethodInterceptor() {
    return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
}

@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
static Advisor preFilterMethodInterceptor() {
    return AuthorizationManagerBeforeMethodInterceptor.preFilter();
}

@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
static Advisor postFilterMethodInterceptor() {
    return AuthorizationManagerAfterMethodInterceptor.postFilter();
}
----
======

[[favor-granting-authorities]]
=== 복잡한 SpEL 표현식보다 권한 부여를 선호

종종 다음과 같은 복잡한 SpEL 표현식을 도입하고 싶을 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@PreAuthorize("hasAuthority('permission:read') || hasRole('ADMIN')")
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@PreAuthorize("hasAuthority('permission:read') || hasRole('ADMIN')")
----
======

하지만 대신 ``ROLE_ADMIN``을 가진 사용자에게 ``permission:read``를 부여할 수 있습니다.
이를 위한 한 가지 방법은 다음과 같이 ``RoleHierarchy``를 사용하는 것입니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
static RoleHierarchy roleHierarchy() {
    return RoleHierarchyImpl.fromHierarchy("ROLE_ADMIN > permission:read");
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
companion object {
    @Bean
    fun roleHierarchy(): RoleHierarchy {
        return RoleHierarchyImpl.fromHierarchy("ROLE_ADMIN > permission:read")
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<bean id="roleHierarchy"
        class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl" factory-method="fromHierarchy">
    <constructor-arg value="ROLE_ADMIN > permission:read"/>
</bean>
----
======

그런 다음 <<customizing-expression-handling,`MethodSecurityExpressionHandler` 인스턴스에 이를 설정>>합니다.
이렇게 하면 다음과 같이 더 간단한 <<use-preauthorize,`@PreAuthorize`>> 표현식을 사용할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@PreAuthorize("hasAuthority('permission:read')")
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@PreAuthorize("hasAuthority('permission:read')")
----
======

또는 가능한 경우 로그인 시 애플리케이션별 권한 부여 로직을 부여된 권한으로 조정하세요.

[[request-vs-method]]
== 요청 레벨과 메서드 레벨 권한 부여 비교

언제 xref:servlet/authorization/authorize-http-requests.adoc[요청 레벨 권한 부여] 대신 메서드 레벨 권한 부여를 선호해야 할까요?
일부는 취향의 문제이지만, 각각의 장점 목록을 고려하여 결정하는 데 도움을 받을 수 있습니다.

|===
|| *요청 레벨* | *메서드 레벨*
| *권한 부여 유형* | 대략적 | 세부적
| *구성 위치* | 구성 클래스에 선언 | 메서드 선언에 로컬
| *구성 스타일* | DSL | 어노테이션
| *권한 부여 정의* | 프로그래밍 방식 | SpEL
|===

주요 트레이드오프는 권한 부여 규칙을 어디에 두고 싶은지입니다.

[NOTE]
어노테이션 기반 메서드 보안을 사용할 때 어노테이션이 없는 메서드는 보안되지 않는다는 점을 기억하는 것이 중요합니다.
이를 방지하기 위해 xref:servlet/configuration/java.adoc#jc-httpsecurity[`HttpSecurity`] 인스턴스에 xref:servlet/authorization/authorize-http-requests.adoc#activate-request-security[포괄적인 권한 부여 규칙]을 선언하세요.

[[authorizing-with-annotations]]
== 어노테이션을 사용한 권한 부여

Spring Security가 메서드 레벨 권한 부여 지원을 활성화하는 주요 방법은 메서드, 클래스, 인터페이스에 추가할 수 있는 어노테이션을 통해서입니다.

[[use-preauthorize]]
=== ``@PreAuthorize``를 사용한 메서드 호출 권한 부여

<<activate-method-security,메서드 보안이 활성화>>되면 다음과 같이 메서드에 {security-api-url}org/springframework/security/access/prepost/PreAuthorize.html[`@PreAuthorize`] 어노테이션을 달 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@PreAuthorize("hasRole('ADMIN')")
	public Account readAccount(Long id) {
        // ... `Authentication`에 `ROLE_ADMIN` 권한이 있는 경우에만 호출됨
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
open class BankService {
	@PreAuthorize("hasRole('ADMIN')")
	fun readAccount(val id: Long): Account {
        // ... `Authentication`에 `ROLE_ADMIN` 권한이 있는 경우에만 호출됨
	}
}
----
======

이는 제공된 표현식 ``hasRole('ADMIN')``이 통과하는 경우에만 메서드를 호출할 수 있음을 나타냅니다.

그런 다음 xref:servlet/test/method.adoc[클래스를 테스트]하여 권한 부여 규칙을 적용하고 있는지 확인할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
BankService bankService;

@WithMockUser(roles="ADMIN")
@Test
void readAccountWithAdminRoleThenInvokes() {
    Account account = this.bankService.readAccount("12345678");
    // ... 결과를 검증
}

@WithMockUser(roles="WRONG")
@Test
void readAccountWithWrongRoleThenAccessDenied() {
    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(
        () -> this.bankService.readAccount("12345678"));
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@WithMockUser(roles="ADMIN")
@Test
fun readAccountWithAdminRoleThenInvokes() {
    val account: Account = this.bankService.readAccount("12345678")
    // ... 결과를 검증
}

@WithMockUser(roles="WRONG")
@Test
fun readAccountWithWrongRoleThenAccessDenied() {
    assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy {
        this.bankService.readAccount("12345678")
    }
}
----
======

[TIP]
``@PreAuthorize``는 <<meta-annotations, 메타 어노테이션>>이 될 수 있고, <<class-or-interface-annotations,클래스나 인터페이스 레벨>>에서 정의될 수 있으며, <<authorization-expressions, SpEL 권한 부여 표현식>>을 사용할 수 있습니다.

``@PreAuthorize``는 필요한 권한을 선언하는 데 매우 유용하지만, <<using_method_parameters,메서드 매개변수와 관련된 더 복잡한 표현식을 평가>>하는 데도 사용할 수 있습니다.

[[use-postauthorize]]
=== ``@PostAuthorize``를 사용한 메서드 결과 권한 부여

메서드 보안이 활성화되면 다음과 같이 메서드에 {security-api-url}org/springframework/security/access/prepost/PostAuthorize.html[`@PostAuthorize`] 어노테이션을 달 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@PostAuthorize("returnObject.owner == authentication.name")
	public Account readAccount(Long id) {
        // ... `Account`가 로그인한 사용자에게 속한 경우에만 반환됨
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
open class BankService {
	@PostAuthorize("returnObject.owner == authentication.name")
	fun readAccount(val id: Long): Account {
        // ... `Account`가 로그인한 사용자에게 속한 경우에만 반환됨
	}
}
----
======

이는 제공된 표현식 ``returnObject.owner == authentication.name``이 통과하는 경우에만 메서드가 값을 반환할 수 있음을 나타냅니다.
``returnObject``는 반환될 `Account` 객체를 나타냅니다.

그런 다음 xref:servlet/test/method.adoc[클래스를 테스트]하여 권한 부여 규칙을 적용하고 있는지 확인할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
BankService bankService;

@WithMockUser(username="owner")
@Test
void readAccountWhenOwnedThenReturns() {
    Account account = this.bankService.readAccount("12345678");
    // ... 결과를 검증
}

@WithMockUser(username="wrong")
@Test
void readAccountWhenNotOwnedThenAccessDenied() {
    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(
        () -> this.bankService.readAccount("12345678"));
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@WithMockUser(username="owner")
@Test
fun readAccountWhenOwnedThenReturns() {
    val account: Account = this.bankService.readAccount("12345678")
    // ... 결과를 검증
}

@WithMockUser(username="wrong")
@Test
fun readAccountWhenNotOwnedThenAccessDenied() {
    assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy {
        this.bankService.readAccount("12345678")
    }
}
----
======

[TIP]
``@PostAuthorize``는 <<meta-annotations,메타 어노테이션>>이 될 수 있고, <<class-or-interface-annotations,클래스나 인터페이스 레벨>>에서 정의될 수 있으며, <<authorization-expressions, SpEL 권한 부여 표현식>>을 사용할 수 있습니다.

``@PostAuthorize``는 https://cheatsheetseries.owasp.org/cheatsheets/Insecure_Direct_Object_Reference_Prevention_Cheat_Sheet.html[안전하지 않은 직접 객체 참조]를 방어할 때 특히 유용합니다.
실제로 다음과 같이 <<meta-annotations,메타 어노테이션>>으로 정의할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@PostAuthorize("returnObject.owner == authentication.name")
public @interface RequireOwnership {}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Target(ElementType.METHOD, ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@PostAuthorize("returnObject.owner == authentication.name")
annotation class RequireOwnership
----
======

이를 통해 서비스에 다음과 같이 어노테이션을 달 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@RequireOwnership
	public Account readAccount(Long id) {
        // ... `Account`가 로그인한 사용자에게 속한 경우에만 반환됨
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
open class BankService {
	@RequireOwnership
	fun readAccount(val id: Long): Account {
        // ... `Account`가 로그인한 사용자에게 속한 경우에만 반환됨
	}
}
----
======

결과적으로 위 메서드는 ``Account``의 `owner` 속성이 로그인한 사용자의 ``name``과 일치하는 경우에만 ``Account``를 반환합니다.
그렇지 않으면 Spring Security는 ``AccessDeniedException``을 던지고 403 상태 코드를 반환합니다.

[[use-prefilter]]
=== ``@PreFilter``를 사용한 메서드 매개변수 필터링

[NOTE]
``@PreFilter``는 아직 Kotlin 특정 데이터 타입에 대해 지원되지 않습니다. 따라서 Java 스니펫만 표시됩니다.

메서드 보안이 활성화되면 다음과 같이 메서드에 {security-api-url}org/springframework/security/access/prepost/PreFilter.html[`@PreFilter`] 어노테이션을 달 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@PreFilter("filterObject.owner == authentication.name")
	public Collection<Account> updateAccounts(Account... accounts) {
        // ... `accounts`는 로그인한 사용자가 소유한 계좌만 포함합니다
        return updated;
	}
}
----
======

이는 `filterObject.owner == authentication.name` 표현식이 실패하는 ``accounts``의 모든 값을 필터링하기 위한 것입니다.
``filterObject``는 ``accounts``의 각 ``account``를 나타내며 각 ``account``를 테스트하는 데 사용됩니다.

그런 다음 다음과 같이 클래스를 테스트하여 권한 부여 규칙을 적용하고 있는지 확인할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
BankService bankService;

@WithMockUser(username="owner")
@Test
void updateAccountsWhenOwnedThenReturns() {
    Account ownedBy = ...
    Account notOwnedBy = ...
    Collection<Account> updated = this.bankService.updateAccounts(ownedBy, notOwnedBy);
    assertThat(updated).containsOnly(ownedBy);
}
----
======

[TIP]
``@PreFilter``도 <<meta-annotations,메타 어노테이션>>이 될 수 있고, <<class-or-interface-annotations,클래스나 인터페이스 레벨>>에서 정의될 수 있으며, <<authorization-expressions, SpEL 권한 부여 표현식>>을 사용할 수 있습니다.

``@PreFilter``는 배열, 컬렉션, 맵, 스트림(스트림이 여전히 열려있는 한)을 지원합니다.

예를 들어, 위의 ``updateAccounts`` 선언은 다음 네 가지와 동일하게 작동합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@PreFilter("filterObject.owner == authentication.name")
public Collection<Account> updateAccounts(Account[] accounts)

@PreFilter("filterObject.owner == authentication.name")
public Collection<Account> updateAccounts(Collection<Account> accounts)

@PreFilter("filterObject.value.owner == authentication.name")
public Collection<Account> updateAccounts(Map<String, Account> accounts)

@PreFilter("filterObject.owner == authentication.name")
public Collection<Account> updateAccounts(Stream<Account> accounts)
----
======

결과적으로 위 메서드는 `owner` 속성이 로그인한 사용자의 ``name``과 일치하는 `Account` 인스턴스만 가지게 됩니다.

[[use-postfilter]]
=== ``@PostFilter``를 사용한 메서드 결과 필터링

[NOTE]
``@PostFilter``는 아직 Kotlin 특정 데이터 타입에 대해 지원되지 않습니다. 따라서 Java 스니펫만 표시됩니다.

메서드 보안이 활성화되면 다음과 같이 메서드에 {security-api-url}org/springframework/security/access/prepost/PostFilter.html[`@PostFilter`] 어노테이션을 달 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@PostFilter("filterObject.owner == authentication.name")
	public Collection<Account> readAccounts(String... ids) {
        // ... 반환 값은 로그인한 사용자가 소유한 계좌만 포함하도록 필터링됩니다
        return accounts;
	}
}
----
======

이는 `filterObject.owner == authentication.name` 표현식이 실패하는 반환 값의 모든 값을 필터링하기 위한 것입니다.
``filterObject``는 ``accounts``의 각 ``account``를 나타내며 각 ``account``를 테스트하는 데 사용됩니다.

그런 다음 다음과 같이 클래스를 테스트하여 권한 부여 규칙을 적용하고 있는지 확인할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
BankService bankService;

@WithMockUser(username="owner")
@Test
void readAccountsWhenOwnedThenReturns() {
    Collection<Account> accounts = this.bankService.updateAccounts("owner", "not-owner");
    assertThat(accounts).hasSize(1);
    assertThat(accounts.get(0).getOwner()).isEqualTo("owner");
}
----
======

[TIP]
``@PostFilter``도 <<meta-annotations,메타 어노테이션>>이 될 수 있고, <<class-or-interface-annotations,클래스나 인터페이스 레벨>>에서 정의될 수 있으며, <<authorization-expressions, SpEL 권한 부여 표현식>>을 사용할 수 있습니다.

``@PostFilter``는 배열, 컬렉션, 맵, 스트림(스트림이 여전히 열려있는 한)을 지원합니다.

예를 들어, 위의 `readAccounts` 선언은 다음 세 가지와 동일하게 작동합니다:

```java
@PostFilter("filterObject.owner == authentication.name")
public Account[] readAccounts(String... ids)

@PostFilter("filterObject.value.owner == authentication.name")
public Map<String, Account> readAccounts(String... ids)

@PostFilter("filterObject.owner == authentication.name")
public Stream<Account> readAccounts(String... ids)
```

결과적으로 위 메서드는 `owner` 속성이 로그인한 사용자의 ``name``과 일치하는 `Account` 인스턴스를 반환합니다.

[NOTE]
메모리 내 필터링은 분명히 비용이 많이 들 수 있으므로 xref:servlet/integrations/data.adoc[데이터 계층에서 데이터를 필터링]하는 것이 더 나은지 고려해야 합니다.

[[use-secured]]
=== ``@Secured``를 사용한 메서드 호출 권한 부여

{security-api-url}org/springframework/security/access/annotation/Secured.html[`@Secured`]는 호출을 권한 부여하기 위한 레거시 옵션입니다.
<<use-preauthorize,`@PreAuthorize`>>가 이를 대체하며 권장됩니다.

`@Secured` 어노테이션을 사용하려면 먼저 다음과 같이 메서드 보안 선언을 변경하여 활성화해야 합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableMethodSecurity(securedEnabled = true)
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity(securedEnabled = true)
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security secured-enabled="true"/>
----
======

이렇게 하면 Spring Security가 ``@Secured``로 어노테이션이 달린 메서드, 클래스, 인터페이스를 권한 부여하는 <<annotation-method-interceptors,해당 메서드 인터셉터>>를 게시합니다.

[[use-jsr250]]
=== JSR-250 어노테이션을 사용한 메서드 호출 권한 부여

https://jcp.org/en/jsr/detail?id=250[JSR-250] 어노테이션을 사용하고 싶은 경우 Spring Security도 이를 지원합니다.
<<use-preauthorize,`@PreAuthorize`>>가 더 강력한 표현력을 가지고 있어 권장됩니다.

JSR-250 어노테이션을 사용하려면 먼저 다음과 같이 메서드 보안 선언을 변경하여 활성화해야 합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableMethodSecurity(jsr250Enabled = true)
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity(jsr250Enabled = true)
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security jsr250-enabled="true"/>
----
======

이렇게 하면 Spring Security가 `@RolesAllowed`, `@PermitAll`, ``@DenyAll``로 어노테이션이 달린 메서드, 클래스, 인터페이스를 권한 부여하는 <<annotation-method-interceptors,해당 메서드 인터셉터>>를 게시합니다.

[[class-or-interface-annotations]]
=== 클래스나 인터페이스 레벨에서 어노테이션 선언

메서드 보안 어노테이션을 클래스와 인터페이스 레벨에서 사용하는 것도 지원됩니다.

클래스 레벨에서 다음과 같이 사용하면:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
@PreAuthorize("hasAuthority('ROLE_USER')")
public class MyController {
    @GetMapping("/endpoint")
    public String endpoint() { ... }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
@PreAuthorize("hasAuthority('ROLE_USER')")
open class MyController {
    @GetMapping("/endpoint")
    fun endpoint(): String { ... }
}
----
======

모든 메서드가 클래스 레벨의 동작을 상속받습니다.

또는 클래스와 메서드 레벨 모두에서 다음과 같이 선언된 경우:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
@PreAuthorize("hasAuthority('ROLE_USER')")
public class MyController {
    @GetMapping("/endpoint")
    @PreAuthorize("hasAuthority('ROLE_ADMIN')")
    public String endpoint() { ... }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
@PreAuthorize("hasAuthority('ROLE_USER')")
open class MyController {
    @GetMapping("/endpoint")
    @PreAuthorize("hasAuthority('ROLE_ADMIN')")
    fun endpoint(): String { ... }
}
----
======

어노테이션을 선언하는 메서드는 클래스 레벨 어노테이션을 재정의합니다.

인터페이스에도 동일한 원칙이 적용되지만, 클래스가 두 개의 다른 인터페이스에서 어노테이션을 상속받는 경우 시작이 실패합니다.
이는 Spring Security가 어떤 것을 사용해야 할지 알 수 없기 때문입니다.

이런 경우에는 구체적인 메서드에 어노테이션을 추가하여 모호성을 해결할 수 있습니다.

[[meta-annotations]]
=== 메타 어노테이션 사용

메서드 보안은 메타 어노테이션을 지원합니다.
이는 애플리케이션별 사용 사례에 따라 가독성을 향상시키기 위해 모든 어노테이션을 사용할 수 있다는 의미입니다.

예를 들어, ``@PreAuthorize("hasRole('ADMIN')")``을 다음과 같이 ``@IsAdmin``으로 단순화할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasRole('ADMIN')")
public @interface IsAdmin {}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Target(ElementType.METHOD, ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasRole('ADMIN')")
annotation class IsAdmin
----
======

그 결과 보안이 적용된 메서드에서 이제 다음과 같이 할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@IsAdmin
	public Account readAccount(Long id) {
        // ... 로그인한 사용자에게 `Account`가 속한 경우에만 반환됨
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
open class BankService {
	@IsAdmin
	fun readAccount(val id: Long): Account {
        // ... 로그인한 사용자에게 `Account`가 속한 경우에만 반환됨
	}
}
----
======

이렇게 하면 메서드 정의의 가독성이 향상됩니다.

==== 메타 어노테이션 표현식 템플릿 사용

메타 어노테이션 템플릿을 사용할 수도 있습니다. 이를 통해 더욱 강력한 어노테이션 정의가 가능합니다.

먼저 다음 빈을 게시합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
static PrePostTemplateDefaults prePostTemplateDefaults() {
	return new PrePostTemplateDefaults();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
companion object {
    @Bean
    fun prePostTemplateDefaults(): PrePostTemplateDefaults {
        return PrePostTemplateDefaults()
    }
}
----
======

이제 `@IsAdmin` 대신 다음과 같이 더 강력한 ``@HasRole``을 만들 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasRole('{value}')")
public @interface HasRole {
	String value();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Target(ElementType.METHOD, ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasRole('{value}')")
annotation class HasRole(val value: String)
----
======

그 결과 보안이 적용된 메서드에서 이제 다음과 같이 할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@HasRole("ADMIN")
	public Account readAccount(Long id) {
        // ... 로그인한 사용자에게 `Account`가 속한 경우에만 반환됨
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
open class BankService {
	@HasRole("ADMIN")
	fun readAccount(val id: Long): Account {
        // ... 로그인한 사용자에게 `Account`가 속한 경우에만 반환됨
	}
}
----
======

이는 메서드 변수와 모든 어노테이션 유형에서도 작동하지만, 결과 SpEL 표현식이 올바르도록 인용 부호를 주의 깊게 처리해야 합니다.

예를 들어, 다음과 같은 `@HasAnyRole` 어노테이션을 고려해보세요:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasAnyRole({roles})")
public @interface HasAnyRole {
	String[] roles();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Target(ElementType.METHOD, ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("hasAnyRole({roles})")
annotation class HasAnyRole(val roles: Array<String>)
----
======

이 경우, 표현식에서 따옴표를 사용하지 않고 대신 매개변수 값에 다음과 같이 따옴표를 사용해야 합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class BankService {
	@HasAnyRole(roles = { "'USER'", "'ADMIN'" })
	public Account readAccount(Long id) {
        // ... 로그인한 사용자에게 `Account`가 속한 경우에만 반환됨
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
open class BankService {
	@HasAnyRole(roles = arrayOf("'USER'", "'ADMIN'"))
	fun readAccount(val id: Long): Account {
        // ... 로그인한 사용자에게 `Account`가 속한 경우에만 반환됨
	}
}
----
======

이렇게 하면 대체된 후 표현식이 ``@PreAuthorize("hasAnyRole('USER', 'ADMIN')")``가 됩니다.

[[enable-annotation]]
=== 특정 어노테이션 활성화하기

``@EnableMethodSecurity``의 사전 구성을 끄고 자체 구성으로 대체할 수 있습니다.
<<custom-authorization-managers,`AuthorizationManager`>>나 ``Pointcut``을 커스터마이즈하려는 경우 이렇게 할 수 있습니다.
또는 단순히 ``@PostAuthorize``와 같은 특정 어노테이션만 활성화하려고 할 수 있습니다.

다음과 같은 방식으로 이를 수행할 수 있습니다:

.@PostAuthorize만 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postAuthorize() {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postAuthorize() : Advisor {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize()
	}
}
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security pre-post-enabled="false"/>

<aop:config/>

<bean id="postAuthorize"
	class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
	factory-method="postAuthorize"/>
----
======

위 스니펫은 먼저 Method Security의 사전 구성을 비활성화한 다음 <<annotation-method-interceptors, `@PostAuthorize` 인터셉터>>를 직접 게시함으로써 이를 달성합니다.

[[use-intercept-methods]]
== ``<intercept-methods>``를 사용한 권한 부여

메서드 보안을 위해 Spring Security의 <<authorizing-with-annotations,어노테이션 기반 지원>>을 사용하는 것이 선호되지만, XML을 사용하여 빈 권한 부여 규칙을 선언할 수도 있습니다.

XML 구성에서 선언해야 하는 경우, xref:servlet/appendix/namespace/method-security.adoc#nsa-intercept-methods[`<intercept-methods>`]를 다음과 같이 사용할 수 있습니다:

[tabs]
======
Xml::
+
[source,xml,role="primary"]
----
<bean class="org.mycompany.MyController">
    <intercept-methods>
        <protect method="get*" access="hasAuthority('read')"/>
        <protect method="*" access="hasAuthority('write')"/>
    </intercept-methods>
</bean>
----
======

[NOTE]
이는 접두사나 이름으로만 메서드를 일치시키는 것을 지원합니다.
더 복잡한 요구사항이 있다면, <<authorizing-with-annotations,어노테이션 지원을 사용>>하세요.

[[use-programmatic-authorization]]
== 프로그래밍 방식으로 메서드 권한 부여

이미 보셨듯이, <<authorization-expressions, 메서드 보안 SpEL 표현식>>을 사용하여 복잡한 권한 부여 규칙을 지정하는 여러 방법이 있습니다.

대신 논리를 Java 기반으로 만들 수 있는 여러 방법이 있습니다.
이를 통해 향상된 테스트 가능성과 흐름 제어를 위해 전체 Java 언어에 접근할 수 있습니다.

=== SpEL에서 사용자 정의 빈 사용

메서드를 프로그래밍 방식으로 권한 부여하는 첫 번째 방법은 두 단계 과정입니다.

먼저 `MethodSecurityExpressionOperations` 인스턴스를 받는 메서드가 있는 빈을 다음과 같이 선언합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component("authz")
public class AuthorizationLogic {
    public boolean decide(MethodSecurityExpressionOperations operations) {
        // ... 권한 부여 로직
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component("authz")
open class AuthorizationLogic {
    fun decide(val operations: MethodSecurityExpressionOperations): boolean {
        // ... 권한 부여 로직
    }
}
----
======

그런 다음 어노테이션에서 다음과 같이 해당 빈을 참조합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Controller
public class MyController {
    @PreAuthorize("@authz.decide(#root)")
    @GetMapping("/endpoint")
    public String endpoint() {
        // ...
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Controller
open class MyController {
    @PreAuthorize("@authz.decide(#root)")
    @GetMapping("/endpoint")
    fun String endpoint() {
        // ...
    }
}
----
======

Spring Security는 각 메서드 호출에 대해 해당 빈의 주어진 메서드를 호출합니다.

이 방식의 좋은 점은 모든 권한 부여 로직이 독립적으로 단위 테스트하고 정확성을 확인할 수 있는 별도의 클래스에 있다는 것입니다.
또한 전체 Java 언어에 접근할 수 있습니다.

[TIP]
``Boolean``을 반환하는 것 외에도 ``null``을 반환하여 결정을 내리지 않겠다고 표시할 수 있습니다.

권한 부여 결정에 대한 추가 정보를 포함하고 싶다면, 다음과 같이 사용자 정의 ``AuthorizationDecision``을 반환할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component("authz")
public class AuthorizationLogic {
    public AuthorizationDecision decide(MethodSecurityExpressionOperations operations) {
        // ... 권한 부여 로직
        return new MyAuthorizationDecision(false, details);
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component("authz")
open class AuthorizationLogic {
    fun decide(val operations: MethodSecurityExpressionOperations): AuthorizationDecision {
        // ... 권한 부여 로직
        return MyAuthorizationDecision(false, details)
    }
}
----
======

또는 사용자 정의 `AuthorizationDeniedException` 인스턴스를 던질 수 있습니다.
단, 객체를 반환하는 것이 스택 트레이스 생성 비용을 피할 수 있으므로 선호됩니다.

그런 다음 <<fallback-values-authorization-denied, 권한 부여 결과 처리 방식을 사용자 정의>>할 때 사용자 정의 세부 정보에 접근할 수 있습니다.

[[custom-authorization-managers]]
=== 사용자 정의 권한 부여 관리자 사용

메서드를 프로그래밍 방식으로 권한 부여하는 두 번째 방법은 사용자 정의 xref:servlet/authorization/architecture.adoc#_the_authorizationmanager[`AuthorizationManager`]를 생성하는 것입니다.

먼저 다음과 같은 권한 부여 관리자 인스턴스를 선언합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class MyAuthorizationManager implements AuthorizationManager<MethodInvocation>, AuthorizationManager<MethodInvocationResult> {
    @Override
    public AuthorizationDecision check(Supplier<Authentication> authentication, MethodInvocation invocation) {
        // ... 권한 부여 로직
    }

    @Override
    public AuthorizationDecision check(Supplier<Authentication> authentication, MethodInvocationResult invocation) {
        // ... 권한 부여 로직
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
class MyAuthorizationManager : AuthorizationManager<MethodInvocation>, AuthorizationManager<MethodInvocationResult> {
    override fun check(authentication: Supplier<Authentication>, invocation: MethodInvocation): AuthorizationDecision {
        // ... 권한 부여 로직
    }

    override fun check(authentication: Supplier<Authentication>, invocation: MethodInvocationResult): AuthorizationDecision {
        // ... 권한 부여 로직
    }
}
----
======

그런 다음 해당 ``AuthorizationManager``를 실행하려는 시기에 해당하는 포인트컷과 함께 메서드 인터셉터를 게시합니다.
예를 들어, ``@PreAuthorize``와 ``@PostAuthorize``의 작동 방식을 다음과 같이 대체할 수 있습니다:

.@PreAuthorize와 @PostAuthorize만 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
    @Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor preAuthorize(MyAuthorizationManager manager) {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(manager);
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	Advisor postAuthorize(MyAuthorizationManager manager) {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize(manager);
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableMethodSecurity(prePostEnabled = false)
class MethodSecurityConfig {
   	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun preAuthorize(val manager: MyAuthorizationManager) : Advisor {
		return AuthorizationManagerBeforeMethodInterceptor.preAuthorize(manager)
	}

	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	fun postAuthorize(val manager: MyAuthorizationManager) : Advisor {
		return AuthorizationManagerAfterMethodInterceptor.postAuthorize(manager)
	}
}
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security pre-post-enabled="false"/>

<aop:config/>

<bean id="preAuthorize"
	class="org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor"
	factory-method="preAuthorize">
    <constructor-arg ref="myAuthorizationManager"/>
</bean>

<bean id="postAuthorize"
	class="org.springframework.security.authorization.method.AuthorizationManagerAfterMethodInterceptor"
	factory-method="postAuthorize">
    <constructor-arg ref="myAuthorizationManager"/>
</bean>
----
======

[TIP]
====
``AuthorizationInterceptorsOrder``에 지정된 순서 상수를 사용하여 인터셉터를 Spring Security 메서드 인터셉터 사이에 배치할 수 있습니다.
====

[[customizing-expression-handling]]
=== 표현식 처리 사용자 정의

또는 세 번째로, 각 SpEL 표현식이 처리되는 방식을 사용자 정의할 수 있습니다.
이를 위해 다음과 같이 사용자 정의 {security-api-url}org.springframework.security.access.expression.method.MethodSecurityExpressionHandler.html[`MethodSecurityExpressionHandler`]를 노출할 수 있습니다:

.사용자 정의 MethodSecurityExpressionHandler
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
static MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) {
	DefaultMethodSecurityExpressionHandler handler = new DefaultMethodSecurityExpressionHandler();
	handler.setRoleHierarchy(roleHierarchy);
	return handler;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
companion object {
	@Bean
	fun methodSecurityEx

pressionHandler(val roleHierarchy: RoleHierarchy) : MethodSecurityExpressionHandler {
		val handler = DefaultMethodSecurityExpressionHandler()
		handler.setRoleHierarchy(roleHierarchy)
		return handler
	}
}
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security>
	<sec:expression-handler ref="myExpressionHandler"/>
</sec:method-security>

<bean id="myExpressionHandler"
		class="org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler">
	<property name="roleHierarchy" ref="roleHierarchy"/>
</bean>
----
======

[TIP]
====
Spring이 Spring Security의 메서드 보안 `@Configuration` 클래스를 초기화하기 전에 ``MethodSecurityExpressionHandler``를 게시하도록 `static` 메서드를 사용하여 노출합니다.
====

또한 <<subclass-defaultmethodsecurityexpressionhandler,``DefaultMessageSecurityExpressionHandler``를 서브클래싱>>하여 기본값 외에 자체 사용자 정의 권한 부여 표현식을 추가할 수 있습니다.

[[use-aspectj]]
== AspectJ를 사용한 권한 부여

[[match-by-pointcut]]
=== 사용자 정의 포인트컷으로 메서드 일치

Spring AOP를 기반으로 설계되어 있어 xref:servlet/authorization/authorize-http-requests.adoc[요청 레벨 권한 부여]와 유사하게 어노테이션과 관련되지 않은 패턴을 선언할 수 있습니다.
이는 메서드 레벨 권한 부여 규칙을 중앙 집중화할 수 있는 잠재적인 장점이 있습니다.

예를 들어, 자체 ``Advisor``를 게시하거나 xref:servlet/appendix/namespace/method-security.adoc#nsa-protect-pointcut[`<protect-pointcut>`]을 사용하여 서비스 계층에 대한 AOP 표현식을 권한 부여 규칙과 일치시킬 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole

@Bean
@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
static Advisor protectServicePointcut() {
    AspectJExpressionPointcut pattern = new AspectJExpressionPointcut()
    pattern.setExpression("execution(* com.mycompany.*Service.*(..))")
    return new AuthorizationManagerBeforeMethodInterceptor(pattern, hasRole("USER"))
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import static org.springframework.security.authorization.AuthorityAuthorizationManager.hasRole

companion object {
    @Bean
    @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
    fun protectServicePointcut(): Advisor {
        val pattern = AspectJExpressionPointcut()
        pattern.setExpression("execution(* com.mycompany.*Service.*(..))")
        return new AuthorizationManagerBeforeMethodInterceptor(pattern, hasRole("USER"))
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security>
    <protect-pointcut expression="execution(* com.mycompany.*Service.*(..))" access="hasRole('USER')"/>
</sec:method-security>
----
======

[[weave-aspectj]]
=== AspectJ 바이트코드 위빙과 통합

때때로 AspectJ를 사용하여 Spring Security 어드바이스를 빈의 바이트코드로 위빙하면 성능이 향상될 수 있습니다.

AspectJ를 설정한 후, `@EnableMethodSecurity` 어노테이션이나 `<method-security>` 요소에서 AspectJ를 사용한다고 간단히 명시할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableMethodSecurity(mode=AdviceMode.ASPECTJ)
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity(mode=AdviceMode.ASPECTJ)
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security mode="aspectj"/>
----
======

그 결과 Spring Security는 어드바이저를 AspectJ 어드바이스로 게시하여 적절하게 위빙될 수 있도록 합니다.

[[changing-the-order]]
== 순서 지정

이미 언급했듯이, 각 어노테이션에 대한 Spring AOP 메서드 인터셉터가 있으며, 각각은 Spring AOP 어드바이저 체인에서 위치를 가집니다.

구체적으로, `@PreFilter` 메서드 인터셉터의 순서는 100, ``@PreAuthorize``의 순서는 200 등입니다.

이를 주목해야 하는 이유는 ``@EnableTransactionManagement``와 같은 다른 AOP 기반 어노테이션이 `Integer.MAX_VALUE` 순서를 가지고 있기 때문입니다.
즉, 기본적으로 어드바이저 체인의 끝에 위치합니다.

때때로 다른 어드바이스가 Spring Security보다 먼저 실행되도록 하는 것이 가치 있을 수 있습니다.
예를 들어, ``@Transactional``과 ``@PostAuthorize``로 어노테이션이 달린 메서드가 있는 경우, ``@PostAuthorize``가 실행될 때 트랜잭션이 여전히 열려있어 ``AccessDeniedException``이 롤백을 유발하도록 할 수 있습니다.

메서드 권한 부여 어드바이스가 실행되기 전에 ``@EnableTransactionManagement``가 트랜잭션을 열도록 하려면 다음과 같이 ``@EnableTransactionManagement``의 순서를 설정할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableTransactionManagement(order = 0)
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableTransactionManagement(order = 0)
----

Xml::
+
[source,xml,role="secondary"]
----
<tx:annotation-driven ref="txManager" order="0"/>
----
======

가장 빠른 메서드 인터셉터(`@PreFilter`)의 순서가 100으로 설정되어 있으므로, 0으로 설정하면 트랜잭션 어드바이스가 모든 Spring Security 어드바이스보다 먼저 실행됩니다.

[[authorization-expressions]]
== SpEL을 사용한 권한 부여 표현

이미 SpEL을 사용한 여러 예를 보셨으므로 이제 API를 좀 더 자세히 살펴보겠습니다.

Spring Security는 모든 권한 부여 필드와 메서드를 루트 객체 세트에 캡슐화합니다.
가장 일반적인 루트 객체는 ``SecurityExpressionRoot``라고 하며 ``MethodSecurityExpressionRoot``의 기초를 형성합니다.
Spring Security는 권한 부여 표현식을 평가할 준비를 할 때 ``MethodSecurityEvaluationContext``에 이 루트 객체를 제공합니다.

[[using-authorization-expression-fields-and-methods]]
=== 권한 부여 표현식 필드 및 메서드 사용

이것이 제공하는 첫 번째 것은 SpEL 표현식에 대한 향상된 권한 부여 필드 및 메서드 세트입니다.
다음은 가장 일반적인 메서드에 대한 간단한 개요입니다:

* `permitAll` - 메서드 호출에 권한 부여가 필요하지 않습니다; 이 경우 xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`]은 세션에서 절대 검색되지 않습니다
* `denyAll` - 어떤 상황에서도 메서드가 허용되지 않습니다; 이 경우 ``Authentication``은 세션에서 절대 검색되지 않습니다
* `hasAuthority` - 메서드는 ``Authentication``이 주어진 값과 일치하는 xref:servlet/authorization/architecture.adoc#authz-authorities[`GrantedAuthority`]를 가지고 있어야 합니다
* `hasRole` - `ROLE_` 또는 구성된 기본 접두사를 앞에 붙이는 ``hasAuthority``의 약칭입니다
* `hasAnyAuthority` - 메서드는 ``Authentication``이 주어진 값 중 하나와 일치하는 ``GrantedAuthority``를 가지고 있어야 합니다
* `hasAnyRole` - `ROLE_` 또는 구성된 기본 접두사를 앞에 붙이는 ``hasAnyAuthority``의 약칭입니다
* `hasPermission` - 객체 레벨 권한 부여를 위한 ``PermissionEvaluator`` 인스턴스에 대한 후크입니다

그리고 다음은 가장 일반적인 필드에 대한 간단한 개요입니다:

* `authentication` - 이 메서드 호출과 관련된 `Authentication` 인스턴스
* `principal` - 이 메서드 호출과 관련된 `Authentication#getPrincipal`

이제 패턴, 규칙 및 이들을 어떻게 함께 사용할 수 있는지 배웠으므로 다음과 같은 더 복잡한 예제를 이해할 수 있을 것입니다:

.요청 권한 부여
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class MyService {
    @PreAuthorize("denyAll") <1>
    MyResource myDeprecatedMethod(...);

    @PreAuthorize("hasRole('ADMIN')") <2>
    MyResource writeResource(...)

    @PreAuthorize("hasAuthority('db') and hasRole('ADMIN')") <3>
    MyResource deleteResource(...)

    @PreAuthorize("principal.claims['aud'] == 'my-audience'") <4>
    MyResource readResource(...);

	@PreAuthorize("@authz.check(authentication, #root)")
    MyResource shareResource(...);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
open class MyService {
    @PreAuthorize("denyAll") <1>
    fun myDeprecatedMethod(...): MyResource

    @PreAuthorize("hasRole('ADMIN')") <2>
    fun writeResource(...): MyResource

    @PreAuthorize("hasAuthority('db') and hasRole('ADMIN')") <3>
    fun deleteResource(...): MyResource

    @PreAuthorize("principal.claims['aud'] == 'my-audience'") <4>
    fun readResource(...): MyResource

    @PreAuthorize("@authz.check(#root)")
    fun shareResource(...): MyResource
}
----

Xml::
+
[source,xml,role="secondary"]
----
<sec:method-security>
    <protect-pointcut expression="execution(* com.mycompany.*Service.myDeprecatedMethod(..))" access="denyAll"/> <1>
    <protect-pointcut expression="execution(* com.mycompany.*Service.writeResource(..))" access="hasRole('ADMIN')"/> <2>
    <protect-pointcut expression="execution(* com.mycompany.*Service.deleteResource(..))" access="hasAuthority('db') and hasRole('ADMIN')"/> <3>
    <protect-pointcut expression="execution(* com.mycompany.*Service.readResource(..))" access="principal.claims['aud'] == 'my-audience'"/> <4>
    <protect-pointcut expression="execution(* com.mycompany.*Service.shareResource(..))" access="@authz.check(#root)"/> <5>
</sec:method-security>
----
======
<1> 이 메서드는 어떤 이유로든 누구도 호출할 수 없습니다
<2> 이 메서드는 `ROLE_ADMIN` 권한이 부여된 ``Authentication``만 호출할 수 있습니다
<3> 이 메서드는 ``db``와 `ROLE_ADMIN` 권한이 부여된 ``Authentication``만 호출할 수 있습니다
<4> 이 메서드는 `aud` 클레임이 "my-audience"와 같은 ``Principal``만 호출할 수 있습니다
<5> 이 메서드는 `authz` 빈의 `check` 메서드가 ``true``를 반환하는 경우에만 호출할 수 있습니다

[TIP]
====
위의 ``authz``와 같은 빈을 사용하여 <<_using_a_custom_bean_in_spel, 프로그래밍 방식 권한 부여를 추가>>할 수 있습니다.
====

[[using_method_parameters]]
=== 메서드 매개변수 사용

또한 Spring Security는 메서드 매개변수를 발견하는 메커니즘을 제공하여 SpEL 표현식에서도 접근할 수 있도록 합니다.

전체 참조를 위해 Spring Security는 ``DefaultSecurityParameterNameDiscoverer``를 사용하여 매개변수 이름을 발견합니다.
기본적으로 메서드에 대해 다음 옵션이 시도됩니다.

1. 메서드의 단일 인수에 Spring Security의 ``@P`` 어노테이션이 있는 경우 해당 값이 사용됩니다.
다음 예제는 ``@P`` 어노테이션을 사용합니다:

+

[tabs]
======
Java::
+
[source,java,role="primary"]
----
import org.springframework.security.access.method.P;

...

@PreAuthorize("hasPermission(#c, 'write')")
public void updateContact(@P("c") Contact contact);


----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.access.method.P

...

@PreAuthorize("hasPermission(#c, 'write')")
fun doSomething(@P("c") contact: Contact?)
----
======
+
이 표현식의 의도는 현재 ``Authentication``이 이 특정 ``Contact`` 인스턴스에 대해 ``write`` 권한을 가지도록 요구하는 것입니다.
+
내부적으로 이는 ``AnnotationParameterNameDiscoverer``를 사용하여 구현되며, 지정된 모든 어노테이션의 value 속성을 지원하도록 사용자 정의할 수 있습니다.

* xref:servlet/integrations/data.adoc[Spring Data]의 ``@Param`` 어노테이션이 메서드의 적어도 하나의 매개변수에 있는 경우 해당 값이 사용됩니다.
다음 예제는 ``@Param`` 어노테이션을 사용합니다:
+
[tabs]
======
Java::
+
[source,java,role="primary"]
----
import org.springframework.data.repository.query.Param;

...

@PreAuthorize("#n == authentication.name")
Contact findContactByName(@Param("n") String name);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.data.repository.query.Param

...

@PreAuthorize("#n == authentication.name")
fun findContactByName(@Param("n") name: String?): Contact?
----
======
+
이 표현식의 의도는 호출이 권한 부여되기 위해 ``name``이 ``Authentication#getName``과 같아야 한다는 것입니다.
+
내부적으로 이는 ``AnnotationParameterNameDiscoverer``를 사용하여 구현되며, 지정된 모든 어노테이션의 value 속성을 지원하도록 사용자 정의할 수 있습니다.

* 코드를 ``-parameters`` 인수로 컴파일하는 경우, 표준 JDK 리플렉션 API를 사용하여 매개변수 이름을 발견합니다.
이는 클래스와 인터페이스 모두에서 작동합니다.

* 마지막으로, 코드를 디버그 심볼과 함께 컴파일하는 경우 디버그 심볼을 사용하여 매개변수 이름을 발견합니다.
이는 인터페이스에서는 작동하지 않습니다. 인터페이스에는 매개변수 이름에 대한 디버그 정보가 없기 때문입니다.
인터페이스의 경우 어노테이션이나 ``-parameters`` 접근 방식을 사용해야 합니다.

[[authorize-object]]
== 임의의 객체 권한 부여

Spring Security는 메서드 보안 어노테이션이 달린 모든 객체를 래핑하는 것도 지원합니다.

이를 달성하는 가장 간단한 방법은 권한 부여하려는 객체를 반환하는 모든 메서드에 `@AuthorizeReturnObject` 어노테이션을 표시하는 것입니다.

예를 들어, 다음과 같은 `User` 클래스를 고려해 보세요:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class User {
	private String name;
	private String email;

	public User(String name, String email) {
		this.name = name;
		this.email = email;
	}

	public String getName() {
		return this.name;
	}

    @PreAuthorize("hasAuthority('user:read')")
    public String getEmail() {
		return this.email;
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class User (val name:String, @get:PreAuthorize("hasAuthority('user:read')") val email:String)
----
======

다음과 같은 인터페이스가 주어진 경우:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class UserRepository {
	@AuthorizeReturnObject
    Optional<User> findByName(String name) {
		// ...
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class UserRepository {
    @AuthorizeReturnObject
    fun findByName(name:String?): Optional<User?>? {
        // ...
    }
}
----
======

그러면 ``findById``에서 반환된 모든 ``User``는 다른 Spring Security 보호 컴포넌트처럼 보안됩니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
UserRepository users;

@Test
void getEmailWhenProxiedThenAuthorizes() {
    Optional<User> securedUser = users.findByName("name");
    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(() -> securedUser.get().getEmail());
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----

import jdk.incubator.vector.VectorOperators.Test
import java.nio.file.AccessDeniedException
import java.util.*

@Autowired
var users:UserRepository? = null

@Test
fun getEmailWhenProxiedThenAuthorizes() {
    val securedUser: Optional<User> = users.findByName("name")
    assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy{securedUser.get().getEmail()}
}
----
======

=== 클래스 레벨에서 `@AuthorizeReturnObject` 사용

``@AuthorizeReturnObject``는 클래스 레벨에 배치할 수 있습니다. 그러나 이는 Spring Security가 `String`, `Integer` 및 기타 타입을 포함한 모든 반환 객체를 프록시하려고 시도한다는 것을 의미합니다.
이는 대개 원하는 동작이 아닙니다.

`int`, `String`, `Double` 또는 이러한 타입의 컬렉션과 같은 값 타입을 반환하는 메서드가 있는 클래스나 인터페이스에서 ``@AuthorizeReturnObject``를 사용하려면 다음과 같이 적절한 ``AuthorizationAdvisorProxyFactory.TargetVisitor``를 게시해야 합니다:


[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
static Customizer<AuthorizationAdvisorProxyFactory> skipValueTypes() {
    return (factory) -> factory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes());
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
open fun skipValueTypes() = Customizer<AuthorizationAdvisorProxyFactory> {
    it.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes())
}
----
======

[TIP]
====
모든 타입 세트에 대한 프록시를 사용자 정의하기 위해 자체 ``AuthorizationAdvisorProxyFactory.TargetVisitor``를 설정할 수 있습니다
====

=== 프로그래밍 방식 프록시

주어진 객체를 프로그래밍 방식으로 프록시할 수도 있습니다.

이를 위해 구성한 메서드 보안 인터셉터를 기반으로 제공된 `AuthorizationProxyFactory` 인스턴스를 자동 연결할 수 있습니다.
``@EnableMethodSecurity``를 사용하는 경우, 이는 기본적으로 `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, ``@PostFilter``에 대한 인터셉터를 가지게 됩니다.


다음과 같은 방식으로 사용자 인스턴스를 프록시할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
AuthorizationProxyFactory proxyFactory;

@Test
void getEmailWhenProxiedThenAuthorizes() {
    User user = new User("name", "email");
    assertThat(user.getEmail()).isNotNull();
    User securedUser = proxyFactory.proxy(user);
    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Autowired
var proxyFactory:AuthorizationProxyFactory? = null

@Test
fun getEmailWhenProxiedThenAuthorizes() {
    val user: User = User("name", "email")
    assertThat(user.getEmail()).isNotNull()
    val securedUser: User = proxyFactory.proxy(user)
    assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy(securedUser::getEmail)
}
----
======

=== 수동 구성

Spring Security 기본값과 다른 것이 필요한 경우 자체 인스턴스를 정의할 수도 있습니다.

예를 들어, 다음과 같이 `AuthorizationProxyFactory` 인스턴스를 정의할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
import org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor;
import static org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.preAuthorize;
// ...

AuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults();
// 값 타입을 건너뛰어야 하는 경우
proxyFactory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes());
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.security.authorization.method.AuthorizationAdvisorProxyFactory.TargetVisitor;
import org.springframework.security.authorization.method.AuthorizationManagerBeforeMethodInterceptor.preAuthorize

// ...

val proxyFactory: AuthorizationProxyFactory = AuthorizationAdvisorProxyFactory(preAuthorize())
// 값 타입을 건너뛰어야 하는 경우
proxyFactory.setTargetVisitor(TargetVisitor.defaultsSkipValueTypes())
----
======

그런 다음 다음과 같이 모든 `User` 인스턴스를 래핑할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Test
void getEmailWhenProxiedThenAuthorizes() {
	AuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults();
    User user = new User("name", "email");
    assertThat(user.getEmail()).isNotNull();
    User securedUser = proxyFactory.proxy(user);
    assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Test
fun getEmailWhenProxiedThenAuthorizes() {
    val proxyFactory: AuthorizationProxyFactory = AuthorizationAdvisorProxyFactory.withDefaults()
    val user: User = User("name", "email")
    assertThat(user.getEmail()).isNotNull()
    val securedUser: User = proxyFactory.proxy(user)
    assertThatExceptionOfType(AccessDeniedException::class.java).isThrownBy(securedUser::getEmail)
}
----
======

[NOTE]
====
이 기능은 아직 Spring AOT를 지원하지 않습니다
====

=== 컬렉션 프록시 생성

``AuthorizationProxyFactory``는 Java 컬렉션, 스트림, 배열, 옵셔널, 반복자의 요소 타입을 프록시하고 맵의 경우 값 타입을 프록시합니다.

이는 객체의 ``List``를 프록시할 때 다음과 같이 작동한다는 것을 의미합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Test
void getEmailWhenProxiedThenAuthorizes() {
	AuthorizationProxyFactory proxyFactory = AuthorizationAdvisorProxyFactory.withDefaults();
    List<User> users = List.of(ada, albert, marie);
    List<User> securedUsers = proxyFactory.proxy(users);
	securedUsers.forEach((securedUser) ->
        assertThatExceptionOfType(AccessDeniedException.class).isThrownBy(securedUser::getEmail));
}
----
======

=== 클래스 프록시 생성

제한된 상황에서는 `Class` 자체를 프록시하는 것이 유용할 수 있으며, ``AuthorizationProxyFactory``도 이를 지원합니다.
이는 대략 Spring Framework의 프록시 생성 지원에서 ``ProxyFactory#getProxyClass``를 호출하는 것과 동등합니다.

이는 Spring AOT와 같이 프록시 클래스를 미리 구성해야 하는 경우에 유용합니다.

=== 모든 메서드 보안 어노테이션 지원

``AuthorizationProxyFactory``는 애플리케이션에서 활성화된 모든 메서드 보안 어노테이션을 지원합니다.
빈으로 게시된 ``AuthorizationAdvisor`` 클래스를 기반으로 합니다.

``@EnableMethodSecurity``는 기본적으로 `@PreAuthorize`, `@PostAuthorize`, `@PreFilter`, `@PostFilter` 어드바이저를 게시하므로, 일반적으로 이 기능을 활성화하기 위해 추가 작업을 할 필요가 없습니다.

[NOTE]
====
`returnObject` 또는 ``filterObject``를 사용하는 SpEL 표현식은 프록시 뒤에 있으므로 객체에 완전히 접근할 수 있습니다.
====

[#custom_advice]
=== 사용자 정의 어드바이스

적용하려는 보안 어드바이스가 있다면 다음과 같이 자체 ``AuthorizationAdvisor``를 게시할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableMethodSecurity
class SecurityConfig {
    @Bean
    static AuthorizationAdvisor myAuthorizationAdvisor() {
        return new AuthorizationAdvisor();
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity
internal class SecurityConfig {
    @Bean
    fun myAuthorizationAdvisor(): AuthorizationAdvisor {
        return AuthorizationAdvisor()
    }
]
----
======

그러면 Spring Security는 ``AuthorizationProxyFactory``가 객체를 프록시할 때 추가하는 어드바이스 세트에 해당 어드바이저를 추가합니다.

=== Jackson과 함께 작업하기

이 기능의 강력한 사용 사례 중 하나는 컨트롤러에서 보안처리 된 값을 다음과 같이 반환하는 것입니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@RestController
public class UserController {
	@Autowired
    AuthorizationProxyFactory proxyFactory;

	@GetMapping
    User currentUser(@AuthenticationPrincipal User user) {
        return this.proxyFactory.proxy(user);
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@RestController
class UserController  {
    @Autowired
    var proxyFactory: AuthorizationProxyFactory? = null

    @GetMapping
    fun currentUser(@AuthenticationPrincipal user:User?): User {
        return proxyFactory.proxy(user)
    }
}
----
======

그러나 Jackson을 사용하는 경우 다음과 같은 직렬화 오류가 발생할 수 있습니다:

[source,bash]
====
com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Direct self-reference leading to cycle
====

이는 Jackson이 CGLIB 프록시와 작동하는 방식 때문입니다.
이를 해결하려면 `User` 클래스 상단에 다음 어노테이션을 추가하세요:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@JsonSerialize(as = User.class)
public class User {

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@JsonSerialize(`as` = User::class)
class User
----
======

마지막으로, 각 필드에 대해 발생하는 ``AccessDeniedException``을 잡기 위해 <<custom_advice, 사용자 정의 인터셉터>>를 게시해야 합니다. 다음과 같이 할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class AccessDeniedExceptionInterceptor implements AuthorizationAdvisor {
    private final AuthorizationAdvisor advisor = AuthorizationManagerBeforeMethodInterceptor.preAuthorize();

	@Override
	public Object invoke(MethodInvocation invocation) throws Throwable {
		try {
			return invocation.proceed();
		} catch (AccessDeniedException ex) {
			return null;
		}
	}

	@Override
	public Pointcut getPointcut() {
		return this.advisor.getPointcut();
	}

	@Override
	public Advice getAdvice() {
		return this;
	}

	@Override
	public int getOrder() {
		return this.advisor.getOrder() - 1;
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
class AccessDeniedExceptionInterceptor: AuthorizationAdvisor {
    var advisor: AuthorizationAdvisor = AuthorizationManagerBeforeMethodInterceptor.preAuthorize()

    @Throws(Throwable::class)
    fun invoke(invocation: MethodInvocation): Any? {
        return try  {
            invocation.proceed()
        } catch (ex:AccessDeniedException) {
            null
        }
    }

     val pointcut: Pointcut
     get() = advisor.getPointcut()

     val advice: Advice
     get() = this

     val order: Int
     get() = advisor.getOrder() - 1
}
----
======

그러면 사용자의 권한 부여 레벨에 따라 다른 JSON 직렬화가 표시됩니다.
`user:read` 권한이 없는 경우 다음과 같이 표시됩니다:

[source,json]
----
{
    "name" : "name",
    "email" : null
}
----

그리고 해당 권한이 있는 경우 다음과 같이 표시됩니다:

[source,json]
----
{
    "name" : "name",
    "email" : "email"
}
----

[TIP]
====
Spring Boot 속성 ``spring.jackson.default-property-inclusion=non_null``을 추가하여 null 값을 제외할 수도 있습니다. 이렇게 하면 권한 부여되지 않은 사용자에게 JSON 키도 노출되지 않습니다.
====

[[fallback-values-authorization-denied]]
== 권한 부여가 거부된 경우 대체 값 제공

필요한 권한 없이 메서드가 호출될 때 ``AuthorizationDeniedException``을 던지고 싶지 않은 시나리오가 있을 수 있습니다.
대신 마스킹된 결과와 같은 후처리된 결과나, 메서드 호출 전에 권한 부여가 거부된 경우 기본값을 반환하고 싶을 수 있습니다.

Spring Security는 {security-api-url}org/springframework/security/authorization/method/HandleAuthorizationDenied.html[`@HandleAuthorizationDenied`]를 사용하여 메서드 호출 시 권한 부여 거부를 처리하는 지원을 제공합니다.
이 핸들러는 <<authorizing-with-annotations,`@PreAuthorize` 및 `@PostAuthorize` 어노테이션>>에서 발생한 권한 부여 거부와 메서드 호출 자체에서 발생한 {security-api-url}org/springframework/security/authorization/AuthorizationDeniedException.html[`AuthorizationDeniedException`]에 대해 작동합니다.

<<authorize-object,이전 섹션>>의 예제를 고려해 보겠습니다. 하지만 ``AccessDeniedException``을 `null` 반환 값으로 변환하는 ``AccessDeniedExceptionInterceptor``를 만드는 대신 ``@HandleAuthorizationDenied``의 ``handlerClass`` 속성을 사용하겠습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class NullMethodAuthorizationDeniedHandler implements MethodAuthorizationDeniedHandler { <1>

    @Override
    public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {
        return null;
    }

}

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    @Bean <2>
    public NullMethodAuthorizationDeniedHandler nullMethodAuthorizationDeniedHandler() {
        return new NullMethodAuthorizationDeniedHandler();
    }

}

public class User {
    // ...

    @PreAuthorize(value = "hasAuthority('user:read')")
    @HandleAuthorizationDenied(handlerClass = NullMethodAuthorizationDeniedHandler.class)
    public String getEmail() {
        return this.email;
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class NullMethodAuthorizationDeniedHandler : MethodAuthorizationDeniedHandler { <1>

    override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any {
        return null
    }

}

@Configuration
@EnableMethodSecurity
class SecurityConfig {

    @Bean <2>
    fun nullMethodAuthorizationDeniedHandler(): NullMethodAuthorizationDeniedHandler {
        return MaskMethodAuthorizationDeniedHandler()
    }

}

class User (val name:String, @PreAuthorize(value = "hasAuthority('user:read')") @HandleAuthorizationDenied(handlerClass = NullMethodAuthorizationDeniedHandler::class) val email:String) <3>
----
======

<1> `null` 값을 반환하는 `MethodAuthorizationDeniedHandler` 구현을 생성합니다
<2> ``NullMethodAuthorizationDeniedHandler``를 빈으로 등록합니다
<3> 메서드에 `@HandleAuthorizationDenied` 어노테이션을 달고 `handlerClass` 속성에 ``NullMethodAuthorizationDeniedHandler``를 전달합니다

그리고 `AccessDeniedException` 대신 `null` 값이 반환되는지 확인할 수 있습니다:

[TIP]
====
`@Bean` 메서드를 생성하는 대신 클래스에 `@Component` 어노테이션을 달 수도 있습니다
====

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
UserRepository users;

@Test
void getEmailWhenProxiedThenNullEmail() {
    Optional<User> securedUser = users.findByName("name");
    assertThat(securedUser.get().getEmail()).isNull();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Autowired
var users:UserRepository? = null

@Test
fun getEmailWhenProxiedThenNullEmail() {
    val securedUser: Optional<User> = users.findByName("name")
    assertThat(securedUser.get().getEmail()).isNull()
}
----
======

=== 메서드 호출의 거부된 결과 사용

거부된 결과에서 파생된 안전한 결과를 반환하고 싶은 시나리오가 있을 수 있습니다.
예를 들어, 사용자가 이메일 주소를 볼 수 있는 권한이 없는 경우 원래 이메일 주소에 일부 마스킹을 적용하고 싶을 수 있습니다. 즉, _useremail@example.com_이 _use\\******@example.com_으로 변경될 수 있습니다.

이러한 시나리오의 경우 {security-api-url}org/springframework/security/authorization/method/MethodInvocationResult.html[`MethodInvocationResult`]를 인수로 받는 ``MethodAuthorizationDeniedHandler``의 ``handleDeniedInvocationResult``를 재정의할 수 있습니다.
이전 예제를 계속 사용하되, ``null``을 반환하는 대신 이메일의 마스킹된 값을 반환하겠습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
public class EmailMaskingMethodAuthorizationDeniedHandler implements MethodAuthorizationDeniedHandler { <1>

    @Override
    public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {
        return "***";
    }

    @Override
    public Object handleDeniedInvocationResult(MethodInvocationResult methodInvocationResult, AuthorizationResult authorizationResult) {
        String email = (String) methodInvocationResult.getResult();
        return email.replaceAll("(^[^@]{3}|(?!^)\\G)[^@]", "$1*");
    }

}

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    @Bean <2>
    public EmailMaskingMethodAuthorizationDeniedHandler emailMaskingMethodAuthorizationDeniedHandler() {
        return new EmailMaskingMethodAuthorizationDeniedHandler();
    }

}

public class User {
    // ...

    @PostAuthorize(value = "hasAuthority('user:read')")
    @HandleAuthorizationDenied(handlerClass = EmailMaskingMethodAuthorizationDeniedHandler.class)
    public String getEmail() {
        return this.email;
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class EmailMaskingMethodAuthorizationDeniedHandler : MethodAuthorizationDeniedHandler {

    override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any {
        return "***"
    }

    override fun handleDeniedInvocationResult(methodInvocationResult: MethodInvocationResult, authorizationResult: AuthorizationResult): Any {
        val email = methodInvocationResult.result as String
        return email.replace("(^[^@]{3}|(?!^)\\G)[^@]".toRegex(), "$1*")
    }

}

@Configuration
@EnableMethodSecurity
class SecurityConfig {

    @Bean
    fun emailMaskingMethodAuthorizationDeniedHandler(): EmailMaskingMethodAuthorizationDeniedHandler {
        return EmailMaskingMethodAuthorizationDeniedHandler()
    }

}

class User (val name:String, @PostAuthorize(value = "hasAuthority('user:read')") @HandleAuthorizationDenied(handlerClass = EmailMaskingMethodAuthorizationDeniedHandler::class) val email:String) <3>
----
======

<1> 권한 부여되지 않은 결과 값의 마스킹된 값을 반환하는 `MethodAuthorizationDeniedHandler` 구현을 생성합니다
<2> ``EmailMaskingMethodAuthorizationDeniedHandler``를 빈으로 등록합니다
<3> 메서드에 `@HandleAuthorizationDenied` 어노테이션을 달고 `handlerClass` 속성에 ``EmailMaskingMethodAuthorizationDeniedHandler``를 전달합니다

그리고 `AccessDeniedException` 대신 마스킹된 이메일이 반환되는지 확인할 수 있습니다:

[WARNING]
====
원본 거부된 값에 접근할 수 있으므로 이를 올바르게 처리하고 호출자에게 반환하지 않도록 주의하세요.
====

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
UserRepository users;

@Test
void getEmailWhenProxiedThenMaskedEmail() {
    Optional<User> securedUser = users.findByName("name");
    // email은 useremail@example.com
    assertThat(securedUser.get().getEmail()).isEqualTo("use******@example.com");
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Autowired
var users:UserRepository? = null

@Test
fun getEmailWhenProxiedThenMaskedEmail() {
    val securedUser: Optional<User> = users.findByName("name")
    // email은 useremail@example.com
    assertThat(securedUser.get().getEmail()).isEqualTo("use******@example.com")
}
----
======

``MethodAuthorizationDeniedHandler``를 구현할 때 반환할 수 있는 타입에는 몇 가지 옵션이 있습니다:

- `null` 값
- 메서드의 반환 타입을 준수하는 null이 아닌 값
- 예외 던지기, 일반적으로 ``AuthorizationDeniedException``의 인스턴스. 이는 기본 동작입니다.
- 리액티브 애플리케이션을 위한 ``Mono`` 타입

핸들러는 애플리케이션 컨텍스트에 빈으로 등록되어야 하므로 더 복잡한 로직이 필요한 경우 의존성을 주입할 수 있습니다.
또한 ``MethodInvocation`` 또는 ``MethodInvocationResult``, 그리고 권한 부여 결정과 관련된 자세한 정보를 위한 ``AuthorizationResult``를 사용할 수 있습니다.

[[deciding-return-based-parameters]]
=== 사용 가능한 매개변수를 기반으로 반환할 내용 결정

여러 메서드에 대해 여러 마스크 값이 있을 수 있는 시나리오를 고려해 보겠습니다. 이런 경우 각 메서드에 대해 핸들러를 만드는 것은 효율적이지 않을 수 있습니다(물론 그렇게 해도 괜찮습니다).
이런 경우 매개변수를 통해 전달된 정보를 사용하여 무엇을 할지 결정할 수 있습니다.
예를 들어, 사용자 정의 `@Mask` 어노테이션을 만들고 해당 어노테이션을 감지하여 어떤 마스크 값을 반환할지 결정하는 핸들러를 만들 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
import org.springframework.core.annotation.AnnotationUtils;

@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface Mask {

    String value();

}

public class MaskAnnotationDeniedHandler implements MethodAuthorizationDeniedHandler {

    @Override
    public Object handleDeniedInvocation(MethodInvocation methodInvocation, AuthorizationResult authorizationResult) {
        Mask mask = AnnotationUtils.getAnnotation(methodInvocation.getMethod(), Mask.class);
        return mask.value();
    }

}

@Configuration
@EnableMethodSecurity
public class SecurityConfig {

    @Bean
    public MaskAnnotationDeniedHandler maskAnnotationDeniedHandler() {
        return new MaskAnnotationDeniedHandler();
    }

}

@Component
public class MyService {

    @PreAuthorize(value = "hasAuthority('user:read')")
    @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class)
    @Mask("***")
    public String foo() {
        return "foo";
    }

    @PreAuthorize(value = "hasAuthority('user:read')")
    @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class)
    @Mask("???")
    public String bar() {
        return "bar";
    }

}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
import org.springframework.core.annotation.AnnotationUtils

@Target(AnnotationTarget.FUNCTION, AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
annotation class Mask(val value: String)

class MaskAnnotationDeniedHandler : MethodAuthorizationDeniedHandler {

    override fun handleDeniedInvocation(methodInvocation: MethodInvocation, authorizationResult: AuthorizationResult): Any {
        val mask = AnnotationUtils.getAnnotation(methodInvocation.method, Mask::class.java)
        return mask.value
    }

}

@Configuration
@EnableMethodSecurity
class SecurityConfig {

    @Bean
    fun maskAnnotationDeniedHandler(): MaskAnnotationDeniedHandler {
        return MaskAnnotationDeniedHandler()
    }

}

@Component
class MyService {

    @PreAuthorize(value = "hasAuthority('user:read')")
    @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class)
    @Mask("***")
    fun foo(): String {
        return "foo"
    }

    @PreAuthorize(value = "hasAuthority('user:read')")
    @HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class)
    @Mask("???")
    fun bar(): String {
        return "bar"
    }

}
----
======

이제 접근이 거부될 때 반환 값은 `@Mask` 어노테이션을 기반으로 결정됩니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Autowired
MyService myService;

@Test
void fooWhenDeniedThenReturnStars() {
    String value = this.myService.foo();
    assertThat(value).isEqualTo("***");
}

@Test
void barWhenDeniedThenReturnQuestionMarks() {
    String value = this.myService.foo();
    assertThat(value).isEqualTo("???");
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Autowired
var myService: MyService

@Test
fun fooWhenDeniedThenReturnStars() {
    val value: String = myService.foo()
    assertThat(value).isEqualTo("***")
}

@Test
fun barWhenDeniedThenReturnQuestionMarks() {
    val value: String = myService.foo()
    assertThat(value).isEqualTo("???")
}
----
======

=== 메타 어노테이션 지원과 결합

``@HandleAuthorizationDenied``를 다른 어노테이션과 결합하여 메서드의 어노테이션을 줄이고 단순화할 수 있습니다.
<<deciding-return-based-parameters,이전 섹션의 예제>>를 고려하여 ``@HandleAuthorizationDenied``와 ``@Mask``를 병합해 보겠습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Target({ ElementType.METHOD, ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
@HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler.class)
public @interface Mask {

    String value();

}

@Mask("***")
public String myMethod() {
    // ...
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Target(AnnotationTarget.FUNCTION, AnnotationTarget.CLASS)
@Retention(AnnotationRetention.RUNTIME)
@HandleAuthorizationDenied(handlerClass = MaskAnnotationDeniedHandler::class)
annotation class Mask(val value: String)

@Mask("***")
fun myMethod(): String {
    // ...
}
----
======

이제 메서드에 마스크 동작이 필요할 때 두 어노테이션을 모두 추가할 필요가 없습니다.
자세한 사용법은 <<meta-annotations,메타 어노테이션 지원>> 섹션을 읽어보세요.

[[migration-enableglobalmethodsecurity]]
== ``@EnableGlobalMethodSecurity``에서 마이그레이션

``@EnableGlobalMethodSecurity``를 사용하고 있다면 ``@EnableMethodSecurity``로 마이그레이션해야 합니다.

[[servlet-replace-globalmethodsecurity-with-methodsecurity]]
=== xref:servlet/authorization/method-security.adoc#jc-enable-global-method-security[전역 메서드 보안]을 xref:servlet/authorization/method-security.adoc#jc-enable-method-security[메서드 보안]으로 교체

{security-api-url}org/springframework/security/config/annotation/method/configuration/EnableGlobalMethodSecurity.html[`@EnableGlobalMethodSecurity`]와 xref:servlet/appendix/namespace/method-security.adoc#nsa-global-method-security[`<global-method-security>`]는 각각 {security-api-url}org/springframework/security/config/annotation/method/configuration/EnableMethodSecurity.html[`@EnableMethodSecurity`]와 xref:servlet/appendix/namespace/method-security.adoc#nsa-method-security[`<method-security>`]로 대체되었습니다.
새로운 어노테이션과 XML 요소는 기본적으로 Spring의 xref:servlet/authorization/method-security.adoc#jc-enable-method-security[사전/사후 어노테이션]을 활성화하고 내부적으로 ``AuthorizationManager``를 사용합니다.

이는 다음 두 목록이 기능적으로 동일하다는 것을 의미합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableGlobalMethodSecurity(prePostEnabled = true)
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableGlobalMethodSecurity(prePostEnabled = true)
----

Xml::
+
[source,xml,role="secondary"]
----
<global-method-security pre-post-enabled="true"/>
----
======

그리고:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableMethodSecurity
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity
----

Xml::
+
[source,xml,role="secondary"]
----
<method-security/>
----
======

사전/사후 어노테이션을 사용하지 않는 애플리케이션의 경우, 원하지 않는 동작을 활성화하지 않도록 비활성화해야 합니다.

예를 들어, 다음과 같은 목록은:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableGlobalMethodSecurity(securedEnabled = true)
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableGlobalMethodSecurity(securedEnabled = true)
----

Xml::
+
[source,xml,role="secondary"]
----
<global-method-security secured-enabled="true"/>
----
======

다음과 같이 변경해야 합니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@EnableMethodSecurity(securedEnabled = true, prePostEnabled = false)
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@EnableMethodSecurity(securedEnabled = true, prePostEnabled = false)
----

Xml::
+
[source,xml,role="secondary"]
----
<method-security secured-enabled="true" pre-post-enabled="false"/>
----
======

=== ``DefaultMethodSecurityExpressionHandler``를 서브클래싱하는 대신 사용자 정의 `@Bean` 사용

성능 최적화를 위해 ``MethodSecurityExpressionHandler``에 ``Authentication`` 대신 ``Supplier<Authentication>``을 받는 새로운 메서드가 도입되었습니다.

이를 통해 Spring Security는 `Authentication` 조회를 지연시킬 수 있으며, `@EnableGlobalMethodSecurity` 대신 ``@EnableMethodSecurity``를 사용할 때 자동으로 이점을 활용합니다.

그러나 코드가 ``DefaultMethodSecurityExpressionHandler``를 확장하고 사용자 정의 `SecurityExpressionRoot` 인스턴스를 반환하기 위해 ``createSecurityExpressionRoot(Authentication, MethodInvocation)``을 재정의한 경우, 이는 더 이상 작동하지 않습니다. 왜냐하면 ``@EnableMethodSecurity``가 설정한 구성에서는 대신 ``createEvaluationContext(Supplier<Authentication>, MethodInvocation)``을 호출하기 때문입니다.

다행히 이러한 레벨의 사용자 정의는 종종 불필요합니다.
대신 필요한 권한 부여 메서드가 있는 사용자 정의 빈을 생성할 수 있습니다.

예를 들어, ``@PostAuthorize("hasAuthority('ADMIN')")``의 사용자 정의 평가를 원하는 경우 다음과 같은 사용자 정의 `@Bean`을 생성할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
class MyAuthorizer {
	boolean isAdmin(MethodSecurityExpressionOperations root) {
		boolean decision = root.hasAuthority("ADMIN");
		// 사용자 정의 작업 ...
        return decision;
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
class MyAuthorizer {
	fun isAdmin(val root: MethodSecurityExpressionOperations): boolean {
		val decision = root.hasAuthority("ADMIN");
		// 사용자 정의 작업 ...
        return decision;
	}
}
----
======

그리고 다음과 같이 어노테이션에서 이를 참조할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@PreAuthorize("@authz.isAdmin(#root)")
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@PreAuthorize("@authz.isAdmin(#root)")
----
======

[[subclass-defaultmethodsecurityexpressionhandler]]
==== 여전히 ``DefaultMethodSecurityExpressionHandler``를 서브클래싱하고 싶습니다

여전히 ``DefaultMethodSecurityExpressionHandler``를 서브클래싱해야 한다면 그렇게 할 수 있습니다.
대신 다음과 같이 ``createEvaluationContext(Supplier<Authentication>, MethodInvocation)`` 메서드를 재정의하세요:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
class MyExpressionHandler extends DefaultMethodSecurityExpressionHandler {
    @Override
    public EvaluationContext createEvaluationContext(Supplier<Authentication> authentication, MethodInvocation mi) {
		StandardEvaluationContext context = (StandardEvaluationContext) super.createEvaluationContext(authentication, mi);
        MethodSecurityExpressionOperations delegate = (MethodSecurityExpressionOperations) context.getRootObject().getValue();
        MySecurityExpressionRoot root = new MySecurityExpressionRoot(delegate);
        context.setRootObject(root);
        return context;
    }
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Component
class MyExpressionHandler: DefaultMethodSecurityExpressionHandler {
    override fun createEvaluationContext(val authentication: Supplier<Authentication>,
        val mi: MethodInvocation): EvaluationContext {
		val context = super.createEvaluationContext(authentication, mi) as StandardEvaluationContext
        val delegate = context.getRootObject().getValue() as MethodSecurityExpressionOperations
        val root = MySecurityExpressionRoot(delegate)
        context.setRootObject(root)
        return context
    }
}
----
======

== 추가 읽기

이제 애플리케이션의 요청을 보호했으므로, 아직 하지 않았다면 xref:servlet/authorization/authorize-http-requests.adoc[요청을 보호]하세요.
또한 xref:servlet/test/index.adoc[애플리케이션 테스트]나 Spring Security를 xref:servlet/integrations/data.adoc[데이터 계층]이나 xref:servlet/integrations/observability.adoc[추적 및 메트릭]과 같은 애플리케이션의 다른 측면과 통합하는 방법에 대해 더 읽어볼 수 있습니다.