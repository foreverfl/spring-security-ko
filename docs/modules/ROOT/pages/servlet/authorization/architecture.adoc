[[authz-arch]]
= 권한 부여 아키텍처
:figures: servlet/authorization

이 섹션에서는 권한 부여에 적용되는 Spring Security 아키텍처에 대해 설명합니다.

[[authz-authorities]]
== 권한
xref:servlet/authentication/architecture.adoc#servlet-authentication-authentication[`Authentication`]에서 모든 `Authentication` 구현이 `GrantedAuthority` 객체 목록을 저장하는 방법에 대해 설명합니다.
이들은 주체에게 부여된 권한을 나타냅니다.
`GrantedAuthority` 객체는 ``AuthenticationManager``에 의해 `Authentication` 객체에 삽입되며, 나중에 권한 부여 결정을 할 때 `AccessDecisionManager` 인스턴스에 의해 읽힙니다.

`GrantedAuthority` 인터페이스에는 하나의 메서드만 있습니다:

[source,java]
----
String getAuthority();
----

이 메서드는 `AuthorizationManager` 인스턴스가 ``GrantedAuthority``의 정확한 `String` 표현을 얻기 위해 사용됩니다.
``String``으로 표현을 반환함으로써, ``GrantedAuthority``는 대부분의 ``AuthorizationManager`` 구현에서 쉽게 "읽을" 수 있습니다.
``GrantedAuthority``를 ``String``으로 정확히 표현할 수 없는 경우, 해당 ``GrantedAuthority``는 "복잡"한 것으로 간주되며 ``getAuthority()``는 ``null``을 반환해야 합니다.

복잡한 ``GrantedAuthority``의 예로는 다른 고객 계정 번호에 적용되는 작업 목록과 권한 임계값을 저장하는 구현이 있습니다.
이러한 복잡한 ``GrantedAuthority``를 ``String``으로 표현하는 것은 매우 어려울 것입니다. 결과적으로 ``getAuthority()`` 메서드는 ``null``을 반환해야 합니다.
이는 모든 ``AuthorizationManager``에게 특정 ``GrantedAuthority`` 구현을 지원해야 그 내용을 이해할 수 있다는 것을 나타냅니다.

Spring Security에는 ``SimpleGrantedAuthority``라는 하나의 구체적인 `GrantedAuthority` 구현이 포함되어 있습니다.
이 구현은 사용자가 지정한 모든 ``String``을 ``GrantedAuthority``로 변환할 수 있게 합니다.
보안 아키텍처에 포함된 모든 `AuthenticationProvider` 인스턴스는 ``SimpleGrantedAuthority``를 사용하여 `Authentication` 객체를 채웁니다.

[[jc-method-security-custom-granted-authority-defaults]]
기본적으로 역할 기반 권한 부여 규칙에는 `ROLE_` 접두사가 포함됩니다.
이는 보안 컨텍스트가 "USER" 역할을 가져야 하는 권한 부여 규칙이 있는 경우, Spring Security는 기본적으로 "ROLE_USER"를 반환하는 ``GrantedAuthority#getAuthority``를 찾는다는 것을 의미합니다.

``GrantedAuthorityDefaults``를 사용하여 이를 사용자 정의할 수 있습니다.
``GrantedAuthorityDefaults``는 역할 기반 권한 부여 규칙에 사용할 접두사를 사용자 정의할 수 있게 합니다.

다음과 같이 ``GrantedAuthorityDefaults`` 빈을 노출하여 권한 부여 규칙이 다른 접두사를 사용하도록 구성할 수 있습니다:

.Custom MethodSecurityExpressionHandler
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
static GrantedAuthorityDefaults grantedAuthorityDefaults() {
	return new GrantedAuthorityDefaults("MYPREFIX_");
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
companion object {
	@Bean
	fun grantedAuthorityDefaults() : GrantedAuthorityDefaults {
		return GrantedAuthorityDefaults("MYPREFIX_");
	}
}
----

Xml::
+
[source,xml,role="secondary"]
----
<bean id="grantedAuthorityDefaults" class="org.springframework.security.config.core.GrantedAuthorityDefaults">
	<constructor-arg value="MYPREFIX_"/>
</bean>
----
======

[TIP]
====
Spring이 Spring Security의 메서드 보안 `@Configuration` 클래스를 초기화하기 전에 ``GrantedAuthorityDefaults``를 게시하도록 `static` 메서드를 사용하여 ``GrantedAuthorityDefaults``를 노출합니다.
====

[[authz-pre-invocation]]
== 호출 처리
Spring Security는 메서드 호출이나 웹 요청과 같은 보안 객체에 대한 접근을 제어하는 인터셉터를 제공합니다.
호출 진행 여부에 대한 사전 호출 결정은 ``AuthorizationManager`` 인스턴스에 의해 이루어집니다.
또한 주어진 값이 반환될 수 있는지에 대한 사후 호출 결정도 ``AuthorizationManager`` 인스턴스에 의해 이루어집니다.

=== AuthorizationManager
``AuthorizationManager``는 <<authz-legacy-note,``AccessDecisionManager``와 ``AccessDecisionVoter``>> 모두 대체합니다.

``AccessDecisionManager`` 또는 ``AccessDecisionVoter``를 사용자 정의하는 애플리케이션은 <<authz-voter-adaptation,``AuthorizationManager`` 사용으로 변경>>하는 것이 좋습니다.

``AuthorizationManager``는 Spring Security의 xref:servlet/authorization/authorize-http-requests.adoc[요청 기반], xref:servlet/authorization/method-security.adoc[메서드 기반], xref:servlet/integrations/websocket.adoc[메시지 기반] 권한 부여 컴포넌트에 의해 호출되며 최종 접근 제어 결정을 담당합니다.
``AuthorizationManager`` 인터페이스에는 두 가지 메서드가 있습니다:

[source,java]
----
AuthorizationDecision check(Supplier<Authentication> authentication, Object secureObject);

default void verify(Supplier<Authentication> authentication, Object secureObject)
        throws AccessDeniedException {
    // ...
}
----

``AuthorizationManager``의 ``check`` 메서드는 권한 부여 결정을 내리는 데 필요한 모든 관련 정보를 전달받습니다.
특히, 보안 ``Object``를 전달함으로써 실제 보안 객체 호출에 포함된 인수를 검사할 수 있습니다.
예를 들어, 보안 객체가 ``MethodInvocation``이라고 가정해 봅시다.
``MethodInvocation``에서 ``Customer`` 인수를 쉽게 쿼리할 수 있고, 그런 다음 ``AuthorizationManager``에서 주체가 해당 고객에 대해 작업할 수 있는 권한이 있는지 확인하는 보안 로직을 구현할 수 있습니다.
구현은 접근이 허용된 경우 허용된 ``AuthorizationDecision``을 반환하고, 접근이 거부된 경우 거부된 ``AuthorizationDecision``을 반환하며, 결정을 내리지 않을 때는 null ``AuthorizationDecision``을 반환해야 합니다.

``verify``는 ``check``를 호출하고 이후 접근이 거부된 ``AuthorizationDecision``인 경우 ``AccessDeniedException``을 던집니다.

[[authz-delegate-authorization-manager]]
=== 위임 기반 AuthorizationManager 구현
사용자가 권한 부여의 모든 측면을 제어하기 위해 자체 ``AuthorizationManager``를 구현할 수 있지만, Spring Security는 개별 ``AuthorizationManager``들과 협력할 수 있는 위임 ``AuthorizationManager``를 제공합니다.

``RequestMatcherDelegatingAuthorizationManager``는 요청을 가장 적절한 위임 ``AuthorizationManager``와 매치시킵니다.
메서드 보안의 경우 ``AuthorizationManagerBeforeMethodInterceptor``와 ``AuthorizationManagerAfterMethodInterceptor``를 사용할 수 있습니다.

<<authz-authorization-manager-implementations>>은 관련 클래스를 보여줍니다.

[[authz-authorization-manager-implementations]]
.Authorization Manager Implementations
image::{figures}/authorizationhierarchy.png[]

이 접근 방식을 사용하면 `AuthorizationManager` 구현의 구성을 권한 부여 결정에 대해 조사할 수 있습니다.

[[authz-authority-authorization-manager]]
==== AuthorityAuthorizationManager
Spring Security에서 제공하는 가장 일반적인 ``AuthorizationManager``는 ``AuthorityAuthorizationManager``입니다.
현재 ``Authentication``에서 찾을 권한 집합으로 구성됩니다.
``Authentication``이 구성된 권한 중 하나라도 포함하고 있으면 접근이 허용된 ``AuthorizationDecision``을 반환합니다.
그렇지 않으면 접근이 거부된 ``AuthorizationDecision``을 반환합니다.

[[authz-authenticated-authorization-manager]]
==== AuthenticatedAuthorizationManager
또 다른 관리자는 ``AuthenticatedAuthorizationManager``입니다.
이는 익명, 완전히 인증된, 그리고 remember-me 인증된 사용자를 구별하는 데 사용될 수 있습니다.
많은 사이트에서 remember-me 인증으로 제한된 접근을 허용하지만, 전체 접근을 위해서는 사용자가 로그인하여 신원을 확인해야 합니다.

[[authz-authorization-managers]]
==== AuthorizationManagers
{security-api-url}org/springframework/security/authorization/AuthorizationManagers.html[``AuthorizationManagers``]에는 개별 ``AuthorizationManager``들을 더 정교한 표현식으로 구성하기 위한 유용한 정적 팩토리들도 있습니다.

[[authz-custom-authorization-manager]]
==== 사용자 정의 Authorization Managers
당연히 사용자 정의 ``AuthorizationManager``를 구현할 수 있으며, 여기에 원하는 거의 모든 접근 제어 로직을 넣을 수 있습니다.
애플리케이션에 특화된(비즈니스 로직 관련) 것일 수도 있고 보안 관리 로직을 구현할 수도 있습니다.
예를 들어, Open Policy Agent나 자체 권한 부여 데이터베이스를 쿼리할 수 있는 구현을 만들 수 있습니다.

[TIP]
Spring 웹사이트에서 계정이 정지된 사용자의 접근을 실시간으로 거부하기 위해 레거시 ``AccessDecisionVoter``를 사용하는 방법을 설명하는 https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time[블로그 글]을 찾을 수 있습니다.
``AuthorizationManager``를 구현하여 동일한 결과를 얻을 수 있습니다.

[[authz-voter-adaptation]]
== AccessDecisionManager 및 AccessDecisionVoter 적응

`AuthorizationManager` 이전에 Spring Security는 <<authz-legacy-note,`AccessDecisionManager` 및 `AccessDecisionVoter`>>를 사용했습니다.

오래된 애플리케이션을 마이그레이션하는 경우와 같은 일부 경우에는 ``AccessDecisionManager`` 또는 ``AccessDecisionVoter``를 호출하는 ``AuthorizationManager``를 도입하는 것이 바람직할 수 있습니다.

기존 ``AccessDecisionManager``를 호출하려면 다음과 같이 할 수 있습니다:

.AccessDecisionManager 적용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class AccessDecisionManagerAuthorizationManagerAdapter implements AuthorizationManager {
    private final AccessDecisionManager accessDecisionManager;
    private final SecurityMetadataSource securityMetadataSource;

    @Override
    public AuthorizationDecision check(Supplier<Authentication> authentication, Object object) {
        try {
            Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);
            this.accessDecisionManager.decide(authentication.get(), object, attributes);
            return new AuthorizationDecision(true);
        } catch (AccessDeniedException ex) {
            return new AuthorizationDecision(false);
        }
    }

    @Override
    public void verify(Supplier<Authentication> authentication, Object object) {
        Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);
        this.accessDecisionManager.decide(authentication.get(), object, attributes);
    }
}
----
======

그런 다음 이를 ``SecurityFilterChain``에 연결합니다.

또는 ``AccessDecisionVoter``만 호출하려면 다음과 같이 할 수 있습니다:

.AccessDecisionVoter 적응
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Component
public class AccessDecisionVoterAuthorizationManagerAdapter implements AuthorizationManager {
    private final AccessDecisionVoter accessDecisionVoter;
    private final SecurityMetadataSource securityMetadataSource;

    @Override
    public AuthorizationDecision check(Supplier<Authentication> authentication, Object object) {
        Collection<ConfigAttribute> attributes = this.securityMetadataSource.getAttributes(object);
        int decision = this.accessDecisionVoter.vote(authentication.get(), object, attributes);
        switch (decision) {
        case ACCESS_GRANTED:
            return new AuthorizationDecision(true);
        case ACCESS_DENIED:
            return new AuthorizationDecision(false);
        }
        return null;
    }
}
----
======

그런 다음 이를 ``SecurityFilterChain``에 연결합니다.

[[authz-hierarchical-roles]]
== 계층적 역할
애플리케이션에서 특정 역할이 자동으로 다른 역할을 "포함"해야 하는 것은 일반적인 요구 사항입니다.
예를 들어, "admin"과 "user" 역할 개념이 있는 애플리케이션에서 admin이 일반 사용자가 할 수 있는 모든 것을 할 수 있기를 원할 수 있습니다.
이를 달성하기 위해 모든 admin 사용자에게 "user" 역할도 할당하도록 할 수 있습니다.
또는 "user" 역할이 필요한 모든 접근 제약 조건을 수정하여 "admin" 역할도 포함하도록 할 수 있습니다.
애플리케이션에 많은 다른 역할이 있는 경우 이는 매우 복잡해질 수 있습니다.

역할 계층의 사용은 어떤 역할(또는 권한)이 다른 역할을 포함해야 하는지 구성할 수 있게 합니다.
이는 ``HttpSecurity#authorizeHttpRequests``의 필터 기반 권한 부여와 메서드 기반 권한 부여를 위한 pre-post 주석의 ``DefaultMethodSecurityExpressionHandler``, ``@Secured``를 위한 ``SecuredAuthorizationManager``, 그리고 JSR-250 주석을 위한 ``Jsr250AuthorizationManager``에서 지원됩니다.
다음과 같은 방식으로 모든 것에 대한 동작을 한 번에 구성할 수 있습니다:

.계층적 역할 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
static RoleHierarchy roleHierarchy() {
    return RoleHierarchyImpl.withDefaultRolePrefix()
        .role("ADMIN").implies("STAFF")
        .role("STAFF").implies("USER")
        .role("USER").implies("GUEST")
        .build();
}

// 그리고 pre-post 메서드 보안을 사용하는 경우 다음도 추가
@Bean
static MethodSecurityExpressionHandler methodSecurityExpressionHandler(RoleHierarchy roleHierarchy) {
	DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
	expressionHandler.setRoleHierarchy(roleHierarchy);
	return expressionHandler;
}
----

Xml::
+
[source,java,role="secondary"]
----
<bean id="roleHierarchy"
		class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl" factory-method="fromHierarchy">
	<constructor-arg>
		<value>
			ROLE_ADMIN > ROLE_STAFF
			ROLE_STAFF > ROLE_USER
			ROLE_USER > ROLE_GUEST
		</value>
	</constructor-arg>
</bean>

<!-- 그리고 메서드 보안을 사용하는 경우 다음도 추가 -->
<bean id="methodSecurityExpressionHandler"
        class="org.springframework.security.access.expression.method.MethodSecurityExpressionHandler">
    <property ref="roleHierarchy"/>
</bean>
----
======

여기서는 ``ROLE_ADMIN => ROLE_STAFF => ROLE_USER => ROLE_GUEST``의 계층 구조로 네 가지 역할이 있습니다.
``ROLE_ADMIN``으로 인증된 사용자는 필터 기반 또는 메서드 기반 규칙에 대해 보안 제약 조건이 평가될 때 네 가지 역할을 모두 가진 것처럼 동작합니다.

[TIP]
`>` 기호는 "포함한다"는 의미로 생각할 수 있습니다.

역할 계층은 애플리케이션의 접근 제어 구성 데이터를 단순화하거나 사용자에게 할당해야 하는 권한의 수를 줄이는 편리한 방법을 제공합니다.
더 복잡한 요구 사항의 경우 애플리케이션에 필요한 특정 접근 권한과 사용자에게 할당된 역할 사이의 논리적 매핑을 정의하고, 사용자 정보를 로드할 때 둘 사이를 변환하는 것이 좋습니다.

[[authz-legacy-note]]
== 레거시 권한 부여 컴포넌트

[NOTE]
Spring Security에는 일부 레거시 컴포넌트가 포함되어 있습니다.
아직 제거되지 않았기 때문에 역사적인 목적으로 문서를 포함합니다.
위에서 권장된 대체품을 사용하는 것이 좋습니다.

[[authz-access-decision-manager]]
=== AccessDecisionManager
``AccessDecisionManager``는 ``AbstractSecurityInterceptor``에 의해 호출되며 최종 접근 제어 결정을 담당합니다.
``AccessDecisionManager`` 인터페이스에는 세 가지 메서드가 있습니다:

[source,java]
----
void decide(Authentication authentication, Object secureObject,
	Collection<ConfigAttribute> attrs) throws AccessDeniedException;

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);
----

``AccessDecisionManager``의 ``decide`` 메서드는 권한 부여 결정을 내리는 데 필요한 모든 관련 정보를 전달받습니다.
특히, 보안 ``Object``를 전달함으로써 실제 보안 객체 호출에 포함된 인수를 검사할 수 있습니다.
예를 들어, 보안 객체가 ``MethodInvocation``이라고 가정해 봅시다.
``MethodInvocation``에서 ``Customer`` 인수를 쿼리한 다음 ``AccessDecisionManager``에서 주체가 해당 고객에 대해 작업할 수 있는 권한이 있는지 확인하는 보안 로직을 구현할 수 있습니다.
구현은 접근이 거부된 경우 ``AccessDeniedException``을 throw해야 합니다.

``supports(ConfigAttribute)`` 메서드는 ``AbstractSecurityInterceptor``에 의해 시작 시 호출되어 ``AccessDecisionManager``가 전달된 ``ConfigAttribute``를 처리할 수 있는지 확인합니다.
``supports(Class)`` 메서드는 보안 인터셉터 구현에 의해 호출되어 구성된 ``AccessDecisionManager``가 보안 인터셉터가 제시하는 보안 객체 유형을 지원하는지 확인합니다.

[[authz-voting-based]]
=== 투표 기반 AccessDecisionManager 구현
사용자가 권한 부여의 모든 측면을 제어하기 위해 자체 ``AccessDecisionManager``를 구현할 수 있지만, Spring Security에는 투표를 기반으로 하는 여러 ``AccessDecisionManager`` 구현이 포함되어 있습니다.
<<authz-access-voting>>은 관련 클래스를 설명합니다.

다음 이미지는 `AccessDecisionManager` 인터페이스를 보여줍니다:

[[authz-access-voting]]
.투표 결정 관리자
image::{figures}/access-decision-voting.png[]

이 접근 방식을 사용하면 일련의 `AccessDecisionVoter` 구현이 권한 부여 결정에 대해 투표합니다.
그런 다음 ``AccessDecisionManager``는 투표 평가에 기반하여 ``AccessDeniedException``을 throw할지 여부를 결정합니다.

`AccessDecisionVoter` 인터페이스에는 세 가지 메서드가 있습니다:

[source,java]
----
int vote(Authentication authentication, Object object, Collection<ConfigAttribute> attrs);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);
----

구체적인 구현은 ``int``를 반환하며, 가능한 값은 ``AccessDecisionVoter`` 정적 필드인 ``ACCESS_ABSTAIN``, ``ACCESS_DENIED`` 및 ``ACCESS_GRANTED``에 반영됩니다.
투표 구현은 권한 부여 결정에 대한 의견이 없는 경우 ``ACCESS_ABSTAIN``을 반환합니다.
의견이 있는 경우 ``ACCESS_DENIED`` 또는 ``ACCESS_GRANTED`` 중 하나를 반환해야 합니다.

Spring Security는 투표를 집계하기 위해 세 가지 구체적인 `AccessDecisionManager` 구현을 제공합니다.
`ConsensusBased` 구현은 기권하지 않은 투표의 합의에 따라 접근을 허용하거나 거부합니다.
투표가 동점이거나 모든 투표가 기권인 경우의 동작을 제어하는 속성이 제공됩니다.
`AffirmativeBased` 구현은 하나 이상의 `ACCESS_GRANTED` 투표를 받은 경우 접근을 허용합니다(즉, 적어도 하나의 승인 투표가 있는 한 거부 투표는 무시됩니다).
`ConsensusBased` 구현과 마찬가지로 모든 투표자가 기권한 경우의 동작을 제어하는 매개변수가 있습니다.
`UnanimousBased` 제공자는 접근을 허용하기 위해 만장일치 `ACCESS_GRANTED` 투표를 기대하며, 기권을 무시합니다.
`ACCESS_DENIED` 투표가 있으면 접근을 거부합니다.
다른 구현과 마찬가지로 모든 투표자가 기권한 경우의 동작을 제어하는 매개변수가 있습니다.

투표를 다르게 집계하는 사용자 정의 ``AccessDecisionManager``를 구현할 수 있습니다.
예를 들어, 특정 ``AccessDecisionVoter``의 투표에 추가 가중치를 부여하거나 특정 투표자의 거부 투표가 거부권을 갖도록 할 수 있습니다.

[[authz-role-voter]]
==== RoleVoter
Spring Security에서 제공하는 가장 일반적으로 사용되는 ``AccessDecisionVoter``는 구성 속성을 역할 이름으로 취급하고 사용자에게 해당 역할이 할당된 경우 접근을 허용하는 투표를 하는 ``RoleVoter``입니다.

`ROLE_` 접두사로 시작하는 ``ConfigAttribute``가 있는 경우 투표합니다.
`ROLE_` 접두사로 시작하는 하나 이상의 ``ConfigAttribute``와 정확히 일치하는 `String` 표현(`getAuthority()` 메서드에서)을 반환하는 ``GrantedAuthority``가 있는 경우 접근을 허용하는 투표를 합니다.
`ROLE_`로 시작하는 ``ConfigAttribute``와 정확히 일치하는 것이 없으면 ``RoleVoter``는 접근을 거부하는 투표를 합니다.
`ROLE_`로 시작하는 ``ConfigAttribute``가 없으면 투표자는 기권합니다.

[[authz-authenticated-voter]]
==== AuthenticatedVoter
우리가 암묵적으로 보았던 또 다른 투표자는 ``AuthenticatedVoter``입니다. 이는 익명, 완전히 인증된, 그리고 remember-me 인증된 사용자를 구별하는 데 사용될 수 있습니다.
많은 사이트에서 remember-me 인증으로 제한된 접근을 허용하지만, 전체 접근을 위해서는 사용자가 로그인하여 신원을 확인해야 합니다.

`IS_AUTHENTICATED_ANONYMOUSLY` 속성을 사용하여 익명 접근을 허용했을 때, 이 속성은 ``AuthenticatedVoter``에 의해 처리되고 있었습니다.
자세한 내용은 {security-api-url}org/springframework/security/access/vote/AuthenticatedVoter.html[``AuthenticatedVoter``]를 참조하세요.

[[authz-custom-voter]]
==== 사용자 정의 Voter
사용자 정의 ``AccessDecisionVoter``를 구현하여 원하는 거의 모든 접근 제어 로직을 넣을 수 있습니다.
애플리케이션에 특화된(비즈니스 로직 관련) 것일 수도 있고 보안 관리 로직을 구현할 수도 있습니다.
예를 들어, Spring 웹사이트에서 계정이 정지된 사용자의 접근을 실시간으로 거부하기 위해 투표자를 사용하는 방법을 설명하는 https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time[블로그 글]을 찾을 수 있습니다.

[[authz-after-invocation]]
.호출 후 구현
image::{figures}/after-invocation.png[]

Spring Security의 다른 많은 부분과 마찬가지로 ``AfterInvocationManager``는 단일 구체적인 구현인 ``AfterInvocationProviderManager``를 가지고 있으며, 이는 ``AfterInvocationProvider`` 목록을 조사합니다.
각 ``AfterInvocationProvider``는 반환 객체를 수정하거나 ``AccessDeniedException``을 throw할 수 있습니다.
실제로 여러 제공자가 객체를 수정할 수 있으며, 이전 제공자의 결과가 목록의 다음 제공자에게 전달됩니다.

``AfterInvocationManager``를 사용하는 경우에도 ``MethodSecurityInterceptor``의 ``AccessDecisionManager``가 작업을 허용하도록 하는 구성 속성이 여전히 필요하다는 점에 유의하세요.
일반적인 Spring Security 포함 ``AccessDecisionManager`` 구현을 사용하는 경우, 특정 보안 메서드 호출에 대해 정의된 구성 속성이 없으면 각 ``AccessDecisionVoter``가 투표를 기권하게 됩니다.
그 결과, ``AccessDecisionManager`` 속성 "allowIfAllAbstainDecisions"가 ``false``인 경우 ``AccessDeniedException``이 throw됩니다.
이 잠재적인 문제를 피하려면 (i) "allowIfAllAbstainDecisions"를 ``true``로 설정하거나(일반적으로 권장되지 않음) 또는 (ii) ``AccessDecisionVoter``가 접근을 허용하는 투표를 할 최소한 하나의 구성 속성이 있는지 확인하면 됩니다.
후자의 (권장되는) 접근 방식은 일반적으로 ``ROLE_USER`` 또는 ``ROLE_AUTHENTICATED`` 구성 속성을 통해 달성됩니다.