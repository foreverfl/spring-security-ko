[[servlet-httpfirewall]]
= HttpFirewall
Spring Security에는 정의한 패턴을 들어오는 요청과 비교하여 요청 처리 방법을 결정하는 여러 영역이 있습니다.
이는 ``FilterChainProxy``가 요청을 어떤 필터 체인으로 전달할지 결정할 때와 ``FilterSecurityInterceptor``가 어떤 보안 제약 조건을 요청에 적용할지 결정할 때 발생합니다.
이 메커니즘과 정의한 패턴을 테스트할 때 사용되는 URL 값을 이해하는 것이 중요합니다.

서블릿 명세는 getter 메서드로 접근 가능하고 우리가 매칭하고자 하는 ``HttpServletRequest``의 여러 속성을 정의합니다.
이들은 `contextPath`, `servletPath`, `pathInfo`, 그리고 ``queryString``입니다.
Spring Security는 애플리케이션 내의 경로만 보호하는 데 관심이 있으므로 ``contextPath``는 무시됩니다.
불행히도, 서블릿 명세는 특정 요청 URI에 대해 ``servletPath``와 ``pathInfo``가 정확히 어떤 값을 포함해야 하는지 정의하지 않습니다.
예를 들어, URL의 각 경로 세그먼트는 https://www.ietf.org/rfc/rfc2396.txt[RFC 2396]에 정의된 대로 매개변수를 포함할 수 있습니다.
(브라우저가 쿠키를 지원하지 않을 때 `jsessionid` 매개변수가 세미콜론 뒤에 URL에 추가되는 것을 보셨을 겁니다.
하지만 RFC는 이러한 매개변수가 URL의 모든 경로 세그먼트에 존재할 수 있도록 허용합니다.)
명세는 이들이 ``servletPath``와 ``pathInfo`` 값에 포함되어야 하는지 명확히 명시하지 않으며, 다른 서블릿 컨테이너 간에 동작이 다릅니다.
경로 매개변수를 이 값들에서 제거하지 않는 컨테이너에 애플리케이션이 배포될 때, 공격자가 요청된 URL에 이들을 추가하여 패턴 매치가 예기치 않게 성공하거나 실패하도록 할 위험이 있습니다.
(원래 값은 요청이 ``FilterChainProxy``를 떠날 때 반환되므로 애플리케이션에서 여전히 사용 가능합니다.)
들어오는 URL의 다른 변형도 가능합니다.
예를 들어, 경로 순회 시퀀스(예: `/../`)나 여러 개의 연속된 슬래시(`//`)가 포함될 수 있으며, 이로 인해 패턴 매치가 실패할 수 있습니다.
일부 컨테이너는 서블릿 매핑을 수행하기 전에 이를 정규화하지만, 다른 컨테이너는 그렇지 않습니다.
이러한 문제로부터 보호하기 위해, ``FilterChainProxy``는 ``HttpFirewall`` 전략을 사용하여 요청을 확인하고 래핑합니다.
기본적으로 정규화되지 않은 요청은 자동으로 거부되며, 경로 매개변수와 중복 슬래시는 매칭 목적으로 제거됩니다.
(예를 들어, 원래 요청 경로가 ``/secure;hack=1/somefile.html;hack=2``인 경우 ``/secure/somefile.html``로 반환됩니다.)
따라서 ``FilterChainProxy``를 사용하여 보안 필터 체인을 관리하는 것이 필수적입니다.
``servletPath``와 ``pathInfo`` 값은 컨테이너에 의해 디코딩되므로, 애플리케이션은 세미콜론을 포함하는 유효한 경로를 가지지 않아야 합니다. 이러한 부분은 매칭 목적으로 제거되기 때문입니다.

앞서 언급했듯이, 기본 전략은 매칭에 Ant 스타일 경로를 사용하는 것이며, 대부분의 사용자에게 최선의 선택일 것입니다.
이 전략은 `AntPathRequestMatcher` 클래스에서 구현되며, Spring의 ``AntPathMatcher``를 사용하여 ``queryString``을 무시하고 연결된 ``servletPath``와 ``pathInfo``에 대해 대소문자를 구분하지 않는 패턴 매치를 수행합니다.

더 강력한 매칭 전략이 필요한 경우 정규 표현식을 사용할 수 있습니다.
이 경우 전략 구현은 ``RegexRequestMatcher``입니다.
자세한 정보는 이 클래스의 {security-api-url}/org/springframework/security/web/util/matcher/RegexRequestMatcher.html[Javadoc]을 참조하세요.

실제로는 웹 애플리케이션 수준에서 정의된 보안 제약 조건에 전적으로 의존하기보다는 서비스 계층에서 메서드 보안을 사용하여 애플리케이션 접근을 제어하는 것을 권장합니다.
URL은 변경될 수 있으며, 애플리케이션이 지원할 수 있는 모든 가능한 URL과 요청이 어떻게 조작될 수 있는지를 고려하는 것은 어렵습니다.
이해하기 쉬운 몇 가지 간단한 Ant 경로 사용으로 제한해야 합니다.
항상 접근을 거부하는 와일드카드(`/**` 또는 `**`)를 마지막에 정의하는 "기본적으로 거부" 접근 방식을 사용하려고 노력하세요.

서비스 계층에서 정의된 보안은 훨씬 더 강력하고 우회하기 어려우므로, Spring Security의 메서드 보안 옵션을 항상 활용해야 합니다.

``HttpFirewall``은 또한 HTTP 응답 헤더에서 새 줄 문자를 거부함으로써 https://www.owasp.org/index.php/HTTP_Response_Splitting[HTTP 응답 분할]을 방지합니다.

기본적으로 ``StrictHttpFirewall`` 구현이 사용됩니다.
이 구현은 악의적으로 보이는 요청을 거부합니다.
만약 이것이 여러분의 요구사항에 비해 너무 엄격하다면, 어떤 유형의 요청을 거부할지 사용자 정의할 수 있습니다.
하지만 이렇게 하면 애플리케이션이 공격에 노출될 수 있다는 점을 알고 진행하는 것이 중요합니다.
예를 들어, Spring MVC의 매트릭스 변수를 사용하고 싶다면 다음과 같은 구성을 사용할 수 있습니다:

.매트릭스 변수 허용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowSemicolon(true);
    return firewall;
}
----

XML::
+
[source,xml,role="secondary"]
----
<b:bean id="httpFirewall"
    class="org.springframework.security.web.firewall.StrictHttpFirewall"
    p:allowSemicolon="true"/>

<http-firewall ref="httpFirewall"/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowSemicolon(true)
    return firewall
}
----
======

https://www.owasp.org/index.php/Cross_Site_Tracing[Cross Site Tracing (XST)]와 https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)[HTTP 메서드 변조]로부터 보호하기 위해, ``StrictHttpFirewall``은 허용되는 유효한 HTTP 메서드의 허용 목록을 제공합니다.
기본 유효 메서드는 `DELETE`, `GET`, `HEAD`, `OPTIONS`, `PATCH`, `POST`, 그리고 ``PUT``입니다.
애플리케이션에서 유효한 메서드를 수정해야 하는 경우, 사용자 정의 `StrictHttpFirewall` 빈을 구성할 수 있습니다.
다음 예제는 HTTP ``GET``과 `POST` 메서드만 허용합니다:


.GET & POST만 허용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHttpMethods(Arrays.asList("GET", "POST"));
    return firewall;
}
----

XML::
+
[source,xml,role="secondary"]
----
<b:bean id="httpFirewall"
      class="org.springframework.security.web.firewall.StrictHttpFirewall"
      p:allowedHttpMethods="GET,POST"/>

<http-firewall ref="httpFirewall"/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHttpMethods(listOf("GET", "POST"))
    return firewall
}
----
======

[TIP]
====
``new MockHttpServletRequest()``를 사용하는 경우, 현재 빈 문자열(`""`)로 HTTP 메서드를 생성합니다.
이는 유효하지 않은 HTTP 메서드이며 Spring Security에 의해 거부됩니다.
이를 해결하려면 ``new MockHttpServletRequest("GET", "")``로 대체할 수 있습니다.
이 문제 개선을 요청하는 https://jira.spring.io/browse/SPR-16851[SPR_16851] 이슈를 참조하세요.
====

모든 HTTP 메서드를 허용해야 하는 경우(권장하지 않음), ``StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)``를 사용할 수 있습니다.
이렇게 하면 HTTP 메서드의 유효성 검사가 완전히 비활성화됩니다.


[[servlet-httpfirewall-headers-parameters]]
``StrictHttpFirewall``은 또한 헤더 이름과 값, 그리고 매개변수 이름을 검사합니다.
각 문자가 정의된 코드 포인트를 가지고 있고 제어 문자가 아닐 것을 요구합니다.

이 요구 사항은 필요에 따라 다음 메서드를 사용하여 완화하거나 조정할 수 있습니다:

* `StrictHttpFirewall#setAllowedHeaderNames(Predicate)`
* `StrictHttpFirewall#setAllowedHeaderValues(Predicate)`
* `StrictHttpFirewall#setAllowedParameterNames(Predicate)`

[NOTE]
====
매개변수 값은 ``setAllowedParameterValues(Predicate)``로도 제어할 수 있습니다.
====

예를 들어, 이 검사를 끄려면 항상 ``true``를 반환하는 ``Predicate`` 인스턴스로 ``StrictHttpFirewall``을 연결할 수 있습니다:

.모든 헤더 이름, 헤더 값, 매개변수 이름 허용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHeaderNames((header) -> true);
    firewall.setAllowedHeaderValues((header) -> true);
    firewall.setAllowedParameterNames((parameter) -> true);
    return firewall;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHeaderNames { true }
    firewall.setAllowedHeaderValues { true }
    firewall.setAllowedParameterNames { true }
    return firewall
}
----
======

또는 허용해야 하는 특정 값이 있을 수 있습니다.

예를 들어, iPhone Xʀ은 ISO-8859-1 문자셋에 없는 문자를 포함하는 ``User-Agent``를 사용합니다.
이로 인해 일부 애플리케이션 서버는 이 값을 두 개의 별도 문자로 파싱하며, 후자는 정의되지 않은 문자입니다.

이는 `setAllowedHeaderValues` 메서드로 해결할 수 있습니다:

.특정 User Agent 허용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    Pattern allowed = Pattern.compile("[\\p{IsAssigned}&&[^\\p{IsControl}]]*");
    Pattern userAgent = ...;
    firewall.setAllowedHeaderValues((header) -> allowed.matcher(header).matches() || userAgent.matcher(header).matches());
    return firewall;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    val allowed = Pattern.compile("[\\p{IsAssigned}&&[^\\p{IsControl}]]*")
    val userAgent = Pattern.compile(...)
    firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() }
    return firewall
}
----
======

헤더 값의 경우, 검증 시 UTF-8로 파싱하는 것을 고려할 수 있습니다:

.헤더를 UTF-8로 파싱
[tabs]
======
Java::
+
[source,java,role="primary"]
----
firewall.setAllowedHeaderValues((header) -> {
    String parsed = new String(header.getBytes(ISO_8859_1), UTF_8);
    return allowed.matcher(parsed).matches();
});
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
firewall.setAllowedHeaderValues {
    val parsed = String(header.getBytes(ISO_8859_1), UTF_8)
    return allowed.matcher(parsed).matches()
}
----
======