[[servlet-headers]]
= 보안 HTTP 응답 헤더

웹 애플리케이션의 보안을 강화하기 위해 xref:features/exploits/headers.adoc#headers[보안 HTTP 응답 헤더]를 사용할 수 있습니다.
이 섹션은 보안 HTTP 응답 헤더에 대한 서블릿 기반 지원을 다룹니다.

[[servlet-headers-default]]
== 기본 보안 헤더

Spring Security는 xref:features/exploits/headers.adoc#headers-default[기본 보안 HTTP 응답 헤더 세트]를 제공하여 안전한 기본값을 제공합니다.
이러한 각 헤더가 모범 사례로 간주되지만, 모든 클라이언트가 이 헤더를 사용하는 것은 아니므로 추가 테스트가 권장됩니다.

특정 헤더를 사용자 정의할 수 있습니다.
예를 들어, 기본값을 원하지만 <<servlet-headers-frame-options,X-Frame-Options>>에 대해 ``SAMEORIGIN``을 지정하고 싶다고 가정해 봅시다.

다음과 같은 구성으로 이를 수행할 수 있습니다:

.기본 보안 헤더 사용자 정의
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.frameOptions(frameOptions -> frameOptions
					.sameOrigin()
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options policy="SAMEORIGIN" />
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                frameOptions {
                    sameOrigin = true
                }
            }
        }
        return http.build()
    }
}
----
======

기본값을 추가하지 않고 사용할 항목을 명시적으로 제어하려면 기본값을 비활성화할 수 있습니다.
다음 코드는 이를 수행하는 방법을 보여줍니다.

Spring Security 구성을 사용하는 경우, 다음은 xref:features/exploits/headers.adoc#headers-cache-control[캐시 제어]만 추가합니다:

.캐시 제어 헤더 사용자 정의
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				// 명시적으로 나열되지 않은 경우 기본 헤더를 사용하지 않음
				.defaultsDisabled()
				.cacheControl(withDefaults())
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<cache-control/>
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                // 명시적으로 나열되지 않은 경우 기본 헤더를 사용하지 않음
                defaultsDisabled = true
                cacheControl {
                }
            }
        }
        return http.build()
    }
}
----
======

필요한 경우 다음 구성으로 모든 HTTP 보안 응답 헤더를 비활성화할 수 있습니다:

.모든 HTTP 보안 헤더 비활성화
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers.disable());
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers disabled="true" />
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                disable()
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-cache-control]]
== 캐시 제어

Spring Security는 기본적으로 xref:features/exploits/headers.adoc#headers-cache-control[캐시 제어] 헤더를 포함합니다.

그러나 특정 응답을 실제로 캐시하려면 애플리케이션에서 선택적으로 https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)[`HttpServletResponse.setHeader(String,String)`]를 호출하여 Spring Security가 설정한 헤더를 재정의할 수 있습니다.
이를 사용하여 콘텐츠(예: CSS, JavaScript 및 이미지)가 적절히 캐시되도록 할 수 있습니다.

Spring Web MVC를 사용할 때 이는 일반적으로 구성 내에서 수행됩니다.
이를 수행하는 방법에 대한 자세한 내용은 Spring 참조 문서의 https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources[정적 리소스] 섹션에서 찾을 수 있습니다.

필요한 경우 Spring Security의 캐시 제어 HTTP 응답 헤더를 비활성화할 수도 있습니다.

.캐시 제어 비활성화
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.cacheControl(cache -> cache.disable())
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<cache-control disabled="true"/>
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
       http {
            headers {
                cacheControl {
                    disable()
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-content-type-options]]
== 콘텐츠 타입 옵션

Spring Security는 기본적으로 xref:features/exploits/headers.adoc#headers-content-type-options[Content-Type] 헤더를 포함합니다.
하지만 이를 비활성화할 수 있습니다:

.콘텐츠 타입 옵션 비활성화
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.contentTypeOptions(contentTypeOptions -> contentTypeOptions.disable())
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<content-type-options disabled="true"/>
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
       http {
            headers {
                contentTypeOptions {
                    disable()
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-hsts]]
== HTTP 엄격 전송 보안 (HSTS)

기본적으로 Spring Security는 xref:features/exploits/headers.adoc#headers-hsts[엄격한 전송 보안] 헤더를 제공합니다.
그러나 결과를 명시적으로 사용자 정의할 수 있습니다.
다음 예제는 명시적으로 HSTS를 제공합니다:

.엄격한 전송 보안
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.httpStrictTransportSecurity(hsts -> hsts
					.includeSubDomains(true)
					.preload(true)
					.maxAgeInSeconds(31536000)
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<hsts
			include-subdomains="true"
			max-age-seconds="31536000"
			preload="true" />
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            headers {
                httpStrictTransportSecurity {
                    includeSubDomains = true
                    preload = true
                    maxAgeInSeconds = 31536000
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-hpkp]]
== HTTP 공개 키 고정 (HPKP)
Spring Security는 xref:features/exploits/headers.adoc#headers-hpkp[HTTP 공개 키 고정]에 대한 서블릿 지원을 제공하지만, 더 이상 xref:features/exploits/headers.adoc#headers-hpkp-deprecated[권장되지 않습니다].

다음 구성으로 HPKP 헤더를 활성화할 수 있습니다:

.HTTP 공개 키 고정
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.httpPublicKeyPinning(hpkp -> hpkp
					.includeSubDomains(true)
					.reportUri("https://example.net/pkp-report")
					.addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=")
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<hpkp
			include-subdomains="true"
			report-uri="https://example.net/pkp-report">
			<pins>
				<pin algorithm="sha256">d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=</pin>
				<pin algorithm="sha256">E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=</pin>
			</pins>
		</hpkp>
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            headers {
                httpPublicKeyPinning {
                    includeSubDomains = true
                    reportUri = "https://example.net/pkp-report"
                    pins = mapOf("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=" to "sha256",
                            "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=" to "sha256")
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-frame-options]]
== X-Frame-Options

기본적으로 Spring Security는 브라우저에게 xref:features/exploits/headers.adoc#headers-frame-options[X-Frame-Options]를 사용하여 반사된 XSS 공격을 차단하도록 지시합니다.

예를 들어, 다음 구성은 Spring Security가 더 이상 브라우저에게 콘텐츠를 차단하도록 지시하지 않도록 지정합니다:

.X-Frame-Options: SAMEORIGIN
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.frameOptions(frameOptions -> frameOptions
					.sameOrigin()
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options
		policy="SAMEORIGIN" />
	</headers>
</http>
----


Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            headers {
                frameOptions {
                    sameOrigin = true
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-xss-protection]]
== X-XSS-Protection

기본적으로 Spring Security는 <<headers-xss-protection,X-XSS-Protection 헤더>>를 사용하여 브라우저에게 XSS Auditor를 비활성화하도록 지시합니다.
하지만 이 기본값을 변경할 수 있습니다.
예를 들어, 다음 구성은 Spring Security가 호환되는 브라우저에게 필터링을 활성화하고 콘텐츠를 차단하도록 지시하도록 지정합니다:

.X-XSS-Protection 사용자 정의
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.xssProtection(xss -> xss
					.headerValue(XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK)
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<xss-protection headerValue="1; mode=block"/>
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        // ...
        http {
            headers {
                xssProtection {
                    headerValue = XXssProtectionHeaderWriter.HeaderValue.ENABLED_MODE_BLOCK
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-csp]]
== 콘텐츠 보안 정책 (CSP)

Spring Security는 기본적으로 xref:features/exploits/headers.adoc#headers-csp[콘텐츠 보안 정책]을 추가하지 않습니다. 애플리케이션의 맥락을 알지 못하면 합리적인 기본값을 알 수 없기 때문입니다.
웹 애플리케이션 작성자는 보호된 리소스에 대해 적용하거나 모니터링할 보안 정책(들)을 선언해야 합니다.

다음 보안 정책을 고려해 봅시다:

.콘텐츠 보안 정책 예시
[source,http]
----
Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
----

위의 보안 정책을 고려하여 CSP 헤더를 활성화할 수 있습니다:

.콘텐츠 보안 정책
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.contentSecurityPolicy(csp -> csp
					.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/" />
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                contentSecurityPolicy {
                    policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                }
            }
        }
        return http.build()
    }
}
----
======

CSP `report-only` 헤더를 활성화하려면 다음 구성을 제공하세요:

.콘텐츠 보안 정책 보고 전용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.contentSecurityPolicy(csp -> csp
					.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
					.reportOnly()
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
			report-only="true" />
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                contentSecurityPolicy {
                    policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                    reportOnly = true
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-referrer]]
== 리퍼러 정책

Spring Security는 기본적으로 xref:features/exploits/headers.adoc#headers-referrer[리퍼러 정책] 헤더를 추가하지 않습니다.
다음 구성을 사용하여 리퍼러 정책 헤더를 활성화할 수 있습니다:

.리퍼러 정책
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.referrerPolicy(referrer -> referrer
					.policy(ReferrerPolicy.SAME_ORIGIN)
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<referrer-policy policy="same-origin" />
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                referrerPolicy {
                    policy = ReferrerPolicy.SAME_ORIGIN
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-feature]]
== 기능 정책

Spring Security는 기본적으로 xref:features/exploits/headers.adoc#headers-feature[기능 정책] 헤더를 추가하지 않습니다.
다음 `Feature-Policy` 헤더를 고려해 보세요:

.Feature-Policy 예시
[source]
----
Feature-Policy: geolocation 'self'
----

위의 기능 정책 헤더를 다음 구성을 사용하여 활성화할 수 있습니다:

.Feature-Policy
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.featurePolicy("geolocation 'self'")
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<feature-policy policy-directives="geolocation 'self'" />
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                featurePolicy("geolocation 'self'")
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-permissions]]
== 권한 정책

Spring Security는 기본적으로 xref:features/exploits/headers.adoc#headers-permissions[권한 정책] 헤더를 추가하지 않습니다.
다음 `Permissions-Policy` 헤더를 고려해 보세요:

.Permissions-Policy 예시
[source]
----
Permissions-Policy: geolocation=(self)
----

위의 권한 정책 헤더를 다음 구성을 사용하여 활성화할 수 있습니다:

.Permissions-Policy
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.permissionsPolicy(permissions -> permissions
					.policy("geolocation=(self)")
				)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<permissions-policy policy="geolocation=(self)" />
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                permissionPolicy {
                    policy = "geolocation=(self)"
                }
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-clear-site-data]]
== 사이트 데이터 지우기

Spring Security는 기본적으로 xref:features/exploits/headers.adoc#headers-clear-site-data[Clear-Site-Data] 헤더를 추가하지 않습니다.
다음 Clear-Site-Data 헤더를 고려해 보세요:

.Clear-Site-Data 예시
----
Clear-Site-Data: "cache", "cookies"
----

로그아웃 시 위의 헤더를 다음 구성으로 전송할 수 있습니다:

.Clear-Site-Data
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.logout((logout) -> logout
                .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES)))
			);
		return http.build();
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            logout {
                addLogoutHandler(HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(CACHE, COOKIES)))
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-custom]]
== 사용자 정의 헤더
Spring Security는 애플리케이션에 더 일반적인 보안 헤더를 추가하는 편리한 메커니즘을 제공합니다.
그러나 사용자 정의 헤더를 추가할 수 있는 훅도 제공합니다.

[[servlet-headers-static]]
=== 정적 헤더
애플리케이션에 기본적으로 지원되지 않는 사용자 정의 보안 헤더를 주입하고 싶을 때가 있을 수 있습니다.
다음과 같은 사용자 정의 보안 헤더를 고려해 보세요:

[source]
----
X-Custom-Security-Header: header-value
----

위의 헤더를 다음 구성을 사용하여 응답에 추가할 수 있습니다:

.StaticHeadersWriter
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.addHeaderWriter(new StaticHeadersWriter("X-Custom-Security-Header","header-value"))
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<header name="X-Custom-Security-Header" value="header-value"/>
	</headers>
</http>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                addHeaderWriter(StaticHeadersWriter("X-Custom-Security-Header","header-value"))
            }
        }
        return http.build()
    }
}
----
======

[[servlet-headers-writer]]
=== 헤더 작성기
네임스페이스나 Java 구성이 원하는 헤더를 지원하지 않을 때, 사용자 정의 `HeadersWriter` 인스턴스를 생성하거나 ``HeadersWriter``의 사용자 정의 구현을 제공할 수 있습니다.

다음 예제는 사용자 정의 ``XFrameOptionsHeaderWriter`` 인스턴스를 사용합니다.
<<servlet-headers-frame-options>>를 명시적으로 구성하려면 다음과 같은 구성을 사용할 수 있습니다:

.헤더 작성기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers -> headers
				.addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<header ref="frameOptionsWriter"/>
	</headers>
</http>
<!-- c-namespace가 필요합니다.
https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace 참조
-->
<beans:bean id="frameOptionsWriter"
	class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"
	c:frameOptionsMode="SAMEORIGIN"/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            // ...
            headers {
                addHeaderWriter(XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
            }
        }
        return http.build()
    }
}
----
======

[[headers-delegatingrequestmatcherheaderwriter]]
=== DelegatingRequestMatcherHeaderWriter

때로는 특정 요청에 대해서만 헤더를 작성하고 싶을 수 있습니다.
예를 들어, 로그인 페이지만 프레임에 포함되지 않도록 보호하고 싶을 수 있습니다.
이를 위해 ``DelegatingRequestMatcherHeaderWriter``를 사용할 수 있습니다.

다음 구성 예제는 ``DelegatingRequestMatcherHeaderWriter``를 사용합니다:

.DelegatingRequestMatcherHeaderWriter Java 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig {

	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		RequestMatcher matcher = new AntPathRequestMatcher("/login");
		DelegatingRequestMatcherHeaderWriter headerWriter =
			new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
		http
			// ...
			.headers(headers -> headers
				.frameOptions(frameOptions -> frameOptions.disable())
				.addHeaderWriter(headerWriter)
			);
		return http.build();
	}
}
----

XML::
+
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options disabled="true"/>
		<header ref="headerWriter"/>
	</headers>
</http>

<beans:bean id="headerWriter"
	class="org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter">
	<beans:constructor-arg>
		<bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"
			c:pattern="/login"/>
	</beans:constructor-arg>
	<beans:constructor-arg>
		<beans:bean
			class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"/>
	</beans:constructor-arg>
</beans:bean>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Bean
    open fun filterChain(http: HttpSecurity): SecurityFilterChain {
        val matcher: RequestMatcher = AntPathRequestMatcher("/login")
        val headerWriter = DelegatingRequestMatcherHeaderWriter(matcher, XFrameOptionsHeaderWriter())
       http {
            headers {
                frameOptions {
                    disable()
                }
                addHeaderWriter(headerWriter)
            }
        }
        return http.build()
    }
}
----
======