[[servlet-hello]]
= Spring Security 시작하기

이 섹션에서는 {spring-boot-reference-url}[Spring Boot]와 함께 Spring Security를 사용하기 위한 최소한의 설정 방법을 다루고, 그 이후의 단계를 안내합니다.

[NOTE]
====
완성된 시작 애플리케이션은 {gh-samples-url}/servlet/spring-boot/java/hello-security[우리의 샘플 저장소]에서 찾을 수 있습니다.
편의를 위해, Spring Initializr에서 준비한 최소한의 Spring Boot + Spring Security 애플리케이션을 https://start.spring.io/starter.zip?type=maven-project&language=java&packaging=jar&jvmVersion=1.8&groupId=example&artifactId=hello-security&name=hello-security&description=Hello%20Security&packageName=example.hello-security&dependencies=web,security[여기서 다운로드]할 수 있습니다.
====

[[servlet-hello-dependencies]]
== 의존성 업데이트하기

먼저 Spring Security를 애플리케이션의 클래스패스에 추가해야 합니다. 이를 위한 두 가지 방법으로 xref:getting-spring-security.adoc#getting-maven-boot[Maven 사용하기] 또는 xref:getting-spring-security.adoc#getting-gradle-boot[Gradle 사용하기]가 있습니다.

[[servlet-hello-starting]]
== Hello Spring Security Boot 시작하기

Spring Security가 <<servlet-hello-dependencies,클래스패스에 있으면>>, 이제 {spring-boot-reference-url}#using.running-your-application[Spring Boot 애플리케이션을 실행]할 수 있습니다.
다음 스니펫은 Spring Security가 애플리케이션에서 활성화되었음을 나타내는 출력의 일부를 보여줍니다:

.Spring Boot 애플리케이션 실행하기
[tabs]
======
Maven::
+
[source,bash,role="primary"]
----
$ ./mvnw spring-boot:run
...
INFO 23689 --- [  restartedMain] .s.s.UserDetailsServiceAutoConfiguration :

Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336

...
----

Gradle::
+
[source,bash,role="secondary"]
----
$ ./gradlew :bootRun
...
INFO 23689 --- [  restartedMain] .s.s.UserDetailsServiceAutoConfiguration :

Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336

...
----

Jar::
+
[source,bash,role="secondary"]
----
$ java -jar target/myapplication-0.0.1.jar
...
INFO 23689 --- [  restartedMain] .s.s.UserDetailsServiceAutoConfiguration :

Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336

...
----
======

이제 실행 중인 애플리케이션이 있으니, 엔드포인트에 접근해 보면 어떤 일이 일어나는지 확인할 수 있습니다.
인증 정보 없이 엔드포인트에 접근하면 다음과 같은 결과가 나타납니다:

.보안이 적용된 Boot 애플리케이션 쿼리하기
[source,bash]
----
$ curl -i http://localhost:8080/some/path
HTTP/1.1 401
...
----

이 경우 Spring Security는 ``401 Unauthorized``로 접근을 거부합니다.

[TIP]
브라우저에서 같은 URL을 입력하면, 기본 로그인 페이지로 리다이렉트됩니다.

그리고 콘솔 출력에서 확인한 인증 정보를 사용하여 엔드포인트에 접근하면 다음과 같습니다:

.인증 정보를 사용한 쿼리
[source,bash]
----
$ curl -i -u user:8e557245-73e2-4286-969a-ff57fe326336 http://localhost:8080/some/path
HTTP/1.1 404
...
----

이 경우 Spring Boot가 요청을 처리하지만, `/some/path`가 존재하지 않으므로 `404 Not Found`를 반환합니다.

여기서 다음 단계로 나아갈 수 있습니다:

* <<servlet-hello-auto-configuration,Spring Boot가 Spring Security에서 기본적으로 활성화하는 기능>> 이해하기
* Spring Security가 도움이 되는 <<security-use-cases,일반적인 사용 사례>> 읽기
* xref:servlet/authentication/index.adoc[인증] 구성 시작하기

[[servlet-hello-auto-configuration]]
== 런타임 예상 동작

Spring Boot와 Spring Security의 기본 구성은 런타임에 다음과 같은 동작을 제공합니다:

* xref:servlet/authorization/authorize-http-requests.adoc[모든 엔드포인트]에 대해 인증된 사용자 요구 (Boot의 `/error` 엔드포인트 포함)
* 시작 시 생성된 비밀번호로 xref:servlet/authentication/passwords/user-details-service.adoc[기본 사용자 등록] (비밀번호는 콘솔에 기록됨. 앞의 예에서 비밀번호는 `8e557245-73e2-4286-969a-ff57fe326336`)
* BCrypt 및 기타 방식으로 xref:servlet/authentication/passwords/password-encoder.adoc[비밀번호 저장 보호]
* xref:servlet/authentication/passwords/form.adoc[로그인] 및 xref:servlet/authentication/logout.adoc[로그아웃]을 위한 폼 기반 플로우 제공
* xref:servlet/authentication/passwords/form.adoc[폼 기반 로그인] 및 xref:servlet/authentication/passwords/basic.adoc[HTTP Basic] 인증
* 콘텐츠 협상 제공. 웹 요청의 경우 로그인 페이지로 리다이렉트. 서비스 요청의 경우 `401 Unauthorized` 반환
* xref:servlet/exploits/csrf.adoc[CSRF 공격 완화]
* xref:servlet/authentication/session-management.adoc#ns-session-fixation[세션 고정 공격 완화]
* xref:servlet/exploits/headers.adoc#servlet-headers-hsts[Strict-Transport-Security] 작성으로 https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security[HTTPS 보장]
* xref:servlet/exploits/headers.adoc#servlet-headers-content-type-options[X-Content-Type-Options] 작성으로 https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-content-type-options[스니핑 공격 완화]
* 인증된 리소스를 보호하는 xref:servlet/exploits/headers.adoc#servlet-headers-cache-control[Cache Control 헤더] 작성
* xref:servlet/exploits/headers.adoc#servlet-headers-frame-options[X-Frame-Options] 작성으로 https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-frame-options[클릭재킹 완화]
* xref:servlet/integrations/servlet-api.adoc[``HttpServletRequest``의 인증 메서드]와 통합
* xref:servlet/authentication/events.adoc[인증 성공 및 실패 이벤트] 발행

Spring Boot가 이를 달성하기 위해 Spring Security와 어떻게 연동되는지 이해하는 것이 도움이 될 수 있습니다.
{spring-boot-api-url}org/springframework/boot/autoconfigure/security/servlet/SecurityAutoConfiguration.html[Boot의 보안 자동 구성]을 살펴보면, 다음과 같은 작업을 수행합니다 (설명을 위해 단순화됨):

.Spring Boot 보안 자동 구성
[source,java]
----
@EnableWebSecurity <1>
@Configuration
public class DefaultSecurityConfig {
    @Bean
    @ConditionalOnMissingBean(UserDetailsService.class)
    InMemoryUserDetailsManager inMemoryUserDetailsManager() { <2>
        String generatedPassword = // ...;
        return new InMemoryUserDetailsManager(User.withUsername("user")
                .password(generatedPassword).roles("USER").build());
    }

    @Bean
    @ConditionalOnMissingBean(AuthenticationEventPublisher.class)
    DefaultAuthenticationEventPublisher defaultAuthenticationEventPublisher(ApplicationEventPublisher delegate) { <3>
        return new DefaultAuthenticationEventPublisher(delegate);
    }
}
----
1. `@EnableWebSecurity` 어노테이션 추가 (다른 기능들 중에서, 이는 xref:servlet/architecture.adoc#servlet-securityfilterchain[Spring Security의 기본 `Filter` 체인]을 ``@Bean``으로 발행함)
2. 사용자 이름이 ``user``이고 무작위로 생성된 비밀번호(콘솔에 기록됨)를 가진 xref:servlet/authentication/passwords/user-details-service.adoc[`UserDetailsService`] ``@Bean`` 발행
3. 인증 이벤트를 발행하기 위한 xref:servlet/authentication/events.adoc[`AuthenticationEventPublisher`] ``@Bean`` 발행

[NOTE]
Spring Boot는 ``@Bean``으로 발행된 모든 ``Filter``를 애플리케이션의 필터 체인에 추가합니다.
이는 Spring Boot와 함께 ``@EnableWebSecurity``를 사용하면 모든 요청에 대해 자동으로 Spring Security의 필터 체인이 등록된다는 것을 의미합니다.

[[security-use-cases]]
== 보안 사용 사례

여기서 여러 가지 방향으로 나아갈 수 있습니다.
귀하와 귀하의 애플리케이션에 맞는 다음 단계를 찾기 위해, Spring Security가 해결하도록 설계된 다음과 같은 일반적인 사용 사례를 고려해보세요:

* REST API를 구축 중이며, xref:servlet/oauth2/resource-server/jwt.adoc[JWT를 인증]하거나 xref:servlet/oauth2/resource-server/opaque-token.adoc[다른 bearer 토큰을 인증]해야 합니다.
* 웹 애플리케이션, API 게이트웨이 또는 BFF를 구축 중이며:
** xref:servlet/oauth2/login/core.adoc[OAuth 2.0 또는 OIDC를 사용하여 로그인]해야 합니다.
** xref:servlet/saml2/login/index.adoc[SAML 2.0을 사용하여 로그인]해야 합니다.
** xref:servlet/authentication/cas.adoc[CAS를 사용하여 로그인]해야 합니다.
* 다음을 관리해야 합니다:
** xref:servlet/authentication/passwords/ldap.adoc[LDAP] 또는 xref:servlet/authentication/passwords/ldap.adoc#_active_directory[Active Directory], xref:servlet/integrations/data.adoc[Spring Data], 또는 xref:servlet/authentication/passwords/jdbc.adoc[JDBC]의 사용자
** xref:servlet/authentication/passwords/storage.adoc[비밀번호]

위의 사례들 중 귀하가 찾는 것이 없다면, 다음 순서로 애플리케이션을 고려해보세요:

1. *프로토콜*: 먼저, 애플리케이션이 통신에 사용할 프로토콜을 고려하세요.
서블릿 기반 애플리케이션의 경우, Spring Security는 HTTP와 xref:servlet/integrations/websocket.adoc[웹소켓]을 지원합니다.
2. *인증*: 다음으로, 사용자가 어떻게 xref:servlet/authentication/index.adoc[인증]할 것인지, 그리고 그 인증이 상태 유지인지 무상태인지 고려하세요.
3. *권한 부여*: 그 다음, xref:servlet/authorization/index.adoc[사용자가 수행할 수 있는 작업을 어떻게 결정할 것인지] 고려하세요.
4. *방어*: 마지막으로, xref:servlet/exploits/csrf.adoc#csrf-considerations[Spring Security의 기본 보호 기능과 통합]하고 xref:servlet/exploits/headers.adoc[어떤 추가 보호 기능이 필요한지] 고려하세요.