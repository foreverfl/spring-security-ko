[[servlet-cas]]
= CAS 인증

[[cas-overview]]
== 개요
JA-SIG는 CAS라고 알려진 엔터프라이즈급 단일 로그인 시스템을 제작했습니다.
다른 시스템들과 비교해, JA-SIG의 중앙 인증 서비스는 오픈 소스이며, 널리 사용되고, 이해하기 쉬우며, 플랫폼 독립적이고, 프록시 기능을 지원합니다.
Spring Security는 CAS를 완벽하게 지원하며, 단일 애플리케이션 배포에서 엔터프라이즈급 CAS 서버로 보안된 다중 애플리케이션 배포로의 쉬운 마이그레이션 경로를 제공합니다.

CAS에 대해 더 자세히 알아보려면 link:[https://www.apereo.org]를 방문하세요.
CAS 서버 파일을 다운로드하려면 이 사이트를 방문해야 합니다.

[[cas-how-it-works]]
== CAS 작동 방식
CAS 웹사이트에는 CAS 아키텍처를 상세히 설명하는 문서가 있지만, 여기서는 Spring Security의 맥락에서 다시 한 번 일반적인 개요를 제시합니다.
Spring Security 3.x는 CAS 3을 지원합니다.
이 글을 쓰는 시점에서 CAS 서버는 버전 3.4였습니다.

기업 내 어딘가에 CAS 서버를 설정해야 합니다.
CAS 서버는 단순히 표준 WAR 파일이므로 서버 설정에 어려움은 없습니다.
WAR 파일 내부에서 사용자에게 표시되는 로그인 및 기타 단일 로그인 페이지를 사용자 정의할 수 있습니다.

CAS 3.4 서버를 배포할 때는 CAS에 포함된 ``deployerConfigContext.xml``에 ``AuthenticationHandler``도 지정해야 합니다.
``AuthenticationHandler``는 주어진 자격 증명 세트가 유효한지에 대한 부울 값을 반환하는 간단한 메서드를 가지고 있습니다.
`AuthenticationHandler` 구현은 LDAP 서버나 데이터베이스와 같은 백엔드 인증 저장소와 연결되어야 합니다.
CAS 자체에는 이를 지원하기 위한 많은 ``AuthenticationHandler``가 포함되어 있습니다.
서버 war 파일을 다운로드하고 배포하면 사용자 이름과 일치하는 비밀번호를 입력한 사용자를 성공적으로 인증하도록 설정되어 있어 테스트에 유용합니다.

CAS 서버 자체 외에도 중요한 역할을 하는 것은 기업 전체에 배포된 보안 웹 애플리케이션입니다.
이러한 웹 애플리케이션을 "서비스"라고 합니다.
세 가지 유형의 서비스가 있습니다.
서비스 티켓을 인증하는 서비스, 프록시 티켓을 얻을 수 있는 서비스, 그리고 프록시 티켓을 인증하는 서비스입니다.
프록시 티켓을 인증하는 것은 프록시 목록을 검증해야 하고 종종 프록시 티켓을 재사용할 수 있기 때문에 다릅니다.

[[cas-sequence]]
=== Spring Security와 CAS 상호 작용 순서
웹 브라우저, CAS 서버, Spring Security로 보안된 서비스 간의 기본 상호 작용은 다음과 같습니다:

* 웹 사용자가 서비스의 공개 페이지를 탐색합니다. CAS나 Spring Security는 관여하지 않습니다.
* 사용자가 결국 보안이 적용된 페이지나 보안이 적용된 빈을 사용하는 페이지를 요청합니다. Spring Security의 ``ExceptionTranslationFilter``가 ``AccessDeniedException`` 또는 ``AuthenticationException``을 감지합니다.
* 사용자의 `Authentication` 객체(또는 그 부재)가 ``AuthenticationException``을 발생시켰기 때문에, ``ExceptionTranslationFilter``는 구성된 ``AuthenticationEntryPoint``를 호출합니다. CAS를 사용하는 경우 이는 `CasAuthenticationEntryPoint` 클래스가 됩니다.
* ``CasAuthenticationEntryPoint``는 사용자의 브라우저를 CAS 서버로 리다이렉트합니다. 또한 Spring Security 서비스(귀하의 애플리케이션)의 콜백 URL인 ``service`` 파라미터를 지정합니다. 예를 들어, 브라우저가 리다이렉트되는 URL은 https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas 일 수 있습니다.
* 사용자의 브라우저가 CAS로 리다이렉트된 후, 사용자는 사용자 이름과 비밀번호를 입력하라는 메시지를 받습니다. 사용자가 이전에 로그인했음을 나타내는 세션 쿠키를 제시하면 다시 로그인하라는 메시지가 표시되지 않습니다(이 절차에는 예외가 있으며 나중에 다룰 것입니다). CAS는 위에서 논의한 ``PasswordHandler``(또는 CAS 3.0을 사용하는 경우 ``AuthenticationHandler``)를 사용하여 사용자 이름과 비밀번호가 유효한지 결정합니다.
* 로그인에 성공하면 CAS는 사용자의 브라우저를 원래 서비스로 다시 리다이렉트합니다. 또한 "서비스 티켓"을 나타내는 불투명한 문자열인 `ticket` 파라미터를 포함합니다. 앞선 예를 계속하면 브라우저가 리다이렉트되는 URL은 https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ 일 수 있습니다.
* 서비스 웹 애플리케이션으로 돌아가서 ``CasAuthenticationFilter``는 항상 ``/login/cas``에 대한 요청을 수신 대기합니다(이는 구성 가능하지만 이 소개에서는 기본값을 사용합니다). 처리 필터는 서비스 티켓을 나타내는 ``UsernamePasswordAuthenticationToken``을 구성합니다. 주체는 ``CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER``와 동일하며, 자격 증명은 서비스 티켓의 불투명한 값입니다. 이 인증 요청은 그 다음 구성된 ``AuthenticationManager``에 전달됩니다.
* `AuthenticationManager` 구현은 ``ProviderManager``가 되며, 이는 차례로 ``CasAuthenticationProvider``로 구성됩니다. ``CasAuthenticationProvider``는 CAS 특정 주체(예: `CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER`)를 포함하는 ``UsernamePasswordAuthenticationToken``과 ``CasAuthenticationToken``(나중에 논의됨)에만 응답합니다.
* ``CasAuthenticationProvider``는 ``TicketValidator`` 구현을 사용하여 서비스 티켓을 검증합니다. 이는 일반적으로 CAS 클라이언트 라이브러리에 포함된 클래스 중 하나인 ``Cas20ServiceTicketValidator``입니다. 애플리케이션이 프록시 티켓을 검증해야 하는 경우 ``Cas20ProxyTicketValidator``가 사용됩니다. ``TicketValidator``는 서비스 티켓을 검증하기 위해 CAS 서버에 HTTPS 요청을 합니다. 프록시 콜백 URL도 포함할 수 있으며, 이 예에서는 다음과 같습니다: https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&ticket=ST-0-ER94xMJmn6pha35CQRoZ&pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor.
* CAS 서버에서 검증 요청을 받습니다. 제시된 서비스 티켓이 티켓이 발급된 서비스 URL과 일치하면 CAS는 사용자 이름을 나타내는 긍정적인 응답을 XML로 제공합니다. 인증에 프록시가 관여한 경우(아래에서 논의됨) 프록시 목록도 XML 응답에 포함됩니다.
* [선택사항] CAS 검증 서비스에 대한 요청에 프록시 콜백 URL이 포함된 경우(`pgtUrl` 파라미터), CAS는 XML 응답에 `pgtIou` 문자열을 포함합니다. 이 ``pgtIou``는 프록시 부여 티켓 IOU를 나타냅니다. 그런 다음 CAS 서버는 `pgtUrl`로 자체 HTTPS 연결을 생성합니다. 이는 CAS 서버와 주장된 서비스 URL을 상호 인증하기 위한 것입니다. HTTPS 연결은 원래 웹 애플리케이션에 프록시 부여 티켓을 보내는 데 사용됩니다. 예: https://server3.company.com/webapp/login/cas/proxyreceptor?pgtIou=PGTIOU-0-R0zlgrl4pdAQwBvJWO3vnNpevwqStbSGcq3vKB2SqSFFRnjPHt&pgtId=PGT-1-si9YkkHLrtACBo64rmsi3v2nf7cpCResXg5MpESZFArbaZiOKH.
* ``Cas20TicketValidator``는 CAS 서버로부터 받은 XML을 파싱합니다. 사용자 이름(필수), 프록시 목록(있는 경우), 프록시 부여 티켓 IOU(프록시 콜백이 요청된 경우)를 포함하는 ``TicketResponse``를 ``CasAuthenticationProvider``에 반환합니다.
* 다음으로 ``CasAuthenticationProvider``는 구성된 ``CasProxyDecider``를 호출합니다. ``CasProxyDecider``는 ``TicketResponse``의 프록시 목록이 서비스에 허용 가능한지를 나타냅니다. Spring Security는 여러 구현을 제공합니다: `RejectProxyTickets`, `AcceptAnyCasProxy`, `NamedCasProxyDecider`. 이 이름들은 대부분 자명하지만, ``NamedCasProxyDecider``는 신뢰할 수 있는 프록시의 `List`를 제공할 수 있습니다.
* ``CasAuthenticationProvider``는 다음으로 ``AuthenticationUserDetailsService``에 ``Assertion``에 포함된 사용자에게 적용되는 `GrantedAuthority` 객체를 로드하도록 요청합니다.
* 문제가 없었다면, ``CasAuthenticationProvider``는 ``TicketResponse``에 포함된 세부 정보와 ``GrantedAuthority``를 포함하는 ``CasAuthenticationToken``을 구성합니다.
* 그런 다음 제어권이 ``CasAuthenticationFilter``로 돌아가고, 이는 생성된 ``CasAuthenticationToken``을 보안 컨텍스트에 배치합니다.
* 사용자의 브라우저는 ``AuthenticationException``을 발생시킨 원래 페이지로 리다이렉트됩니다(또는 구성에 따라 사용자 정의 목적지로).

여기까지 잘 따라오셨군요! 이제 이것이 어떻게 구성되는지 살펴보겠습니다.

[[cas-client]]
== CAS 클라이언트 구성
Spring Security 덕분에 CAS의 웹 애플리케이션 측은 쉽게 구성할 수 있습니다.
Spring Security 사용의 기본 사항을 이미 알고 있다고 가정하므로 아래에서 다시 다루지 않습니다.
네임스페이스 기반 구성을 사용하고 필요에 따라 CAS 빈을 추가한다고 가정하겠습니다.
각 섹션은 이전 섹션을 기반으로 합니다.
전체 CAS 샘플 애플리케이션은 Spring Security xref:samples.adoc#samples[샘플]에서 찾을 수 있습니다.

[[cas-st]]
=== 서비스 티켓 인증
이 섹션에서는 서비스 티켓을 인증하도록 Spring Security를 설정하는 방법을 설명합니다.
이는 대부분의 경우 웹 애플리케이션이 필요로 하는 전부입니다.
애플리케이션 컨텍스트에 `ServiceProperties` 빈을 추가해야 합니다.
이는 CAS 서비스를 나타냅니다:

[source,xml]
----
<bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties">
<property name="service"
	value="https://localhost:8443/cas-sample/login/cas"/>
<property name="sendRenew" value="false"/>
</bean>
----

``service``는 ``CasAuthenticationFilter``가 모니터링할 URL과 같아야 합니다.
``sendRenew``는 기본적으로 false이지만, 애플리케이션이 특별히 민감한 경우 true로 설정해야 합니다.
이 매개변수는 단일 로그인이 허용되지 않음을 CAS 로그인 서비스에 알립니다.
대신, 사용자는 서비스에 접근하기 위해 사용자 이름과 비밀번호를 다시 입력해야 합니다.

다음 빈들은 CAS 인증 프로세스를 시작하도록 구성되어야 합니다(네임스페이스 구성을 사용한다고 가정):

[source,xml]
----
<security:http entry-point-ref="casEntryPoint">
...
<security:custom-filter position="CAS_FILTER" ref="casFilter" />
</security:http>

<bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter">
<property name="authenticationManager" ref="authenticationManager"/>
</bean>

<bean id="casEntryPoint"
	class="org.springframework.security.cas.web.CasAuthenticationEntryPoint">
<property name="loginUrl" value="https://localhost:9443/cas/login"/>
<property name="serviceProperties" ref="serviceProperties"/>
</bean>
----

CAS가 작동하려면 ``ExceptionTranslationFilter``의 `authenticationEntryPoint` 속성이 `CasAuthenticationEntryPoint` 빈으로 설정되어야 합니다.
이는 위 예제에서처럼 xref:servlet/appendix/namespace/http.adoc#nsa-http-entry-point-ref[entry-point-ref]를 사용하여 쉽게 할 수 있습니다.
``CasAuthenticationEntryPoint``는 기업의 CAS 로그인 서버 URL을 제공하는 `ServiceProperties` 빈(위에서 논의됨)을 참조해야 합니다.
사용자의 브라우저가 리다이렉트될 곳입니다.

``CasAuthenticationFilter``는 ``UsernamePasswordAuthenticationFilter``(폼 기반 로그인에 사용됨)와 매우 유사한 속성을 가집니다.
이러한 속성을 사용하여 인증 성공 및 실패 시 동작과 같은 것들을 사용자 정의할 수 있습니다.

다음으로 ``CasAuthenticationProvider``와 그 협력자를 추가해야 합니다:

[source,xml,attrs="-attributes"]
----
<security:authentication-manager alias="authenticationManager">
<security:authentication-provider ref="casAuthenticationProvider" />
</security:authentication-manager>

<bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
<property name="authenticationUserDetailsService">
	<bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper">
	<constructor-arg ref="userService" />
	</bean>
</property>
<property name="serviceProperties" ref="serviceProperties" />
<property name="ticketValidator">
	<bean class="org.apereo.cas.client.validation.Cas20ServiceTicketValidator">
	<constructor-arg index="0" value="https://localhost:9443/cas" />
	</bean>
</property>
<property name="key" value="an_id_for_this_auth_provider_only"/>
</bean>

<security:user-service id="userService">
<!-- 비밀번호 앞에 {noop}를 붙여 DelegatingPasswordEncoder에게
NoOpPasswordEncoder를 사용해야 함을 나타냅니다.
이는 프로덕션에서는 안전하지 않지만 샘플을 읽기 쉽게 만듭니다.
일반적으로 비밀번호는 BCrypt로 해시되어야 합니다 -->
<security:user name="joe" password="{noop}joe" authorities="ROLE_USER" />
...
</security:user-service>
----

``CasAuthenticationProvider``는 CAS에 의해 인증된 후 사용자의 권한을 로드하기 위해 `UserDetailsService` 인스턴스를 사용합니다.
여기서는 간단한 인메모리 설정을 보여주었습니다.
``CasAuthenticationProvider``는 실제로 인증에 비밀번호를 사용하지 않지만, 권한은 사용한다는 점에 유의하세요.

<<cas-how-it-works,CAS 작동 방식>> 섹션을 참조하면 빈들이 모두 합리적으로 자명합니다.

이것으로 CAS에 대한 가장 기본적인 구성이 완료됩니다.
실수를 하지 않았다면 웹 애플리케이션은 CAS 단일 로그온 프레임워크 내에서 잘 작동할 것입니다.
Spring Security의 다른 부분은 CAS가 인증을 처리했다는 사실에 대해 신경 쓸 필요가 없습니다.
다음 섹션에서는 (선택적인) 더 고급 구성에 대해 논의하겠습니다.

[[cas-singlelogout]]
=== 단일 로그아웃
CAS 프로토콜은 단일 로그아웃을 지원하며 Spring Security 구성에 쉽게 추가할 수 있습니다.
아래는 단일 로그아웃을 처리하는 Spring Security 구성 업데이트입니다.

[source,xml]
----
<security:http entry-point-ref="casEntryPoint">
...
<security:logout logout-success-url="/cas-logout.jsp"/>
<security:custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/>
<security:custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/>
</security:http>

<!-- 이 필터는 CAS 서버로부터의 단일 로그아웃 요청을 처리합니다 -->
<bean id="singleLogoutFilter" class="org.apereo.cas.client.session.SingleSignOutFilter"/>

<!-- 이 필터는 단일 로그아웃을 수행해야 함을 CAS 서버에 알리기 위해 리다이렉트합니다 -->
<bean id="requestSingleLogoutFilter"
	class="org.springframework.security.web.authentication.logout.LogoutFilter">
<constructor-arg value="https://localhost:9443/cas/logout"/>
<constructor-arg>
	<bean class=
		"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/>
</constructor-arg>
<property name="filterProcessesUrl" value="/logout/cas"/>
</bean>
----

`logout` 요소는 사용자를 로컬 애플리케이션에서 로그아웃시키지만, CAS 서버나 로그인한 다른 애플리케이션과의 세션을 종료하지는 않습니다.
`requestSingleLogoutFilter` 필터는 `/spring_security_cas_logout` URL을 요청하여 애플리케이션을 구성된 CAS 서버 로그아웃 URL로 리다이렉트할 수 있게 합니다.
그러면 CAS 서버는 로그인한 모든 서비스에 단일 로그아웃 요청을 보냅니다.
``singleLogoutFilter``는 정적 ``Map``에서 ``HttpSession``을 조회한 다음 무효화하여 단일 로그아웃 요청을 처리합니다.

`logout` 요소와 ``singleLogoutFilter``가 모두 필요한 이유가 혼란스러울 수 있습니다.
``SingleSignOutFilter``가 ``HttpSession``을 무효화하기 위해 정적 ``Map``에 저장하기 때문에 로컬에서 먼저 로그아웃하는 것이 최선의 방법으로 간주됩니다.
위의 구성에서 로그아웃 흐름은 다음과 같습니다:

* 사용자가 ``/logout``을 요청하면 로컬 애플리케이션에서 사용자를 로그아웃시키고 로그아웃 성공 페이지로 보냅니다.
* 로그아웃 성공 페이지인 `/cas-logout.jsp`는 모든 애플리케이션에서 로그아웃하기 위해 ``/logout/cas``를 가리키는 링크를 클릭하도록 사용자에게 지시해야 합니다.
* 사용자가 링크를 클릭하면 CAS 단일 로그아웃 URL(link:[https://localhost:9443/cas/logout])로 리다이렉트됩니다.
* CAS 서버 측에서 CAS 단일 로그아웃 URL은 모든 CAS 서비스에 단일 로그아웃 요청을 제출합니다. CAS 서비스 측에서 Apereo의 ``SingleSignOutFilter``가 원래 세션을 무효화하여 로그아웃 요청을 처리합니다.

다음 단계는 web.xml에 다음을 추가하는 것입니다:

[source,xml]
----
<filter>
<filter-name>characterEncodingFilter</filter-name>
<filter-class>
	org.springframework.web.filter.CharacterEncodingFilter
</filter-class>
<init-param>
	<param-name>encoding</param-name>
	<param-value>UTF-8</param-value>
</init-param>
</filter>
<filter-mapping>
<filter-name>characterEncodingFilter</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>
<listener>
<listener-class>
	org.apereo.cas.client.session.SingleSignOutHttpSessionListener
</listener-class>
</listener>
----

SingleSignOutFilter를 사용할 때 인코딩 문제가 발생할 수 있습니다.
따라서 SingleSignOutFilter를 사용할 때 문자 인코딩이 올바른지 확인하기 위해 ``CharacterEncodingFilter``를 추가하는 것이 좋습니다.
자세한 내용은 Apereo CAS의 문서를 참조하세요.
``SingleSignOutHttpSessionListener``는 ``HttpSession``이 만료될 때 단일 로그아웃에 사용되는 매핑이 제거되도록 합니다.

[[cas-pt-client]]
=== CAS를 사용하여 상태 비저장 서비스에 인증하기
이 섹션에서는 CAS를 사용하여 서비스에 인증하는 방법을 설명합니다.
다시 말해, 이 섹션에서는 CAS로 인증하는 서비스를 사용하는 클라이언트를 설정하는 방법을 설명합니다.
다음 섹션에서는 CAS를 사용하여 인증하는 상태 비저장 서비스를 설정하는 방법을 설명합니다.

[[cas-pt-client-config]]
==== 프록시 부여 티켓을 얻기 위한 CAS 구성
상태 비저장 서비스에 인증하기 위해 애플리케이션은 프록시 부여 티켓(PGT)을 얻어야 합니다.
이 섹션에서는 thencas-st[서비스 티켓 인증] 구성을 기반으로 PGT를 얻기 위해 Spring Security를 구성하는 방법을 설명합니다.

첫 번째 단계는 Spring Security 구성에 ``ProxyGrantingTicketStorage``를 포함하는 것입니다.
이는 ``CasAuthenticationFilter``가 얻은 PGT를 저장하여 프록시 티켓을 얻는 데 사용할 수 있도록 하는 데 사용됩니다.
예제 구성은 다음과 같습니다:

[source,xml]
----
<!--
참고: 실제 애플리케이션에서는 인메모리 구현을 사용해서는 안 됩니다.
또한 ProxyGrantingTicketStorage.cleanup()을 호출하여
만료된 티켓을 정리해야 합니다
-->
<bean id="pgtStorage" class="org.apereo.cas.client.proxy.ProxyGrantingTicketStorageImpl"/>
----

다음 단계는 프록시 티켓을 얻을 수 있도록 ``CasAuthenticationProvider``를 업데이트하는 것입니다.
이를 위해 ``Cas20ServiceTicketValidator``를 ``Cas20ProxyTicketValidator``로 교체합니다.
``proxyCallbackUrl``은 애플리케이션이 PGT를 받을 URL로 설정해야 합니다.
마지막으로, 구성은 PGT를 사용하여 프록시 티켓을 얻을 수 있도록 ``ProxyGrantingTicketStorage``를 참조해야 합니다.
아래에서 필요한 구성 변경의 예를 찾을 수 있습니다.

[source,xml]
----
<bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
...
<property name="ticketValidator">
	<bean class="org.apereo.cas.client.validation.Cas20ProxyTicketValidator">
	<constructor-arg value="https://localhost:9443/cas"/>
		<property name="proxyCallbackUrl"
		value="https://localhost:8443/cas-sample/login/cas/proxyreceptor"/>
	<property name="proxyGrantingTicketStorage" ref="pgtStorage"/>
	</bean>
</property>
</bean>
----

마지막 단계는 PGT를 수락하고 ``ProxyGrantingTicketStorage``에 저장하도록 ``CasAuthenticationFilter``를 업데이트하는 것입니다.
``proxyReceptorUrl``이 ``Cas20ProxyTicketValidator``의 ``proxyCallbackUrl``과 일치하는 것이 중요합니다.
예제 구성은 다음과 같습니다.

[source,xml]
----

<bean id="casFilter"
		class="org.springframework.security.cas.web.CasAuthenticationFilter">
	...
	<property name="proxyGrantingTicketStorage" ref="pgtStorage"/>
	<property name="proxyReceptorUrl" value="/login/cas/proxyreceptor"/>
</bean>

----

[[cas-pt-client-sample]]
==== 프록시 티켓을 사용하여 상태 비저장 서비스 호출하기
이제 Spring Security가 PGT를 얻었으므로, 이를 사용하여 상태 비저장 서비스 인증에 사용할 수 있는 프록시 티켓을 생성할 수 있습니다.
CAS xref:samples.adoc#samples[샘플 애플리케이션]에는 ``ProxyTicketSampleServlet``에 작동하는 예제가 포함되어 있습니다.
예제 코드는 다음과 같습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
protected void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException {
// 참고: CasAuthenticationToken은 SecurityContextHolder.getContext().getAuthentication()을
// 사용하여 얻을 수도 있습니다
final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();
// proxyTicket은 대상 URL이 다르더라도 CAS 서비스 호출에 재사용될 수 있습니다
final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);

// 프록시 티켓을 사용하여 원격 호출 수행
final String serviceUrl = targetUrl+"?ticket="+URLEncoder.encode(proxyTicket, "UTF-8");
String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8");
...
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
protected fun doGet(request: HttpServletRequest, response: HttpServletResponse?) {
    // 참고: CasAuthenticationToken은 SecurityContextHolder.getContext().getAuthentication()을
    // 사용하여 얻을 수도 있습니다
    val token = request.userPrincipal as CasAuthenticationToken
    // proxyTicket은 대상 URL이 다르더라도 CAS 서비스 호출에 재사용될 수 있습니다
    val proxyTicket = token.assertion.principal.getProxyTicketFor(targetUrl)

    // 프록시 티켓을 사용하여 원격 호출 수행
    val serviceUrl: String = targetUrl + "?ticket=" + URLEncoder.encode(proxyTicket, "UTF-8")
    val proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8")
}
----
======

[[cas-pt]]
=== 프록시 티켓 인증
``CasAuthenticationProvider``는 상태 유지 클라이언트와 상태 비저장 클라이언트를 구분합니다.
상태 유지 클라이언트는 ``CasAuthenticationFilter``의 ``filterProcessesUrl``에 제출하는 모든 것으로 간주됩니다.
상태 비저장 클라이언트는 ``filterProcessesUrl`` 이외의 URL에서 ``CasAuthenticationFilter``에 인증 요청을 제시하는 모든 것입니다.

원격 프로토콜은 ``HttpSession`` 컨텍스트 내에서 자신을 제시할 방법이 없기 때문에, 요청 간에 보안 컨텍스트를 세션에 저장하는 기본 관행에 의존할 수 없습니다.
더욱이 CAS 서버가 ``TicketValidator``에 의해 티켓이 검증된 후 티켓을 무효화하기 때문에, 후속 요청에서 동일한 프록시 티켓을 제시하는 것은 작동하지 않습니다.

한 가지 명백한 옵션은 원격 프로토콜 클라이언트에 대해 CAS를 전혀 사용하지 않는 것입니다.
그러나 이는 CAS의 많은 바람직한 기능을 제거할 것입니다.
중간 지점으로, ``CasAuthenticationProvider``는 ``StatelessTicketCache``를 사용합니다.
이는 ``CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER``와 동일한 주체를 사용하는 상태 비저장 클라이언트에만 사용됩니다.
``CasAuthenticationProvider``는 결과로 얻은 ``CasAuthenticationToken``을 프록시 티켓을 키로 사용하여 ``StatelessTicketCache``에 저장합니다.
따라서 원격 프로토콜 클라이언트는 동일한 프록시 티켓을 제시할 수 있으며 ``CasAuthenticationProvider``는 (첫 번째 요청을 제외하고) CAS 서버에 연락하여 검증할 필요가 없습니다.
인증되면 프록시 티켓은 원래 대상 서비스 이외의 URL에 사용될 수 있습니다.

이 섹션은 이전 섹션을 기반으로 하여 프록시 티켓 인증을 수용합니다.
첫 번째 단계는 모든 아티팩트를 인증하도록 지정하는 것입니다. 아래와 같이 설정합니다.

[source,xml]
----
<bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties">
...
<property name="authenticateAllArtifacts" value="true"/>
</bean>
----

다음 단계는 ``CasAuthenticationFilter``에 대한 ``serviceProperties``와 ``authenticationDetailsSource``를 지정하는 것입니다.
`serviceProperties` 속성은 ``CasAuthenticationFilter``에게 ``filterProcessesUrl``에 있는 아티팩트만이 아닌 모든 아티팩트를 인증하려고 시도하도록 지시합니다.
``ServiceAuthenticationDetailsSource``는 티켓을 검증할 때 ``HttpServletRequest``를 기반으로 현재 URL이 서비스 URL로 사용되도록 하는 ``ServiceAuthenticationDetails``를 생성합니다.
서비스 URL을 생성하는 방법은 사용자 정의 ``ServiceAuthenticationDetails``를 반환하는 사용자 정의 ``AuthenticationDetailsSource``를 주입하여 사용자 정의할 수 있습니다.

[source,xml]
----
<bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter">
...
<property name="serviceProperties" ref="serviceProperties"/>
<property name="authenticationDetailsSource">
	<bean class=
	"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource">
	<constructor-arg ref="serviceProperties"/>
	</bean>
</property>
</bean>
----

프록시 티켓을 처리하도록 ``CasAuthenticationProvider``도 업데이트해야 합니다.
이를 위해 ``Cas20ServiceTicketValidator``를 ``Cas20ProxyTicketValidator``로 교체합니다.
``statelessTicketCache``를 구성하고 어떤 프록시를 수락할지 구성해야 합니다.
모든 프록시를 수락하는 데 필요한 업데이트의 예를 아래에서 찾을 수 있습니다.

[source,xml]
----

<bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
...
<property name="ticketValidator">
	<bean class="org.apereo.cas.client.validation.Cas20ProxyTicketValidator">
	<constructor-arg value="https://localhost:9443/cas"/>
	<property name="acceptAnyProxy" value="true"/>
	</bean>
</property>
<property name="statelessTicketCache">
	<bean class="org.springframework.security.cas.authentication.EhCacheBasedTicketCache">
	<property name="cache">
		<bean class="net.sf.ehcache.Cache"
			init-method="initialise" destroy-method="dispose">
		<constructor-arg value="casTickets"/>
		<constructor-arg value="50"/>
		<constructor-arg value="true"/>
		<constructor-arg value="false"/>
		<constructor-arg value="3600"/>
		<constructor-arg value="900"/>
		</bean>
	</property>
	</bean>
</property>
</bean>
----