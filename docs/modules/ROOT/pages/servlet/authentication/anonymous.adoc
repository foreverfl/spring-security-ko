[[anonymous]]
= 익명 인증

[[anonymous-overview]]
== 개요
일반적으로 "기본적으로 거부"하는 자세를 취하는 것이 좋은 보안 관행으로 간주됩니다. 이는 명시적으로 허용되는 것을 지정하고 나머지는 모두 거부하는 방식입니다.
인증되지 않은 사용자가 접근할 수 있는 것을 정의하는 것도 비슷한 상황입니다. 특히 웹 애플리케이션에서 그렇습니다.
많은 사이트에서는 몇 개의 URL(예: 홈 페이지와 로그인 페이지)을 제외하고는 모든 것에 대해 사용자 인증을 요구합니다.
이 경우, 모든 보안 리소스에 대해 접근 구성 속성을 정의하는 것보다 이러한 특정 URL에 대해서만 접근 구성 속성을 정의하는 것이 더 쉽습니다.
다르게 말하면, 때로는 기본적으로 ``ROLE_SOMETHING``이 필요하다고 말하고 로그인, 로그아웃, 애플리케이션의 홈 페이지와 같은 특정 예외만 허용하는 것이 좋습니다.
이러한 페이지를 필터 체인에서 완전히 제외할 수도 있어 접근 제어 검사를 우회할 수 있지만, 이는 다른 이유로 바람직하지 않을 수 있습니다. 특히 인증된 사용자에 대해 페이지가 다르게 동작하는 경우에 그렇습니다.

이것이 우리가 말하는 익명 인증입니다.
"익명으로 인증된" 사용자와 인증되지 않은 사용자 사이에는 실제로 개념적 차이가 없다는 점에 유의하세요.
Spring Security의 익명 인증은 단지 접근 제어 속성을 구성하는 더 편리한 방법을 제공할 뿐입니다.
``getCallerPrincipal``과 같은 서블릿 API 호출은 ``SecurityContextHolder``에 실제로 익명 인증 객체가 있더라도 여전히 null을 반환합니다.

감사 인터셉터가 어떤 주체가 특정 작업을 수행했는지 식별하기 위해 ``SecurityContextHolder``를 조회하는 경우와 같이 익명 인증이 유용한 다른 상황도 있습니다.
``SecurityContextHolder``가 항상 ``Authentication`` 객체를 포함하고 절대 ``null``을 포함하지 않는다는 것을 알면 클래스를 더 견고하게 작성할 수 있습니다.

[[anonymous-config]]
== 구성
HTTP 구성을 사용할 때(Spring Security 3.0에서 도입) 익명 인증 지원이 자동으로 제공됩니다.
`<anonymous>` 요소를 사용하여 이를 사용자 정의(또는 비활성화)할 수 있습니다.
전통적인 빈 구성을 사용하지 않는 한 여기에서 설명하는 빈을 구성할 필요가 없습니다.

익명 인증 기능을 제공하기 위해 세 가지 클래스가 함께 작동합니다.
``AnonymousAuthenticationToken``은 ``Authentication``의 구현체로 익명 주체에 적용되는 ``GrantedAuthority`` 인스턴스를 저장합니다.
이에 해당하는 ``AnonymousAuthenticationProvider``가 있어 ``ProviderManager``에 연결되어 ``AnonymousAuthenticationToken`` 인스턴스가 수락됩니다.
마지막으로, ``AnonymousAuthenticationFilter``가 일반 인증 메커니즘 후에 연결되어 ``SecurityContextHolder``에 기존 ``Authentication``이 없는 경우 자동으로 ``AnonymousAuthenticationToken``을 추가합니다.
필터와 인증 제공자는 다음과 같이 정의됩니다:

[source,xml]
----
<bean id="anonymousAuthFilter"
	class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter">
<property name="key" value="foobar"/>
<property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS"/>
</bean>

<bean id="anonymousAuthenticationProvider"
	class="org.springframework.security.authentication.AnonymousAuthenticationProvider">
<property name="key" value="foobar"/>
</bean>
----

``key``는 필터와 인증 제공자 간에 공유되어 전자가 생성한 토큰을 후자가 수락할 수 있도록 합니다.

[NOTE]
====
여기서 ``key`` 속성의 사용은 실제 보안을 제공하는 것으로 간주해서는 안 됩니다.
단순히 관리 목적으로 사용됩니다.
클라이언트가 `Authentication` 객체를 구성할 수 있는 시나리오(예: RMI 호출)에서 ``AnonymousAuthenticationProvider``를 포함하는 ``ProviderManager``를 공유하는 경우, 악의적인 클라이언트가 자체적으로 생성한 ``AnonymousAuthenticationToken``을 제출할 수 있습니다(선택한 사용자 이름과 권한 목록으로).
``key``를 추측하거나 알아낼 수 있다면 익명 제공자가 토큰을 수락할 것입니다.
이는 일반적인 사용에서는 문제가 되지 않습니다. 그러나 RMI를 사용하는 경우, HTTP 인증 메커니즘에 사용하는 것을 공유하는 대신 익명 제공자를 제외한 사용자 지정 ``ProviderManager``를 사용해야 합니다.
====

``userAttribute``는 `usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]` 형식으로 표현됩니다.
``InMemoryDaoImpl``의 `userMap` 속성에 대해 등호 뒤에 동일한 구문이 사용됩니다.

앞서 설명한 대로 익명 인증의 이점은 모든 URI 패턴에 보안을 적용할 수 있다는 것입니다. 다음 예시에서 볼 수 있습니다:

[source,xml]
----
<bean id="filterSecurityInterceptor"
	class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor">
<property name="authenticationManager" ref="authenticationManager"/>
<property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/>
<property name="securityMetadata">
	<security:filter-security-metadata-source>
	<security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/>
	<security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/>
	<security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/>
	<security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/>
	<security:intercept-url pattern='/**' access='ROLE_USER'/>
	</security:filter-security-metadata-source>" +
</property>
</bean>
----

[[anonymous-auth-trust-resolver]]
== AuthenticationTrustResolver
익명 인증 논의를 마무리하는 것은 `AuthenticationTrustResolver` 인터페이스와 그에 해당하는 `AuthenticationTrustResolverImpl` 구현입니다.
이 인터페이스는 `isAnonymous(Authentication)` 메서드를 제공하여 관심 있는 클래스가 이 특별한 유형의 인증 상태를 고려할 수 있도록 합니다.
``ExceptionTranslationFilter``는 `AccessDeniedException` 인스턴스를 처리할 때 이 인터페이스를 사용합니다.
``AccessDeniedException``이 발생하고 인증이 익명 유형인 경우, 403(금지됨) 응답을 보내는 대신 필터는 ``AuthenticationEntryPoint``를 시작하여 주체가 적절히 인증할 수 있도록 합니다.
이는 필요한 구분입니다. 그렇지 않으면 주체가 항상 "인증된" 것으로 간주되어 폼, 기본, 다이제스트 또는 기타 일반적인 인증 메커니즘을 통해 로그인할 기회를 갖지 못할 것입니다.

우리는 종종 앞서 본 인터셉터 구성에서 `ROLE_ANONYMOUS` 속성이 ``IS_AUTHENTICATED_ANONYMOUSLY``로 대체되는 것을 봅니다. 이는 접근 제어를 정의할 때 사실상 동일한 것입니다.
이는 xref:servlet/authorization/architecture.adoc#authz-authenticated-voter[권한 부여 챕터]에서 다루는 ``AuthenticatedVoter``의 사용 예시입니다.
이는 ``AuthenticationTrustResolver``를 사용하여 이 특정 구성 속성을 처리하고 익명 사용자에게 접근 권한을 부여합니다.
`AuthenticatedVoter` 접근 방식은 더 강력합니다. 익명, 자동 로그인(remember-me), 완전히 인증된 사용자를 구별할 수 있기 때문입니다.
하지만 이 기능이 필요하지 않다면 Spring Security의 표준 ``RoleVoter``에 의해 처리되는 ``ROLE_ANONYMOUS``를 계속 사용할 수 있습니다.

[[anonymous-auth-mvc-controller]]
== Spring MVC에서 익명 인증 얻기

https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments[Spring MVC는 자체 인자 리졸버를 사용하여 `Principal` 타입의 파라미터를 해석합니다].

이는 다음과 같은 구조가:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/")
public String method(Authentication authentication) {
	if (authentication instanceof AnonymousAuthenticationToken) {
		return "anonymous";
	} else {
		return "not anonymous";
	}
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/")
fun method(authentication: Authentication?): String {
    return if (authentication is AnonymousAuthenticationToken) {
        "anonymous"
    } else {
        "not anonymous"
    }
}
----
======

익명 요청에 대해서도 항상 "not anonymous"를 반환한다는 것을 의미합니다.
그 이유는 Spring MVC가 ``HttpServletRequest#getPrincipal``을 사용하여 파라미터를 해석하기 때문인데, 이는 요청이 익명일 때 ``null``입니다.

익명 요청에서 ``Authentication``을 얻고 싶다면 대신 ``@CurrentSecurityContext``를 사용하세요:

.익명 요청에 CurrentSecurityContext 사용하기
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@GetMapping("/")
public String method(@CurrentSecurityContext SecurityContext context) {
	return context.getAuthentication().getName();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@GetMapping("/")
fun method(@CurrentSecurityContext context : SecurityContext) : String =
		context!!.authentication!!.name
----
======