[[servlet-authentication-inmemory]]
= 인메모리 인증

Spring Security의 ``InMemoryUserDetailsManager``는 메모리에 저장된 사용자 이름/비밀번호 기반 인증을 지원하기 위해 ``UserDetailsService``를 구현합니다.
``InMemoryUserDetailsManager``는 `UserDetailsManager` 인터페이스를 구현하여 ``UserDetails``를 관리합니다.
`UserDetails` 기반 인증은 Spring Security가 인증을 위해 사용자 이름과 비밀번호를 받도록 구성된 경우 사용됩니다.

다음 예제에서는 Spring Boot CLI를 사용하여 'password'라는 비밀번호 값을 인코딩하고, 인코딩된 비밀번호 ``+{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW+``를 얻습니다:

.InMemoryUserDetailsManager Java 구성
[tabs]
======
Java::
+
[source,java,role="primary",attrs="-attributes"]
----
@Bean
public UserDetailsService users() {
	UserDetails user = User.builder()
		.username("user")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER")
		.build();
	UserDetails admin = User.builder()
		.username("admin")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER", "ADMIN")
		.build();
	return new InMemoryUserDetailsManager(user, admin);
}
----

XML::
+
[source,xml,role="secondary",attrs="-attributes"]
----
<user-service>
	<user name="user"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER" />
	<user name="admin"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER,ROLE_ADMIN" />
</user-service>
----

Kotlin::
+
[source,kotlin,role="secondary",attrs="-attributes"]
----
@Bean
fun users(): UserDetailsService {
    val user = User.builder()
        .username("user")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER")
        .build()
    val admin = User.builder()
        .username("admin")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}
----
======

위의 예제는 비밀번호를 안전한 형식으로 저장하지만, 시작하는 데 있어서는 다소 부족한 점이 있습니다.

다음 예제에서는 ``User.withDefaultPasswordEncoder``를 사용하여 메모리에 저장된 비밀번호가 보호되도록 합니다.
하지만 이는 소스 코드를 역컴파일하여 비밀번호를 얻는 것을 방지하지는 못합니다.
이러한 이유로 ``User.withDefaultPasswordEncoder``는 "시작하기" 용도로만 사용해야 하며 실제 운영 환경에서는 사용하지 않아야 합니다.

.User.withDefaultPasswordEncoder를 사용한 InMemoryUserDetailsManager
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public UserDetailsService users() {
	// 빌더는 메모리에 저장하기 전에 비밀번호가 인코딩되도록 보장합니다
	UserBuilder users = User.withDefaultPasswordEncoder();
	UserDetails user = users
		.username("user")
		.password("password")
		.roles("USER")
		.build();
	UserDetails admin = users
		.username("admin")
		.password("password")
		.roles("USER", "ADMIN")
		.build();
	return new InMemoryUserDetailsManager(user, admin);
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun users(): UserDetailsService {
    // 빌더는 메모리에 저장하기 전에 비밀번호가 인코딩되도록 보장합니다
    val users = User.withDefaultPasswordEncoder()
    val user = users
        .username("user")
        .password("password")
        .roles("USER")
        .build()
    val admin = users
        .username("admin")
        .password("password")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}
----
======

XML 기반 구성에서 ``User.withDefaultPasswordEncoder``를 사용하는 간단한 방법은 없습니다.
데모나 시작 단계에서는 비밀번호 앞에 ``+{noop}+``를 붙여 인코딩을 사용하지 않도록 표시할 수 있습니다:

.<user-service> `+{noop}+` XML 구성
[source,xml,attrs="-attributes"]
----
<user-service>
	<user name="user"
		password="{noop}password"
		authorities="ROLE_USER" />
	<user name="admin"
		password="{noop}password"
		authorities="ROLE_USER,ROLE_ADMIN" />
</user-service>
----