[[servlet-authentication-jdbc]]
= JDBC 인증

Spring Security의 ``JdbcDaoImpl``은 JDBC를 사용하여 검색된 사용자 이름과 비밀번호 기반 인증을 지원하기 위해 ``UserDetailsService``를 구현합니다.
``JdbcUserDetailsManager``는 ``JdbcDaoImpl``을 확장하여 ``UserDetailsManager`` 인터페이스를 통해 ``UserDetails``의 관리를 제공합니다.
`UserDetails` 기반 인증은 Spring Security가 인증을 위해 사용자 이름/비밀번호를 받도록 구성된 경우 사용됩니다.

다음 섹션에서는 아래 내용을 다룹니다:

* Spring Security JDBC 인증에서 사용하는 <<servlet-authentication-jdbc-schema>>
* <<servlet-authentication-jdbc-datasource>>
* <<servlet-authentication-jdbc-bean>>

[[servlet-authentication-jdbc-schema]]
== 기본 스키마

Spring Security는 JDBC 기반 인증을 위한 기본 쿼리를 제공합니다.
이 섹션에서는 기본 쿼리와 함께 사용되는 해당 기본 스키마를 제공합니다.
사용하는 데이터베이스 방언과 쿼리의 사용자 정의에 맞게 스키마를 조정해야 합니다.

[[servlet-authentication-jdbc-schema-user]]
=== 사용자 스키마

``JdbcDaoImpl``은 사용자의 비밀번호, 계정 상태(활성화 또는 비활성화) 및 권한(역할) 목록을 로드하기 위한 테이블이 필요합니다.

[NOTE]
====
기본 스키마는 ``org/springframework/security/core/userdetails/jdbc/users.ddl``이라는 이름의 클래스패스 리소스로도 제공됩니다.
====

.기본 사용자 스키마
[source,sql]
----
create table users(
	username varchar_ignorecase(50) not null primary key,
	password varchar_ignorecase(500) not null,
	enabled boolean not null
);

create table authorities (
	username varchar_ignorecase(50) not null,
	authority varchar_ignorecase(50) not null,
	constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);
----

Oracle은 인기 있는 데이터베이스 선택이지만 약간 다른 스키마가 필요합니다:

.Oracle 데이터베이스용 기본 사용자 스키마
[source,sql]
----
CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;
----

[[servlet-authentication-jdbc-schema-group]]
=== 그룹 스키마

애플리케이션에서 그룹을 사용하는 경우 그룹 스키마를 제공해야 합니다:

.기본 그룹 스키마
[source,sql]
----
create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);
----

[[servlet-authentication-jdbc-datasource]]
== DataSource 설정

``JdbcUserDetailsManager``를 구성하기 전에 ``DataSource``를 생성해야 합니다.
이 예제에서는 <<servlet-authentication-jdbc-schema,기본 사용자 스키마>>로 초기화된 내장 DataSource를 설정합니다.

.내장 Data Source
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
DataSource dataSource() {
	return new EmbeddedDatabaseBuilder()
		.setType(H2)
		.addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
		.build();
}
----

XML::
+
[source,xml,role="secondary"]
----
<jdbc:embedded-database>
	<jdbc:script location="classpath:org/springframework/security/core/userdetails/jdbc/users.ddl"/>
</jdbc:embedded-database>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
        .setType(H2)
        .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
        .build()
}
----
======

운영 환경에서는 외부 데이터베이스에 대한 연결을 설정해야 합니다.

[[servlet-authentication-jdbc-bean]]
== JdbcUserDetailsManager 빈

이 예제에서는 Spring Boot CLI를 사용하여 'password'라는 비밀번호 값을 인코딩하고, 인코딩된 비밀번호 ``+{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW+``를 얻습니다.
비밀번호 저장 방법에 대한 자세한 내용은 PasswordEncoder 섹션을 참조하세요.

.JdbcUserDetailsManager

[tabs]
======
Java::
+
[source,java,role="primary",attrs="-attributes"]
----
@Bean
UserDetailsManager users(DataSource dataSource) {
	UserDetails user = User.builder()
		.username("user")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER")
		.build();
	UserDetails admin = User.builder()
		.username("admin")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER", "ADMIN")
		.build();
	JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
	users.createUser(user);
	users.createUser(admin);
	return users;
}
----

XML::
+
[source,xml,role="secondary",attrs="-attributes"]
----
<jdbc-user-service>
	<user name="user"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER" />
	<user name="admin"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER,ROLE_ADMIN" />
</jdbc-user-service>
----

Kotlin::
+
[source,kotlin,role="secondary",attrs="-attributes"]
----
@Bean
fun users(dataSource: DataSource): UserDetailsManager {
    val user = User.builder()
            .username("user")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER")
            .build();
    val admin = User.builder()
            .username("admin")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER", "ADMIN")
            .build();
    val users = JdbcUserDetailsManager(dataSource)
    users.createUser(user)
    users.createUser(admin)
    return users
}
----
======