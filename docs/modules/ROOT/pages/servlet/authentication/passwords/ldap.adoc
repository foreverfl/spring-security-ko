[[servlet-authentication-ldap]]
= LDAP 인증

LDAP(Lightweight Directory Access Protocol)는 조직에서 사용자 정보의 중앙 저장소와 인증 서비스로 자주 사용됩니다.
또한 애플리케이션 사용자의 역할 정보를 저장하는 데도 사용될 수 있습니다.

Spring Security의 LDAP 기반 인증은 xref:servlet/authentication/passwords/index.adoc#servlet-authentication-unpwd-input[사용자 이름/비밀번호를 받아들이도록] 구성된 경우 Spring Security에서 사용됩니다.
그러나 인증에 사용자 이름과 비밀번호를 사용함에도 불구하고, <<servlet-authentication-ldap-bind,바인드 인증>>에서는 LDAP 서버가 비밀번호를 반환하지 않기 때문에 ``UserDetailsService``를 사용하지 않습니다. 따라서 애플리케이션에서 비밀번호 검증을 수행할 수 없습니다.

LDAP 서버를 구성하는 방법에는 여러 가지 시나리오가 있으므로 Spring Security의 LDAP 제공자는 완전히 구성 가능합니다.
인증과 역할 검색을 위해 별도의 전략 인터페이스를 사용하며, 다양한 상황을 처리할 수 있도록 구성할 수 있는 기본 구현을 제공합니다.

[[servlet-authentication-ldap-required-dependencies]]
== 필요한 의존성

시작하려면 프로젝트에 ``spring-security-ldap`` 의존성을 추가하세요.
Spring Boot를 사용할 때는 다음 의존성을 추가하세요:

.Spring Security LDAP 의존성
[tabs]
======
Maven::
+
[source,xml,role="primary"]
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-ldap</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-ldap</artifactId>
</dependency>
----

Gradle::
+
[source,groovy,role="secondary"]
----
depenendencies {
    implementation "org.springframework.boot:spring-boot-starter-data-ldap"
    implementation "org.springframework.security:spring-security-ldap"
}
----
======

[[servlet-authentication-ldap-prerequisites]]
== 사전 준비

Spring Security와 함께 LDAP를 사용하기 전에 LDAP에 대해 잘 알고 있어야 합니다.
다음 링크는 관련 개념을 소개하고 무료 LDAP 서버인 OpenLDAP를 사용하여 디렉토리를 설정하는 방법에 대한 가이드를 제공합니다: https://www.zytrax.com/books/ldap/.
Java에서 LDAP에 접근하는 데 사용되는 JNDI API에 대한 어느 정도의 친숙함도 도움이 될 수 있습니다.
LDAP 제공자에서는 타사 LDAP 라이브러리(Mozilla, JLDAP 등)를 사용하지 않지만, Spring LDAP를 광범위하게 사용하므로 자체 사용자 정의를 추가할 계획이라면 해당 프로젝트에 대한 일부 친숙함이 유용할 수 있습니다.

LDAP 인증을 사용할 때는 LDAP 연결 풀링을 적절히 구성해야 합니다.
구성 방법을 잘 모르는 경우 https://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html[Java LDAP 문서]를 참조하세요.

[[servlet-authentication-ldap-embedded]]
== 내장 LDAP 서버 설정

먼저 해야 할 일은 구성을 지정할 LDAP 서버가 있는지 확인하는 것입니다.
간단히 하기 위해 내장 LDAP 서버로 시작하는 것이 가장 좋습니다.
Spring Security는 다음 중 하나를 사용할 수 있도록 지원합니다:

* <<servlet-authentication-ldap-unboundid>>
* <<servlet-authentication-ldap-apacheds>>

다음 예제에서는 ``users.ldif``를 클래스패스 리소스로 노출하여 내장 LDAP 서버를 두 명의 사용자, ``user``와 ``admin``으로 초기화합니다. 두 사용자 모두 비밀번호는 ``password``입니다:

.users.ldif
[source,ldif]
----
dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
member: uid=admin,ou=people,dc=springframework,dc=org
member: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
member: uid=admin,ou=people,dc=springframework,dc=org
----

[[servlet-authentication-ldap-unboundid]]
=== 내장 UnboundID 서버

https://ldap.com/unboundid-ldap-sdk-for-java/[UnboundID]를 사용하려면 다음 의존성을 지정하세요:

.UnboundID 의존성
[tabs]
======
Maven::
+
[source,xml,role="primary",subs="verbatim,attributes"]
----
<dependency>
	<groupId>com.unboundid</groupId>
	<artifactId>unboundid-ldapsdk</artifactId>
	<version>{unboundid-ldapsdk-version}</version>
	<scope>runtime</scope>
</dependency>
----

Gradle::
+
[source,groovy,role="secondary",subs="verbatim,attributes"]
----
depenendencies {
	runtimeOnly "com.unboundid:unboundid-ldapsdk:{unboundid-ldapsdk-version}"
}
----
======

그런 다음 ``EmbeddedLdapServerContextSourceFactoryBean``을 사용하여 내장 LDAP 서버를 구성할 수 있습니다.
이렇게 하면 Spring Security가 메모리 내 LDAP 서버를 시작하도록 지시합니다:

.내장 LDAP 서버 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() {
	return EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer();
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun contextSourceFactoryBean(): EmbeddedLdapServerContextSourceFactoryBean {
    return EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer()
}
----
======

또는 내장 LDAP 서버를 수동으로 구성할 수 있습니다.
이 접근 방식을 선택하면 내장 LDAP 서버의 생명주기를 관리해야 합니다.

.명시적 내장 LDAP 서버 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
UnboundIdContainer ldapContainer() {
	return new UnboundIdContainer("dc=springframework,dc=org",
				"classpath:users.ldif");
}
----

XML::
+
[source,xml,role="secondary"]
----
<b:bean class="org.springframework.security.ldap.server.UnboundIdContainer"
	c:defaultPartitionSuffix="dc=springframework,dc=org"
	c:ldif="classpath:users.ldif"/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun ldapContainer(): UnboundIdContainer {
    return UnboundIdContainer("dc=springframework,dc=org","classpath:users.ldif")
}
----
======

[[servlet-authentication-ldap-apacheds]]
=== 내장 ApacheDS 서버

[NOTE]
====
Spring Security는 더 이상 유지 관리되지 않는 ApacheDS 1.x를 사용합니다.
안타깝게도 ApacheDS 2.x는 안정적인 릴리스 없이 마일스톤 버전만 출시했습니다.
ApacheDS 2.x의 안정적인 릴리스가 가능해지면 업데이트를 고려하겠습니다.
====

https://directory.apache.org/apacheds/[Apache DS]를 사용하려면 다음 의존성을 지정하세요:

.ApacheDS 의존성
[tabs]
======
Maven::
+
[source,xml,role="primary",subs="+attributes"]
----
<dependency>
	<groupId>org.apache.directory.server</groupId>
	<artifactId>apacheds-core</artifactId>
	<version>{apacheds-core-version}</version>
	<scope>runtime</scope>
</dependency>
<dependency>
	<groupId>org.apache.directory.server</groupId>
	<artifactId>apacheds-server-jndi</artifactId>
	<version>{apacheds-core-version}</version>
	<scope>runtime</scope>
</dependency>
----

Gradle::
+
[source,groovy,role="secondary",subs="+attributes"]
----
depenendencies {
	runtimeOnly "org.apache.directory.server:apacheds-core:{apacheds-core-version}"
	runtimeOnly "org.apache.directory.server:apacheds-server-jndi:{apacheds-core-version}"
}
----
======

그런 다음 내장 LDAP 서버를 구성할 수 있습니다:

.내장 LDAP 서버 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ApacheDSContainer ldapContainer() {
	return new ApacheDSContainer("dc=springframework,dc=org",
				"classpath:users.ldif");
}
----

XML::
+
[source,xml,role="secondary"]
----
<b:bean class="org.springframework.security.ldap.server.ApacheDSContainer"
	c:defaultPartitionSuffix="dc=springframework,dc=org"
	c:ldif="classpath:users.ldif"/>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun ldapContainer(): ApacheDSContainer {
    return ApacheDSContainer("dc=springframework,dc=org", "classpath:users.ldif")
}
----
======

[[servlet-authentication-ldap-contextsource]]
== LDAP ContextSource

구성을 지정할 LDAP 서버가 준비되면 Spring Security가 사용자 인증에 사용할 LDAP 서버를 가리키도록 구성해야 합니다.
이를 위해 LDAP ``ContextSource``(JDBC `DataSource`와 동등한)를 생성합니다.
이미 ``EmbeddedLdapServerContextSourceFactoryBean``을 구성한 경우 Spring Security는 내장 LDAP 서버를 가리키는 LDAP ``ContextSource``를 생성합니다.

.내장 LDAP 서버가 있는 LDAP Context Source
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
public EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean() {
	EmbeddedLdapServerContextSourceFactoryBean contextSourceFactoryBean =
			EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer();
	contextSourceFactoryBean.setPort(0);
	return contextSourceFactoryBean;
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun contextSourceFactoryBean(): EmbeddedLdapServerContextSourceFactoryBean {
    val contextSourceFactoryBean = EmbeddedLdapServerContextSourceFactoryBean.fromEmbeddedLdapServer()
    contextSourceFactoryBean.setPort(0)
    return contextSourceFactoryBean
}
----
======

또는 제공된 LDAP 서버에 연결하도록 LDAP ``ContextSource``를 명시적으로 구성할 수 있습니다:

.LDAP Context Source
[tabs]
======
Java::
+
[source,java,role="primary"]
----
ContextSource contextSource(UnboundIdContainer container) {
	return new DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org");
}
----

XML::
+
[source,xml,role="secondary"]
----
<ldap-server
	url="ldap://localhost:53389/dc=springframework,dc=org" />
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
fun contextSource(container: UnboundIdContainer): ContextSource {
    return DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org")
}
----
======

[[servlet-authentication-ldap-authentication]]
== 인증

Spring Security의 LDAP 지원은 xref:servlet/authentication/passwords/user-details-service.adoc#servlet-authentication-userdetailsservice[UserDetailsService]를 사용하지 않습니다. LDAP 바인드 인증에서는 클라이언트가 비밀번호나 해시된 비밀번호 버전을 읽을 수 없기 때문입니다. 즉, Spring Security가 비밀번호를 읽어 인증할 방법이 없습니다.

이러한 이유로 LDAP 지원은 ``LdapAuthenticator`` 인터페이스를 통해 구현됩니다. ``LdapAuthenticator`` 인터페이스는 필요한 사용자 속성을 검색하는 역할도 합니다. 이는 속성에 대한 권한이 사용되는 인증 유형에 따라 달라질 수 있기 때문입니다. 예를 들어, 사용자로 바인딩하는 경우 사용자 자신의 권한으로 속성을 읽어야 할 수 있습니다.

Spring Security는 두 가지 ``LdapAuthenticator`` 구현을 제공합니다:

* <<servlet-authentication-ldap-bind>>
* <<servlet-authentication-ldap-pwd>>

[[servlet-authentication-ldap-bind]]
== 바인드 인증 사용

https://ldap.com/the-ldap-bind-operation/[바인드 인증]은 LDAP로 사용자를 인증하는 가장 일반적인 메커니즘입니다. 바인드 인증에서는 사용자의 자격 증명(사용자 이름과 비밀번호)이 LDAP 서버에 제출되어 인증됩니다. 바인드 인증을 사용하는 장점은 사용자의 비밀 정보(비밀번호)를 클라이언트에 노출할 필요가 없어 유출을 방지할 수 있다는 것입니다.

다음 예제는 바인드 인증 구성을 보여줍니다:

.바인드 인증
[tabs]
======
Java::
+
[source,java,role="primary",attrs="-attributes"]
----
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {
	LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);
	factory.setUserDnPatterns("uid={0},ou=people");
	return factory.createAuthenticationManager();
}
----

XML::
+
[source,xml,role="secondary",attrs="-attributes"]
----
<ldap-authentication-provider
	user-dn-pattern="uid={0},ou=people"/>
----

Kotlin::
+
[source,kotlin,role="secondary",attrs="-attributes"]
----
@Bean
fun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager {
    val factory = LdapBindAuthenticationManagerFactory(contextSource)
    factory.setUserDnPatterns("uid={0},ou=people")
    return factory.createAuthenticationManager()
}
----
======

이 간단한 예제는 제공된 패턴에 사용자 로그인 이름을 대체하여 사용자의 DN(Distinguished Name)을 얻고, 로그인 비밀번호로 해당 사용자로 바인딩을 시도합니다. 모든 사용자가 디렉토리의 단일 노드 아래에 저장된 경우 이 방법이 적합합니다. 대신 사용자를 찾기 위한 LDAP 검색 필터를 구성하려면 다음과 같이 할 수 있습니다:

.검색 필터가 있는 바인드 인증
[tabs]
======
Java::
+
[source,java,role="primary",attrs="-attributes"]
----
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {
	LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);
	factory.setUserSearchFilter("(uid={0})");
	factory.setUserSearchBase("ou=people");
	return factory.createAuthenticationManager();
}
----

XML::
+
[source,xml,role="secondary",attrs="-attributes"]
----
<ldap-authentication-provider
		user-search-filter="(uid={0})"
	user-search-base="ou=people"/>
----

Kotlin::
+
[source,kotlin,role="secondary",attrs="-attributes"]
----
@Bean
fun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager {
    val factory = LdapBindAuthenticationManagerFactory(contextSource)
    factory.setUserSearchFilter("(uid={0})")
    factory.setUserSearchBase("ou=people")
    return factory.createAuthenticationManager()
}
----
======

<<servlet-authentication-ldap-contextsource,앞서 보여준 ContextSource 정의>>와 함께 사용하면, 이는 ``+(uid={0})+``를 필터로 사용하여 ``ou=people,dc=springframework,dc=org`` DN 아래에서 검색을 수행합니다. 다시 말해, 사용자 로그인 이름이 필터 이름의 매개변수로 대체되어 `uid` 속성이 사용자 이름과 같은 항목을 검색합니다. 사용자 검색 기반이 제공되지 않으면 루트에서 검색이 수행됩니다.

[[servlet-authentication-ldap-pwd]]
== 비밀번호 인증 사용

비밀번호 비교는 사용자가 제공한 비밀번호를 저장소에 있는 비밀번호와 비교하는 것입니다. 이는 비밀번호 속성 값을 검색하여 로컬에서 확인하거나 LDAP "compare" 작업을 수행하여 제공된 비밀번호를 서버로 전달하여 비교할 수 있습니다. 이 경우 실제 비밀번호 값은 검색되지 않습니다. 비밀번호가 무작위 솔트로 적절히 해시되었을 때는 LDAP 비교를 수행할 수 없습니다.

.최소 비밀번호 비교 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {
	LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(
			contextSource, NoOpPasswordEncoder.getInstance());
	factory.setUserDnPatterns("uid={0},ou=people");
	return factory.createAuthenticationManager();
}
----

XML::
+
[source,xml,role="secondary",attrs="-attributes"]
----
<ldap-authentication-provider
		user-dn-pattern="uid={0},ou=people">
	<password-compare />
</ldap-authentication-provider>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authenticationManager(contextSource: BaseLdapPathContextSource?): AuthenticationManager? {
    val factory = LdapPasswordComparisonAuthenticationManagerFactory(
        contextSource, NoOpPasswordEncoder.getInstance()
    )
    factory.setUserDnPatterns("uid={0},ou=people")
    return factory.createAuthenticationManager()
}
----
======

다음 예제는 일부 사용자 정의를 포함한 더 고급 구성을 보여줍니다:

.비밀번호 비교 구성
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource) {
	LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(
			contextSource, new BCryptPasswordEncoder());
	factory.setUserDnPatterns("uid={0},ou=people");
	factory.setPasswordAttribute("pwd");  // <1>
	return factory.createAuthenticationManager();
}
----

XML::
+
[source,xml,role="secondary",attrs="-attributes"]
----
<ldap-authentication-provider
		user-dn-pattern="uid={0},ou=people">
	<password-compare password-attribute="pwd"> <!--1-->
		<password-encoder ref="passwordEncoder" /> <!--2-->
	</password-compare>
</ldap-authentication-provider>
<b:bean id="passwordEncoder"
	class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" />
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authenticationManager(contextSource: BaseLdapPathContextSource): AuthenticationManager {
    val factory = LdapPasswordComparisonAuthenticationManagerFactory(
        contextSource, BCryptPasswordEncoder()
    )
    factory.setUserDnPatterns("uid={0},ou=people")
    factory.setPasswordAttribute("pwd") // <1>
    return factory.createAuthenticationManager()
}
----
======

<1> 비밀번호 속성을 ``pwd``로 지정합니다.

== LdapAuthoritiesPopulator

Spring Security의 ``LdapAuthoritiesPopulator``는 사용자에 대해 반환될 권한을 결정하는 데 사용됩니다.
다음 예제는 ``LdapAuthoritiesPopulator``를 구성하는 방법을 보여줍니다:

.LdapAuthoritiesPopulator 구성
[tabs]
======
Java::
+
[source,java,role="primary",attrs="-attributes"]
----
@Bean
LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
	String groupSearchBase = "";
	DefaultLdapAuthoritiesPopulator authorities =
		new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase);
	authorities.setGroupSearchFilter("member={0}");
	return authorities;
}

@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) {
	LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);
	factory.setUserDnPatterns("uid={0},ou=people");
	factory.setLdapAuthoritiesPopulator(authorities);
	return factory.createAuthenticationManager();
}
----

XML::
+
[source,xml,role="secondary",attrs="-attributes"]
----
<ldap-authentication-provider
	user-dn-pattern="uid={0},ou=people"
	group-search-filter="member={0}"/>
----

Kotlin::
+
[source,kotlin,role="secondary",attrs="-attributes"]
----
@Bean
fun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator {
    val groupSearchBase = ""
    val authorities = DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase)
    authorities.setGroupSearchFilter("member={0}")
    return authorities
}

@Bean
fun authenticationManager(
    contextSource: BaseLdapPathContextSource,
    authorities: LdapAuthoritiesPopulator): AuthenticationManager {
    val factory = LdapBindAuthenticationManagerFactory(contextSource)
    factory.setUserDnPatterns("uid={0},ou=people")
    factory.setLdapAuthoritiesPopulator(authorities)
    return factory.createAuthenticationManager()
}
----
======

== Active Directory

Active Directory는 자체적인 비표준 인증 옵션을 지원하며, 일반적인 사용 패턴은 표준 ``LdapAuthenticationProvider``와 잘 맞지 않습니다. 일반적으로 인증은 LDAP 고유 이름(DN)을 사용하는 대신 도메인 사용자 이름(`user@domain` 형식)을 사용하여 수행됩니다. 이를 쉽게 만들기 위해 Spring Security는 일반적인 Active Directory 설정에 맞춤화된 인증 제공자를 가지고 있습니다.

``ActiveDirectoryLdapAuthenticationProvider``를 구성하는 것은 상당히 간단합니다. 도메인 이름과 서버 주소를 제공하는 LDAP URL만 제공하면 됩니다.

[NOTE]
====
DNS 조회를 사용하여 서버의 IP 주소를 얻는 것도 가능합니다. 현재는 지원되지 않지만, 향후 버전에서는 지원될 수 있기를 희망합니다.
====

다음 예제는 Active Directory를 구성합니다:

.Active Directory 구성 예제
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@Bean
ActiveDirectoryLdapAuthenticationProvider authenticationProvider() {
	return new ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/");
}
----

XML::
+
[source,xml,role="secondary"]
----
<bean id="authenticationProvider"
        class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider">
	<constructor-arg value="example.com" />
	<constructor-arg value="ldap://company.example.com/" />
</bean>
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@Bean
fun authenticationProvider(): ActiveDirectoryLdapAuthenticationProvider {
    return ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/")
}
----
======