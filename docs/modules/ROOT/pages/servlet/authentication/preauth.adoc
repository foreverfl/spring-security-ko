[[servlet-preauth]]
= 사전 인증 시나리오
Spring Security를 인가에 사용하고 싶지만 사용자가 이미 애플리케이션에 접근하기 전에 외부 시스템에 의해 안정적으로 인증된 상황이 있습니다.
이러한 상황을 "사전 인증" 시나리오라고 합니다.
예를 들어 X.509, Siteminder, 그리고 애플리케이션이 실행되는 Java EE 컨테이너에 의한 인증 등이 있습니다.
사전 인증을 사용할 때 Spring Security는 다음과 같은 작업을 수행해야 합니다:

* 요청을 하는 사용자를 식별합니다.
* 해당 사용자의 권한을 얻습니다.

세부 사항은 외부 인증 메커니즘에 따라 다릅니다.
X.509의 경우 사용자는 인증서 정보로 식별될 수 있고, Siteminder의 경우 HTTP 요청 헤더로 식별될 수 있습니다.
컨테이너 인증에 의존하는 경우, 들어오는 HTTP 요청에서 `getUserPrincipal()` 메서드를 호출하여 사용자를 식별합니다.
일부 경우에는 외부 메커니즘이 사용자의 역할과 권한 정보를 제공할 수 있습니다. 그러나 다른 경우에는 ``UserDetailsService``와 같은 별도의 소스에서 권한을 얻어야 합니다.

== 사전 인증 프레임워크 클래스
대부분의 사전 인증 메커니즘이 동일한 패턴을 따르기 때문에, Spring Security는 사전 인증된 인증 제공자를 구현하기 위한 내부 프레임워크를 제공하는 일련의 클래스를 가지고 있습니다.
이를 통해 중복을 제거하고 새로운 구현을 처음부터 작성하지 않고도 구조화된 방식으로 추가할 수 있습니다.
xref:servlet/authentication/x509.adoc#servlet-x509[X.509 인증]과 같은 것을 사용하려면 이 클래스들에 대해 알 필요가 없습니다. 이미 더 간단하게 사용하고 시작할 수 있는 네임스페이스 구성 옵션이 있기 때문입니다.
명시적인 빈 구성을 사용해야 하거나 자체 구현을 작성할 계획이라면 제공된 구현이 어떻게 작동하는지 이해해야 합니다.
`org.springframework.security.web.authentication.preauth` 아래에서 클래스를 찾을 수 있습니다.
여기서는 개요만 제공하므로 필요한 경우 Javadoc과 소스를 참조해야 합니다.

=== AbstractPreAuthenticatedProcessingFilter
이 클래스는 현재 보안 컨텍스트의 내용을 확인하고, 비어 있는 경우 HTTP 요청에서 사용자 정보를 추출하여 ``AuthenticationManager``에 제출하려고 시도합니다.
하위 클래스는 이 정보를 얻기 위해 다음 메서드를 오버라이드합니다.

.AbstractPreAuthenticatedProcessingFilter 오버라이드
[tabs]
======
Java::
+
[source,java,role="primary"]
----
protected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request);

protected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request);
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
protected abstract fun getPreAuthenticatedPrincipal(request: HttpServletRequest): Any?

protected abstract fun getPreAuthenticatedCredentials(request: HttpServletRequest): Any?
----
======

이 메서드들을 호출한 후, 필터는 반환된 데이터를 포함하는 ``PreAuthenticatedAuthenticationToken``을 생성하고 이를 인증을 위해 제출합니다.
여기서 "인증"이란 사용자의 권한을 로드하는 추가 처리를 의미하지만, 표준 Spring Security 인증 아키텍처를 따릅니다.

다른 Spring Security 인증 필터와 마찬가지로, 사전 인증 필터에는 ``authenticationDetailsSource`` 속성이 있습니다. 이는 기본적으로 세션 식별자와 발신 IP 주소와 같은 추가 정보를 ``Authentication`` 객체의 `details` 속성에 저장하는 `WebAuthenticationDetails` 객체를 생성합니다.
사용자 역할 정보를 사전 인증 메커니즘에서 얻을 수 있는 경우, 이 데이터도 이 속성에 저장되며, 상세 정보는 `GrantedAuthoritiesContainer` 인터페이스를 구현합니다.
이를 통해 인증 제공자가 사용자에게 외부적으로 할당된 권한을 읽을 수 있습니다.
다음으로 구체적인 예를 살펴보겠습니다.

[[j2ee-preauth-details]]
==== J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource
필터가 이 클래스의 인스턴스인 ``authenticationDetailsSource``로 구성된 경우, 권한 정보는 미리 정의된 "매핑 가능한 역할" 집합의 각각에 대해 `isUserInRole(String role)` 메서드를 호출하여 얻습니다.
이 클래스는 구성된 ``MappableAttributesRetriever``에서 이 정보를 가져옵니다.
가능한 구현에는 애플리케이션 컨텍스트에 목록을 하드코딩하거나 `web.xml` 파일의 `<security-role>` 정보에서 역할 정보를 읽는 방법이 있습니다.
사전 인증 샘플 애플리케이션은 후자의 접근 방식을 사용합니다.

역할(또는 속성)을 Spring Security `GrantedAuthority` 객체로 매핑하는 추가 단계가 있으며, 이는 구성된 ``Attributes2GrantedAuthoritiesMapper``를 사용합니다.
기본값은 단순히 이름에 일반적인 `ROLE_` 접두사를 추가하지만, 동작을 완전히 제어할 수 있습니다.

=== PreAuthenticatedAuthenticationProvider
사전 인증된 제공자는 사용자의 `UserDetails` 객체를 로드하는 것 외에는 할 일이 거의 없습니다.
이는 ``AuthenticationUserDetailsService``에 위임하여 수행합니다.
후자는 표준 ``UserDetailsService``와 유사하지만 단순히 사용자 이름 대신 `Authentication` 객체를 받습니다:

[source,java]
----
public interface AuthenticationUserDetailsService {
	UserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException;
}
----

이 인터페이스는 다른 용도로도 사용될 수 있지만, 사전 인증에서는 이전 섹션에서 본 것처럼 `Authentication` 객체에 포함된 권한에 접근할 수 있게 해줍니다.
`PreAuthenticatedGrantedAuthoritiesUserDetailsService` 클래스가 이 작업을 수행합니다.
또는 `UserDetailsByNameServiceWrapper` 구현을 통해 표준 ``UserDetailsService``에 위임할 수 있습니다.

=== Http403ForbiddenEntryPoint
xref:servlet/authentication/architecture.adoc#servlet-authentication-authenticationentrypoint[`AuthenticationEntryPoint`]는 인증되지 않은 사용자(보호된 리소스에 접근하려고 할 때)에 대한 인증 프로세스를 시작하는 역할을 합니다. 그러나 사전 인증의 경우 이는 적용되지 않습니다.
다른 인증 메커니즘과 함께 사전 인증을 사용하지 않는 경우에만 이 클래스의 인스턴스로 ``ExceptionTranslationFilter``를 구성합니다.
``AbstractPreAuthenticatedProcessingFilter``에 의해 사용자가 거부되어 인증이 null이 되는 경우 호출됩니다.
호출되면 항상 ``403``-금지 응답 코드를 반환합니다.

== 구체적인 구현
X.509 인증은 xref:servlet/authentication/x509.adoc#servlet-x509[자체 장]에서 다룹니다.
여기서는 다른 사전 인증 시나리오를 지원하는 몇 가지 클래스를 살펴보겠습니다.

=== 요청 헤더 인증 (Siteminder)
외부 인증 시스템은 HTTP 요청에 특정 헤더를 설정하여 애플리케이션에 정보를 제공할 수 있습니다.
잘 알려진 예로 Siteminder가 있는데, 이는 ``SM_USER``라는 헤더로 사용자 이름을 전달합니다.
이 메커니즘은 `RequestHeaderAuthenticationFilter` 클래스에서 지원되며, 이 클래스는 헤더에서 사용자 이름만 추출합니다.
기본적으로 ``SM_USER``를 헤더 이름으로 사용합니다.
자세한 내용은 Javadoc을 참조하세요.

[TIP]
====
이런 시스템을 사용할 때, 프레임워크는 어떤 인증 검사도 수행하지 않으므로 외부 시스템이 적절히 구성되어 애플리케이션에 대한 모든 접근을 보호하는 것이 _매우_ 중요합니다.
공격자가 이를 탐지하지 않고 원래 요청의 헤더를 위조할 수 있다면, 원하는 사용자 이름을 선택할 수 있습니다.
====

==== Siteminder 예제 구성
다음 예는 이 필터를 사용하는 일반적인 구성을 보여줍니다:

[source,xml]
----
<security:http>
<!-- 추가적인 http 구성 생략 -->
<security:custom-filter position="PRE_AUTH_FILTER" ref="siteminderFilter" />
</security:http>

<bean id="siteminderFilter" class="org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter">
<property name="principalRequestHeader" value="SM_USER"/>
<property name="authenticationManager" ref="authenticationManager" />
</bean>

<bean id="preauthAuthProvider" class="org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider">
<property name="preAuthenticatedUserDetailsService">
	<bean id="userDetailsServiceWrapper"
		class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper">
	<property name="userDetailsService" ref="userDetailsService"/>
	</bean>
</property>
</bean>

<security:authentication-manager alias="authenticationManager">
<security:authentication-provider ref="preauthAuthProvider" />
</security:authentication-manager>
----

여기서는 xref:servlet/configuration/xml-namespace.adoc#ns-config[security 네임스페이스]가 구성에 사용되고 있다고 가정했습니다.
또한 사용자의 역할을 로드하기 위해 구성에 ``UserDetailsService``(여기서는 "userDetailsService"라고 불림)를 추가했다고 가정합니다.

=== Java EE 컨테이너 인증
`J2eePreAuthenticatedProcessingFilter` 클래스는 ``HttpServletRequest``의 ``userPrincipal`` 속성에서 사용자 이름을 추출합니다.
이 필터의 사용은 일반적으로 앞서 <<j2ee-preauth-details>>에서 설명한 대로 Java EE 역할 사용과 결합됩니다.

코드베이스에 이 접근 방식을 사용하는 {gh-old-samples-url}/xml/preauth[샘플 애플리케이션]이 있으므로, 관심이 있다면 Github에서 코드를 가져와 애플리케이션 컨텍스트 파일을 살펴보세요.