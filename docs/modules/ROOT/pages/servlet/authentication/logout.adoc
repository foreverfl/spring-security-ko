[[jc-logout]]
= 로그아웃 처리

사용자가 xref:servlet/authentication/index.adoc[로그인]할 수 있는 애플리케이션에서는 로그아웃도 가능해야 합니다.

기본적으로 Spring Security는 `/logout` 엔드포인트를 제공하므로 추가 코드가 필요하지 않습니다.

이 섹션의 나머지 부분에서는 고려해야 할 여러 사용 사례를 다룹니다:

* <<logout-java-configuration,로그아웃 아키텍처 이해하기>>
* <<customizing-logout-uris, 로그아웃 또는 로그아웃 성공 URI 커스터마이징>>
* <<permit-logout-endpoints, `/logout` 엔드포인트를 명시적으로 허용해야 하는 경우>>
* <<clear-all-site-data, 사용자 로그아웃 시 쿠키, 스토리지 및/또는 캐시 지우기>>
* OAuth 2.0 사용 시 xref:servlet/oauth2/login/advanced.adoc#oauth2login-advanced-oidc-logout[인증 서버와 로그아웃 조정]
* SAML 2.0 사용 시 xref:servlet/saml2/logout.adoc[ID 제공자와 로그아웃 조정]
* CAS 사용 시 xref:servlet/authentication/cas.adoc#cas-singlelogout[ID 제공자와 로그아웃 조정]

[[logout-architecture]]
[[logout-java-configuration]]
== 로그아웃 아키텍처 이해하기

{spring-boot-reference-url}using.html#using.build-systems.starters[`spring-boot-starter-security` 의존성]을 포함하거나 `@EnableWebSecurity` 어노테이션을 사용하면, Spring Security는 로그아웃 지원을 추가하고 기본적으로 ``GET /logout``과 ``POST /logout`` 모두에 응답합니다.

``GET /logout``을 요청하면 Spring Security는 로그아웃 확인 페이지를 표시합니다.
이는 사용자에게 유용한 이중 확인 메커니즘을 제공할 뿐만 아니라, ``POST /logout``에 필요한 xref:servlet/exploits/csrf.adoc[CSRF 토큰]을 제공하는 간단한 방법도 제공합니다.

xref:servlet/exploits/csrf.adoc[CSRF 보호]가 구성에서 비활성화된 경우, 사용자에게 로그아웃 확인 페이지가 표시되지 않고 로그아웃이 직접 수행됨을 주의하세요.

[TIP]
애플리케이션에서 로그아웃을 수행하기 위해 ``GET /logout``을 사용할 필요는 없습니다.
xref:servlet/exploits/csrf.adoc[필요한 CSRF 토큰]이 요청에 있는 한, 애플리케이션은 단순히 ``POST /logout``을 수행하여 로그아웃을 유도할 수 있습니다.

``POST /logout``을 요청하면 일련의 {security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[``LogoutHandler``]를 사용하여 다음과 같은 기본 작업을 수행합니다:

- HTTP 세션 무효화 ({security-api-url}org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[`SecurityContextLogoutHandler`])
- xref:servlet/authentication/session-management.adoc#use-securitycontextholderstrategy[`SecurityContextHolderStrategy`] 지우기 ({security-api-url}org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[`SecurityContextLogoutHandler`])
- xref:servlet/authentication/persistence.adoc#securitycontextrepository[`SecurityContextRepository`] 지우기 ({security-api-url}org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[`SecurityContextLogoutHandler`])
- xref:servlet/authentication/rememberme.adoc[RememberMe 인증] 정리 (`TokenRememberMeServices` / `PersistentTokenRememberMeServices`)
- 저장된 xref:servlet/exploits/csrf.adoc[CSRF 토큰] 지우기 ({security-api-url}org/springframework/security/web/csrf/CsrfLogoutHandler.html[`CsrfLogoutHandler`])
- `LogoutSuccessEvent` xref:servlet/authentication/events.adoc[발생] ({security-api-url}org/springframework/security/web/authentication/logout/LogoutSuccessEventPublishingLogoutHandler.html[`LogoutSuccessEventPublishingLogoutHandler`])

완료되면 기본 {security-api-url}org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html[`LogoutSuccessHandler`]를 실행하여 ``/login?logout``으로 리다이렉트합니다.

[[customizing-logout-uris]]
== 로그아웃 URI 커스터마이징

``LogoutFilter``가 xref:servlet/architecture.adoc#servlet-filterchain-figure[필터 체인]에서 xref:servlet/authorization/authorize-http-requests.adoc[`AuthorizationFilter`] 앞에 위치하기 때문에, 기본적으로 `/logout` 엔드포인트를 명시적으로 허용할 필요가 없습니다.
따라서 일반적으로 직접 생성한 <<permit-logout-endpoints,사용자 정의 로그아웃 엔드포인트>>만 접근 가능하도록 `permitAll` 구성이 필요합니다.

예를 들어, Spring Security가 일치시키는 URI를 단순히 변경하려면 `logout` DSL에서 다음과 같이 할 수 있습니다:

.Custom Logout Uri
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .logout((logout) -> logout.logoutUrl("/my/logout/uri"))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    logout {
        logoutUrl = "/my/logout/uri"
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<logout logout-url="/my/logout/uri"/>
----
======

이는 단순히 ``LogoutFilter``를 조정하므로 권한 변경이 필요하지 않습니다.

[[permit-logout-endpoints]]
그러나 자체 로그아웃 성공 엔드포인트(또는 드물게 <<creating-custom-logout-endpoint, 자체 로그아웃 엔드포인트>>)를 설정하는 경우, 예를 들어 {spring-framework-reference-url}web.html#spring-web[Spring MVC]를 사용하는 경우, Spring Security에서 이를 허용해야 합니다.
이는 Spring MVC가 Spring Security 이후에 요청을 처리하기 때문입니다.

`authorizeHttpRequests` 또는 ``<intercept-url>``을 사용하여 다음과 같이 할 수 있습니다:

.Custom Logout Endpoint
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        .requestMatchers("/my/success/endpoint").permitAll()
        // ...
    )
    .logout((logout) -> logout.logoutSuccessUrl("/my/success/endpoint"))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    authorizeHttpRequests {
        authorize("/my/success/endpoint", permitAll)
    }
    logout {
        logoutSuccessUrl = "/my/success/endpoint"
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<http>
    <filter-url pattern="/my/success/endpoint" access="permitAll"/>
    <logout logout-success-url="/my/success/endpoint"/>
</http>
----
======

이 예에서는 ``LogoutFilter``에게 완료되면 ``/my/success/endpoint``로 리다이렉트하도록 지시합니다.
그리고 xref:servlet/authorization/authorize-http-requests.adoc[`AuthorizationFilter`]에서 ``/my/success/endpoint`` 엔드포인트를 명시적으로 허용합니다.

두 번 지정하는 것이 번거로울 수 있습니다.
Java 구성을 사용하는 경우 대신 로그아웃 DSL에서 ``permitAll`` 속성을 다음과 같이 설정할 수 있습니다:

.Permitting Custom Logout Endpoints
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .authorizeHttpRequests((authorize) -> authorize
        // ...
    )
    .logout((logout) -> logout
        .logoutSuccessUrl("/my/success/endpoint")
        .permitAll()
    )
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http
    authorizeHttpRequests {
        // ...
    }
    logout {
        logoutSuccessUrl = "/my/success/endpoint"
        permitAll = true
    }
----
======

이렇게 하면 모든 로그아웃 URI를 허용 목록에 자동으로 추가합니다.

[[add-logout-handler]]
== 정리 작업 추가하기

Java 구성을 사용하는 경우, `logout` DSL에서 `addLogoutHandler` 메서드를 호출하여 자체 정리 작업을 추가할 수 있습니다:

.Custom Logout Handler
[tabs]
======
Java::
+
[source,java,role="primary"]
----
CookieClearingLogoutHandler cookies = new CookieClearingLogoutHandler("our-custom-cookie");
http
    .logout((logout) -> logout.addLogoutHandler(cookies))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    logout {
        addLogoutHandler(CookieClearingLogoutHandler("our-custom-cookie"))
    }
}
----
======

[NOTE]
{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[``LogoutHandler``]는 정리 목적이므로 예외를 던지면 안 됩니다.

[TIP]
{security-api-url}org/springframework/security/web/authentication/logout/LogoutHandler.html[`LogoutHandler`]는 함수형 인터페이스이므로 람다로 제공할 수 있습니다.

일부 로그아웃 핸들러 구성은 일반적이어서 `logout` DSL과 `<logout>` 요소에 직접 노출됩니다.
한 예는 세션 무효화를 구성하는 것이고 다른 예는 삭제해야 할 추가 쿠키를 지정하는 것입니다.

예를 들어, 위에서 본 것처럼 {security-api-url}org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html[`CookieClearingLogoutHandler`]를 구성할 수 있습니다.

[[delete-cookies]]
또는 다음과 같이 적절한 구성 값을 설정할 수 있습니다:

[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .logout((logout) -> logout.deleteCookies("our-custom-cookie"))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    logout {
        deleteCookies = "our-custom-cookie"
    }
}
----

Xml::
+
[source,kotlin,role="secondary"]
----
<http>
    <logout delete-cookies="our-custom-cookie"/>
</http>
----
======

[NOTE]
`JSESSIONID` 쿠키를 지정할 필요는 없습니다. {security-api-url}/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[`SecurityContextLogoutHandler`]가 세션을 무효화함으로써 이를 제거하기 때문입니다.

[[clear-all-site-data]]
=== Clear-Site-Data를 사용하여 사용자 로그아웃하기

`Clear-Site-Data` HTTP 헤더는 브라우저가 소유 웹사이트에 속하는 쿠키, 스토리지, 캐시를 지우라는 지시로 지원하는 헤더입니다.
이는 세션 쿠키를 포함한 모든 것이 로그아웃 시 정리되도록 하는 편리하고 안전한 방법입니다.

다음과 같이 Spring Security를 구성하여 로그아웃 시 `Clear-Site-Data` 헤더를 작성하도록 할 수 있습니다:

.Using Clear-Site-Data
[tabs]
======
Java::
+
[source,java,role="primary"]
----
HeaderWriterLogoutHandler clearSiteData = new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter());
http
    .logout((logout) -> logout.addLogoutHandler(clearSiteData))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val clearSiteData = HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter())
http {
    logout {
        addLogoutHandler(clearSiteData)
    }
}
----
======

`ClearSiteDataHeaderWriter` 생성자에 지우고 싶은 항목 목록을 제공합니다.

위의 구성은 모든 사이트 데이터를 지우지만, 다음과 같이 쿠키만 제거하도록 구성할 수도 있습니다:

.Using Clear-Site-Data to Clear Cookies
[tabs]
======
Java::
+
[source,java,role="primary"]
----
HeaderWriterLogoutHandler clearSiteData = new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(Directive.COOKIES));
http
    .logout((logout) -> logout.addLogoutHandler(clearSiteData))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val clearSiteData = HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(Directive.COOKIES))
http {
    logout {
        addLogoutHandler(clearSiteData)
    }
}
----
======

[[customizing-logout-success]]
== 로그아웃 성공 커스터마이징

``logoutSuccessUrl``을 사용하는 것이 대부분의 경우에 충분하지만, 로그아웃이 완료된 후 URL로 리다이렉트하는 것 외에 다른 작업을 수행해야 할 수도 있습니다.
{security-api-url}org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html[`LogoutSuccessHandler`]는 로그아웃 성공 동작을 커스터마이징하기 위한 Spring Security 컴포넌트입니다.

예를 들어, 리다이렉트 대신 상태 코드만 반환하고 싶을 수 있습니다. 이 경우 다음과 같이 성공 핸들러 인스턴스를 제공할 수 있습니다:

.상태 코드 반환 로그아웃 성공 핸들러 사용
[tabs]
======
Java::
+
[source,java,role="primary"]
----
http
    .logout((logout) -> logout.logoutSuccessHandler(new HttpStatusReturningLogoutSuccessHandler()))
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
http {
    logout {
        logoutSuccessHandler = HttpStatusReturningLogoutSuccessHandler()
    }
}
----

Xml::
+
[source,xml,role="secondary"]
----
<bean name="mySuccessHandlerBean" class="org.springframework.security.web.authentication.logout.HttpStatusReturningLogoutSuccessHandler"/>
<http>
    <logout success-handler-ref="mySuccessHandlerBean"/>
</http>
----
======

[TIP]
{security-api-url}org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html[`LogoutSuccessHandler`]는 함수형 인터페이스이므로 람다로 커스텀 핸들러를 제공할 수 있습니다.

[[creating-custom-logout-endpoint]]
== 커스텀 로그아웃 엔드포인트 생성하기

로그아웃을 구성하기 위해 제공된 `logout` DSL을 사용하는 것이 강력히 권장됩니다.
한 가지 이유는 적절하고 완전한 로그아웃을 보장하기 위해 필요한 Spring Security 컴포넌트를 호출하는 것을 잊기 쉽기 때문입니다.

사실, 로그아웃을 수행하기 위한 {spring-framework-reference-url}web.html#spring-web[Spring MVC] 엔드포인트를 만드는 것보다 <<add-logout-handler, 커스텀 ``LogoutHandler``를 등록>>하는 것이 종종 더 간단합니다.

그럼에도 불구하고 커스텀 로그아웃 엔드포인트가 필요한 상황이 있다면, 다음과 같은 엔드포인트를 만들 수 있습니다:

.Custom Logout Endpoint
[tabs]
======
Java::
+
[source,java,role="primary"]
----
@PostMapping("/my/logout")
public String performLogout() {
    // .. 로그아웃 수행
    return "redirect:/home";
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
@PostMapping("/my/logout")
fun performLogout(): String {
    // .. 로그아웃 수행
    return "redirect:/home"
}
----
======

이 경우, 해당 엔드포인트에서 안전하고 완전한 로그아웃을 보장하기 위해 Spring Security의 {security-api-url}/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[`SecurityContextLogoutHandler`]를 호출해야 합니다.
최소한 다음과 같은 작업이 필요합니다:

.Custom Logout Endpoint
[tabs]
======
Java::
+
[source,java,role="primary"]
----
SecurityContextLogoutHandler logoutHandler = new SecurityContextLogoutHandler();

@PostMapping("/my/logout")
public String performLogout(Authentication authentication, HttpServletRequest request, HttpServletResponse response) {
    // .. 로그아웃 수행
    this.logoutHandler.doLogout(request, response, authentication);
    return "redirect:/home";
}
----

Kotlin::
+
[source,kotlin,role="secondary"]
----
val logoutHandler = SecurityContextLogoutHandler()

@PostMapping("/my/logout")
fun performLogout(val authentication: Authentication, val request: HttpServletRequest, val response: HttpServletResponse): String {
    // .. 로그아웃 수행
    this.logoutHandler.doLogout(request, response, authentication)
    return "redirect:/home"
}
----
======

이렇게 하면 필요에 따라 {security-api-url}/org/springframework/security/core/context/SecurityContextHolderStrategy.html[`SecurityContextHolderStrategy`]와 {security-api-url}/org/springframework/security/web/context/SecurityContextRepository.html[`SecurityContextRepository`]를 정리합니다.

또한 <<permit-logout-endpoints, 해당 엔드포인트를 명시적으로 허용>>해야 합니다.

[WARNING]
{security-api-url}/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html[`SecurityContextLogoutHandler`]를 호출하지 않으면 xref:servlet/authentication/architecture.adoc#servlet-authentication-securitycontext[`SecurityContext`]가 후속 요청에서 여전히 사용 가능할 수 있어 사용자가 실제로 로그아웃되지 않을 수 있습니다.

[[testing-logout]]
== 로그아웃 테스트하기
로그아웃을 구성한 후에는 xref:servlet/test/mockmvc/logout.adoc[Spring Security의 MockMvc 지원]을 사용하여 테스트할 수 있습니다.

[[jc-logout-references]]
== 추가 로그아웃 관련 참조

- xref:servlet/test/mockmvc/logout.adoc#test-logout[로그아웃 테스트하기]
- xref:servlet/integrations/servlet-api.adoc#servletapi-logout[HttpServletRequest.logout()]
- xref:servlet/authentication/rememberme.adoc#remember-me-impls[Remember-Me 인터페이스 및 구현]
- xref:servlet/exploits/csrf.adoc#csrf-considerations-logout[로그아웃] (CSRF 주의사항 섹션)
- xref:servlet/authentication/cas.adoc#cas-singlelogout[단일 로그아웃] (CAS 프로토콜)
- Spring Security XML 네임스페이스 섹션의 xref:servlet/appendix/namespace/http.adoc#nsa-logout[logout 요소] 문서